<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Why, after 6 years, I’m over GraphQL</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Why, after 6 years, I’m over GraphQL"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/6crc35gbgjs11cgz7rmwdxx/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="5/31/2024"/><meta property="article:modified_time" content="5/31/2024"/><link rel="canonical" href="https://luke-snaw.github.io//notes/6crc35gbgjs11cgz7rmwdxx/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_buildManifest.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="why-after-6-years-im-over-graphql">Why, after 6 years, I’m over GraphQL<a aria-hidden="true" class="anchor-heading icon-link" href="#why-after-6-years-im-over-graphql"></a></h1>
<blockquote>
<p><a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/">https://bessey.dev/blog/2024/05/24/why-im-over-graphql/</a></p>
</blockquote>
<p>GraphQL is an incredible piece of technology that has captured a lot of mindshare since I first started slinging it in production in 2018. You won’t have to look far back on this (rather inactive) blog to see I have previously championed this technology. After building many a React SPA on top of a hodge podge of untyped JSON REST APIs, I found GraphQL a breath of fresh air. I was truly a GraphQL hype train member.</p>
<p>However, as the years have gone on and I have had the opportunity to deploy to environments where non functional requirements like security, performance, and maintainability were more of a concern, my perspective has changed. In this article I would like to take you through why today, <strong>I would not recommend GraphQL to most people</strong>, and what I think are better alternatives.</p>
<p>Throughout I will use Ruby code with the excellent <a href="https://graphql-ruby.org/">graphql-ruby</a> library for examples, but I believe many of these problems are ubiquitous across choice of language / GraphQL library.</p>
<p>If you know of better solutions and mitigations, please do leave a comment. Now, lets begin…</p>
<h2 id="attack-surface">Attack surface<a aria-hidden="true" class="anchor-heading icon-link" href="#attack-surface"></a></h2>
<p>It was obvious from GraphQL’s beginning that exposing a <strong>query language</strong> to untrusted clients increases the attack surface of the application. Nevertheless, the variety of attacks to consider was even broader than I imagined, and mitigating them is quite a burden. Here’s the worst I’ve had to deal with over the years…</p>
<h3 id="authorisation">Authorisation<a aria-hidden="true" class="anchor-heading icon-link" href="#authorisation"></a></h3>
<p>I think this is the most widely understood risk of GraphQL, so I won’t go into too much depth here. TLDR: if you expose a fully self documenting query API to all clients, you better be damn sure that <strong>every field</strong> is authorised against the current user appropriately to the context in which that field is being fetched. Initially authorising <strong>objects</strong> seems like enough, but this quickly becomes insufficient. For example, say we are the ~Twitter~ X 🙄 API:</p>
<pre><code>query {
  user(id: 321) {
    handle # ✅ I am allowed to view Users public info
    email # 🛑 I shouldn't be able to see their PII just because I can view the User
  }
  user(id: 123) {
    blockedUsers {
      # 🛑 And sometimes I shouldn't even be able to see their public info,
      # because context matters!
      handle
    }
  }
}
</code></pre>
<p>One wonders how much GraphQL holds responsibility for Broken Access Control climbing to the <a href="https://owasp.org/Top10/">OWASP Top 10’s #1 spot</a>. One mitigation here is to make your API secure by default by integrating with <a href="https://graphql-ruby.org/authorization/authorization">your GraphQL library’s authorisation framework</a>. Every object returned and/or field resolved, your authorisation system is called to confirm that the current user has access.</p>
<p>Compare this to the REST world where generally speaking you would authorise <strong>every endpoint</strong>, a far smaller task.</p>
<h3 id="rate-limiting">Rate limiting<a aria-hidden="true" class="anchor-heading icon-link" href="#rate-limiting"></a></h3>
<p>With GraphQL we cannot assume that all requests are equally hard on the server. There is no limit to how big a query can be. Even in a completely empty schema, the types exposed for <a href="https://graphql.org/learn/introspection/">introspection</a> are cyclical, so its possible to craft a valid query that returns MBs of JSON:</p>
<pre><code>query {
  __schema{
    types{
      __typename
      interfaces {
        possibleTypes {
          interfaces {
            possibleTypes {
              name
            }
          }
        }
      }
    }
  }
}
</code></pre>
<p>I just tested this attack against a <strong>very</strong> popular website’s GraphQL API explorer and got a 500 response back after 10 seconds. I just ate 10 seconds of someone’s CPU time running this (whitespace removed) <strong>128 byte</strong> query, and it doesn’t even require me to be logged in.</p>
<p>A common mitigation<sup id="fnref:1" role="doc-noteref"><a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fn:1" class="footnote" rel="footnote">1</a></sup> for this attack is to</p>
<ol>
<li>Estimate the complexity of resolving <strong>every single field in the schema</strong>, and abandon queries that exceed some maximum complexity value</li>
<li>Capture the actual complexity of the run query and take it out of bucket of credits that resets at some interval</li>
</ol>
<p>This calculation is a <a href="https://graphql-ruby.org/queries/complexity_and_depth#prevent-complex-queries">delicate affair to get right</a>. It gets particularly tricky when you are returning list fields whose length is not known prior to execution. You can make an assumption about the complexity of these, but if you are wrong, you may end up rate limiting valid queries or not rate limiting invalid queries.</p>
<p>To make matters worse, its common for the graph that makes up the schema to contain cycles. Lets say you run a blog with Articles which each have multiple Tags, from which you can see associated Articles.</p>
<pre><code>type Article {
  title: String
  tags: [Tag]
}
type Tag {
  name: String
  relatedTags: [Tag]
}
</code></pre>
<p>When estimating the complexity of <code>Tag.relatedTags</code>, you might assume that an article will never have more than 5 tags, so you set this fields complexity to <strong>5</strong> (or 5 * <a href="https://graphql-ruby.org/queries/complexity_and_depth#how-complexity-scoring-works">its children’s complexity</a>). The problem here is that <code>Article.relatedTags</code> can be its own child, so your estimate’s inaccuracy can compound exponentially. The formula is <code>N^5 * 1</code>. So given this query:</p>
<pre><code>query {
  tag(name: "security") {
    relatedTags {
      relatedTags {
        relatedTags {
          relatedTags {
            relatedTags { name }
          }
        }
      }
    }
  }
}
</code></pre>
<p>You expect a complexity of <code>5^5 = 3,125</code>. If an attacker is able to find an Article with 10 tags, they can trigger a query with a “true” complexity of <code>10^5 = 100_000</code>, <strong>20x</strong> greater than estimated.</p>
<p>A partial mitigation here is to <a href="https://graphql-ruby.org/queries/complexity_and_depth#prevent-deeply-nested-queries">prevent deeply nested queries</a>. However, the example above demonstrates that this is not really a defense, as it’ts not an unusually deep query. GraphQL Ruby’s default maximum depth is <strong>13</strong>, this is just 7.</p>
<p>Compare this to rate limiting a REST endpoint, which generally have comparable response times. In this case all you need is a bucketed rate limiter that prevents a user exceeding, say, 200 requests per minute across all endpoints. If you <strong>do</strong> have slower endpoints (say, a CSV report or PDF generator) you can define more aggressive rate limits for these. With some HTTP middleware this is pretty trivial:</p>
<pre><code>Rack::Attack.throttle('API v1', limit: 200, period: 60) do |req|
  if req.path =~ '/api/v1/'
    req.env['rack.session']['session_id']
  end
end
</code></pre>
<h3 id="query-parsing">Query parsing<a aria-hidden="true" class="anchor-heading icon-link" href="#query-parsing"></a></h3>
<p>Before a query is executed, it is first parsed. We once received a pen-test report evidencing that its possible to craft an invalid query string that OOM’d the server. For example:</p>
<pre><code>query {
  __typename @a @b @c @d @e ... # imagine 1k+ more of these
}
</code></pre>
<p>This is a <strong>syntactically</strong> valid query, but invalid for our schema. A spec compliant server will parse this and start building an errors response containing thousands of errors which we found consumed <strong>2,000x</strong> more memory than the query string itself. Because of this memory amplification, its not enough to just limit the payload size, as you will have valid queries that are larger than the the smallest dangerous malicious query.</p>
<p>If your server exposes a concept of maximum number of errors to accrue before abandoning parsing, <a href="https://github.com/rmosolgo/graphql-ruby/issues/4154">this can be mitigated</a>. If not, you’ll have to roll your own solution. There is no REST equivalent to this attack of this severity.</p>
<h2 id="performance">Performance<a aria-hidden="true" class="anchor-heading icon-link" href="#performance"></a></h2>
<p>When it comes to performance in GraphQL people often talk about it’s incompatibility with HTTP caching. For me personally, this has not been an issue. For SaaS applications, data is usually highly user specific and serving stale data is unacceptable, so I have not found myself missing response caches (or the cache invalidation bugs they cause…).</p>
<p>The major performance problems I <strong>did</strong> find myself dealing with were…</p>
<h3 id="data-fetching-and-the-n1-problem">Data fetching and the N+1 problem<a aria-hidden="true" class="anchor-heading icon-link" href="#data-fetching-and-the-n1-problem"></a></h3>
<p>I think this issue is pretty widely understood nowadays. TLDR: if a field resolver hits an external data source such as a DB or HTTP API, and it is nested in a list containing N items, it will do those calls N times.</p>
<p>This is not a unique problem to GraphQL, and actually the strict GraphQL resolution algorithm has allowed most libraries to share a common solution: <a href="https://graphql-ruby.org/dataloader/overview.html">the Dataloader pattern</a>. Unique to GraphQL though is the fact that since it is a query language, this can <strong>become</strong> a problem with no backend changes when a client modifies a query. As a result, I found you end up having to defensively introduce the Dataloader abstraction everywhere <em>just in case</em> a client ends up fetching a field in a list context in the future. This is a lot of boilerplate to write and maintain.</p>
<p>Meanwhile, in REST, we can generally hoist nested N+1 queries up to the controller, which I think is a pattern much easier to wrap your head around:</p>
<pre><code>class BlogsController &#x3C; ApplicationController
  def index
    @latest_blogs = Blog.limit(25).includes(:author, :tags)
    render json: BlogSerializer.render(@latest_blogs)
  end

  def show
    # No prefetching necessary here since N=1
    @blog = Blog.find(params[:id])
    render json: BlogSerializer.render(@blog)
  end
end
</code></pre>
<h3 id="authorisation-and-the-n1-problem">Authorisation and the N+1 problem<a aria-hidden="true" class="anchor-heading icon-link" href="#authorisation-and-the-n1-problem"></a></h3>
<p>But wait, there’s more N+1s! If you followed the advice earlier of integrating with your library’s authorisation framework, you’ve now got a whole new category of N+1 problems to deal with. Lets continue with our X API example from earlier:</p>
<pre><code>class UserType &#x3C; GraphQL::BaseObject
  field :handle, String
  field :birthday, authorize_with: :view_pii
end

class UserPolicy &#x3C; ApplicationPolicy
  def view_pii?
    # Oh no, I hit the DB to fetch the user's friends
    user.friends_with?(record)
  end
end
</code></pre>
<pre><code>query {
  me {
    friends { # returns N Users
      handle
      birthday # runs UserPolicy#view_pii? N times
    }
  }
}
</code></pre>
<p>This is actually trickier to deal with than our previous example, because authorisation code is not always run in a GraphQL context. It may for example be run in a background job or an HTML endpoint. That means we can’t just reach for a Dataloader naively, because Dataloaders expect to be run from within GraphQL (in the Ruby implementation anyway).</p>
<p>In my experience, this is actually <strong>the biggest source of performance issues</strong>. We would regularly find that our queries were spending more time authorising data than anything else. Again, this problem simply does not exist in the REST world.</p>
<p>I have mitigated this using nasty things like <a href="https://api.rubyonrails.org/classes/ActiveSupport/CurrentAttributes.html">request level globals</a> to memoise data across policy calls, but its never felt great.</p>
<h2 id="coupling">Coupling<a aria-hidden="true" class="anchor-heading icon-link" href="#coupling"></a></h2>
<p>In my experience, in a mature GraphQL codebase, your business logic is forced into the <a href="https://en.wikipedia.org/wiki/Transport_layer">transport layer</a>. This happens through a number of mechanisms, some of which we’ve already talked about:</p>
<ul>
<li>Solving data authorisation leads to peppering authorisation rules throughout your GraphQL types</li>
<li>Solving mutation / argument authorisation leads to peppering authorisation rules throughout your GraphQL arguments</li>
<li>Solving resolver data fetching N+1s leads to moving this logic into GraphQL specific dataloaders</li>
<li>Leveraging the (lovely) <a href="https://graphql-ruby.org/pagination/using_connections">Relay Connection</a> pattern leads to moving data fetching logic into GraphQL specific <a href="https://graphql-ruby.org/pagination/custom_connections">custom connection objects</a></li>
</ul>
<p>The net effect of all of this is to meaningfully test your application you <strong>must</strong> extensively test at the integration layer, i.e. by running GraphQL queries. I have found this makes for a painful experience. Any errors encountered are captured by the framework, leading to the fun task of reading stack traces in JSON GraphQL error responses. Since so much around authorisation and Dataloaders happens inside the framework, debugging is often much harder as the breakpoint you want is not in application code.</p>
<p>And of course, again, since its a query language you’re going to be writing a lot more tests to confirm that all those argument and field level behaviours we mentioned are working correctly.</p>
<h2 id="complexity">Complexity<a aria-hidden="true" class="anchor-heading icon-link" href="#complexity"></a></h2>
<p>Taken in aggregate, the various mitigations to security and performance issues we’ve gone through add <strong>significant</strong> complexity to a codebase. It’s not that REST does not have these problems (though it certainly has fewer), it’s just that the REST solutions are generally much simpler for a backend developer to implement and understand.</p>
<h2 id="and-more">And more…<a aria-hidden="true" class="anchor-heading icon-link" href="#and-more"></a></h2>
<p>So those are the major reasons I am, for the most part, over GraphQL. I have a few more peeves, but to keep this article growing further I’ll summarise them here..</p>
<ul>
<li>GraphQL discourages breaking changes and provides no tools to deal with them. This adds needless complexity for those who control all their clients, who will have to <a href="https://graphql-ruby.org/changesets/overview.html">find workarounds</a>.</li>
<li>Reliance on HTTP response codes turns up everywhere in tooling, so dealing with the fact that 200 can mean everything from everything is Ok through to everything is down can be quite annoying.</li>
<li>Fetching all your data in one query in the HTTP 2+ age is often not beneficial to response time, in fact it will worsen it if your server is not parallelised, vs sending separate requests to separate servers to process in parallel.</li>
</ul>
<h2 id="alternatives">Alternatives<a aria-hidden="true" class="anchor-heading icon-link" href="#alternatives"></a></h2>
<p>Ok, end of the rant. What would I recommend instead? To be up front, I am definitely early in the <a href="https://en.wikipedia.org/wiki/Gartner_hype_cycle">hype cycle</a> here, but right now my view is that if you:</p>
<ol>
<li>Control all your clients</li>
<li>Have ≤3 clients</li>
<li>Have a client written in a statically typed language</li>
<li>Are using >1 language across the server and clients<sup id="fnref:2" role="doc-noteref"><a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fn:2" class="footnote" rel="footnote">2</a></sup></li>
</ol>
<p>You are probably better off exposing an <strong>OpenAPI 3.0+</strong> compliant JSON REST API. If, as in my experience, the main thing your frontend devs like about GraphQL is its self documenting type safe nature, I think this will work well for you. Tooling in this area has improved a lot since GraphQL came on the scene; there are many options for generating typed client code even down to <a href="https://orval.dev/overview">framework specific data fetching libraries</a>. My experience so far is pretty close to “the best parts of what <strong>I</strong> used GraphQL for, without the complexity Facebook needed”.</p>
<p>As with GraphQL there’s a couple of implementation approach…</p>
<p><strong>Implementation first</strong> tooling generates OpenAPI specs from a typed / type hinted server. <a href="https://fastapi.tiangolo.com/">FastAPI</a> in Python and <a href="https://github.com/lukeautry/tsoa">tsoa</a> in TypeScript are good examples of this approach<sup id="fnref:3" role="doc-noteref"><a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fn:3" class="footnote" rel="footnote">3</a></sup>. This is the approach I have the most experience with, and I think it works well.</p>
<p><strong>Specification first</strong> is equivalent to “schema first” in GraphQL. Spec first tooling generates code from a hand written spec. I can’t say I’ve ever looked at an OpenAPI YAML file and thought “I would love to have written that myself”, but the recent release of <a href="https://typespec.io/">TypeSpec</a> changes things entirely. With it could come a quite elegant schema first workflow:</p>
<ol>
<li>Write a succinct human readable TypeSpec schema</li>
<li>Generate an OpenAPI YAML spec from it</li>
<li>Generate statically typed API client for your frontend language of choice (e.g. <a href="https://orval.dev/overview">TypeScript</a>)</li>
<li>Generate statically typed server handlers for your backend language &#x26; server framework (e.g. <a href="https://docs.buildwithfern.com/server-boilerplate/server-boilerplate/express-js">TypeScript + Express</a>, <a href="https://docs.buildwithfern.com/server-boilerplate/server-boilerplate/fast-api">Python + FastAPI</a>, <a href="https://github.com/deepmap/oapi-codegen">Go + Echo</a>)</li>
<li>Write an implementation for that handler that compiles, safe in the knowledge that it will be type safe</li>
</ol>
<p>This approach is less mature but I think has a lot of promise.</p>
<p>To me, it seems like powerful <strong>and</strong> simpler options are here, and I’m excited to learn their drawbacks next 😄.</p>
<ol>
<li>Persisted queries are also a mitigation for this and many attacks, but if you actually want to expose a customer facing GraphQL API, persisted queries are not an option. <a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fnref:1">↩</a></li>
<li>Otherwise a language specific solution like <a href="https://trpc.io/">tRPC</a> might be a better fit. <a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fnref:2">↩</a></li>
<li>In Ruby, I guess because type hints are not popular, there is no equivalent approach. Instead we have <a href="https://github.com/rswag/rswag">rswag</a> which generates OpenAPI specs from request specs. It would be cool if we could build an OpenAPI spec from Sorbet / RBS typed endpoints! <a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fnref:3">↩</a></li>
</ol>
<hr>
<h2 id="gn-6년-만에-graphql을-그만둔-이유">GN⁺: 6년 만에 GraphQL을 그만둔 이유<a aria-hidden="true" class="anchor-heading icon-link" href="#gn-6년-만에-graphql을-그만둔-이유"></a></h2>
<blockquote>
<p><a href="https://news.hada.io/topic?id=15097">https://news.hada.io/topic?id=15097</a></p>
</blockquote>
<ul>
<li>2018년부터 6년간 사용 후, 진정한 GraphQL 열혈 팬이었지만 이제 회의가 듦</li>
<li>이제 GraphQL을 추천하지 않는 이유와 더 나은 대안이 무엇이라고 생각하는지에 대해 설명하고자 함</li>
</ul>
<h3 id="공격-표면">공격 표면<a aria-hidden="true" class="anchor-heading icon-link" href="#공격-표면"></a></h3>
<ul>
<li>GraphQL은 쿼리 언어를 노출하여 공격 표면을 넓히는 위험이 있음.</li>
<li>권한 부여와 관련된 문제는 특히 중요함.
<ul>
<li>모든 필드에 대해 적절한 권한 검사가 필요함.</li>
<li>REST API에서는 엔드포인트마다 권한을 검사하는 것이 더 간단함.</li>
</ul>
</li>
</ul>
<h4 id="권한-부여">권한 부여<a aria-hidden="true" class="anchor-heading icon-link" href="#권한-부여"></a></h4>
<ul>
<li>모든 필드에 대해 사용자 권한을 확인해야 함.</li>
<li>REST API에서는 엔드포인트마다 권한을 검사하는 것이 더 간단함.</li>
</ul>
<h4 id="속도-제한">속도 제한<a aria-hidden="true" class="anchor-heading icon-link" href="#속도-제한"></a></h4>
<ul>
<li>GraphQL 쿼리는 크기 제한이 없어서 서버에 큰 부담을 줄 수 있음.</li>
<li>쿼리 복잡성을 추정하고, 일정 복잡성을 초과하는 쿼리를 제한하는 방법이 있음.</li>
<li>REST API에서는 요청 수를 제한하는 것이 더 간단함.</li>
</ul>
<h4 id="쿼리-파싱">쿼리 파싱<a aria-hidden="true" class="anchor-heading icon-link" href="#쿼리-파싱"></a></h4>
<ul>
<li>잘못된 쿼리 문자열이 서버의 메모리를 과도하게 사용할 수 있음.</li>
<li>최대 오류 수를 설정하여 파싱을 중단하는 방법이 있음.</li>
</ul>
<h3 id="성능">성능<a aria-hidden="true" class="anchor-heading icon-link" href="#성능"></a></h3>
<h4 id="데이터-페칭과-n1-문제">데이터 페칭과 N+1 문제<a aria-hidden="true" class="anchor-heading icon-link" href="#데이터-페칭과-n1-문제"></a></h4>
<ul>
<li>필드 리졸버가 외부 데이터 소스를 여러 번 호출할 수 있음.</li>
<li>Dataloader 패턴을 사용하여 문제를 해결할 수 있음.</li>
<li>REST에서는 컨트롤러에서 N+1 문제를 해결하는 것이 더 간단함.</li>
</ul>
<h4 id="권한-부여와-n1-문제">권한 부여와 N+1 문제<a aria-hidden="true" class="anchor-heading icon-link" href="#권한-부여와-n1-문제"></a></h4>
<ul>
<li>권한 부여 코드가 N+1 문제를 일으킬 수 있음.</li>
<li>REST에서는 이 문제가 발생하지 않음.</li>
</ul>
<h3 id="결합">결합<a aria-hidden="true" class="anchor-heading icon-link" href="#결합"></a></h3>
<ul>
<li>GraphQL 코드베이스는 비즈니스 로직이 전송 계층에 강하게 결합됨.</li>
<li>통합 테스트가 필요하고, 디버깅이 어려움.</li>
</ul>
<h3 id="복잡성">복잡성<a aria-hidden="true" class="anchor-heading icon-link" href="#복잡성"></a></h3>
<ul>
<li>GraphQL의 보안 및 성능 문제를 해결하기 위한 다양한 방법들이 코드베이스의 복잡성을 증가시킴.</li>
<li>REST 솔루션은 일반적으로 더 간단함.</li>
</ul>
<h3 id="대안">대안<a aria-hidden="true" class="anchor-heading icon-link" href="#대안"></a></h3>
<ul>
<li>OpenAPI 3.0+를 사용하는 JSON REST API를 추천함.</li>
<li>정적 타입 언어로 작성된 클라이언트가 있는 경우, OpenAPI가 더 나은 선택일 수 있음.</li>
<li>OpenAPI는 자동으로 타입 안전한 클라이언트 코드를 생성할 수 있음.</li>
</ul>
<h2 id="gn의-의견">GN⁺의 의견<a aria-hidden="true" class="anchor-heading icon-link" href="#gn의-의견"></a></h2>
<ul>
<li>GraphQL은 강력하지만, 보안과 성능 문제를 해결하는 데 많은 노력이 필요함.</li>
<li>REST API는 상대적으로 간단하고, 많은 경우에 더 적합할 수 있음.</li>
<li>OpenAPI는 타입 안전성과 자동화된 도구를 제공하여 개발 생산성을 높일 수 있음.</li>
<li>GraphQL을 도입할 때는 보안 및 성능 문제를 충분히 고려해야 함.</li>
<li>REST와 GraphQL의 장단점을 비교하여 프로젝트에 맞는 기술을 선택하는 것이 중요함.</li>
</ul>
<h2 id="hacker-news-의견"><a href="https://news.ycombinator.com/item?id=40521518">Hacker News 의견</a><a aria-hidden="true" class="anchor-heading icon-link" href="#hacker-news-의견"></a></h2>
<ul>
<li>GraphQL 도입 후 많은 문제를 겪었음. 권한 관리와 성능 문제로 인해 더 이상 사용하고 싶지 않음. 프론트엔드에서만 사용하면 좋을 수 있지만, 백엔드와의 통합은 복잡함.</li>
<li>REST를 먼저 배우고 gRPC를 사용해보니 타입 안전한 API가 매력적이었음. GraphQL은 많은 이점이 없고, 데이터베이스처럼 동작할 때만 유용함.</li>
<li>두 개의 GraphQL 프로젝트에서 일했는데, 초기에는 작게 시작했지만 시간이 지나면서 복잡해졌음. 디버깅이 어렵고 성능 문제가 발생함. REST와 RPC가 더 간단하고 관리하기 쉬움.</li>
<li>Hasura 창립자로서 GraphQL 사용의 진화를 보았음. GraphQL은 데이터 레이어가 없으면 구축하기 매우 어려움. REST 위에 GraphQL을 사용하는 것은 비효율적임. GraphQL의 주요 사용 사례는 여러 데이터 소비자가 있는 경우임.</li>
<li>프론트엔드 엔지니어들이 쿼리를 중앙 라이브러리에 저장하고 재사용하는데, 이는 GraphQL을 REST처럼 사용하는 것과 같음.</li>
<li>OpenAPI, GraphQL, JSON/HTTP, gRPC를 사용해본 경험으로, GraphQL 쿼리를 제한하는 것이 성능과 보안 문제를 완화할 수 있음. Buf Connect가 대부분의 프로젝트에 가장 적합한 타협점임.</li>
<li>Facebook에서 GraphQL을 사용한 경험으로, 많은 사람들이 GraphQL이 해결하려는 문제를 가지고 있지 않음. Facebook은 버전 관리와 복잡한 객체 모델을 다루기 위해 GraphQL을 사용함.</li>
<li>Facebook에서 GraphQL이 잘 작동하는 이유는 모든 사용자가 로그인하고, 보안이 모든 필드에 내재되어 있기 때문임. SPA와 로그인 요구 사항이 있는 경우 GraphQL이 유용할 수 있음.</li>
<li>GraphQL을 사용해보니 처음에는 좋았지만, 결국 많은 추가 작업과 중복이 필요했음. JSON-RPC 타입 엔드포인트로 시작하고 필요한 기능을 추가하는 것이 더 나았음.</li>
<li>작은 프로젝트에서 GraphQL을 사용해보니 거의 모든 부분이 좋았음. Apollo Client와 graphql-codegen을 사용해 Vue 3용 타입과 함수를 생성했음. 일부 문제는 있었지만, 타입 수준에서 많은 오류를 잡아줌.</li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#attack-surface" title="Attack surface">Attack surface</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#authorisation" title="Authorisation">Authorisation</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#rate-limiting" title="Rate limiting">Rate limiting</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#query-parsing" title="Query parsing">Query parsing</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#performance" title="Performance">Performance</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#data-fetching-and-the-n1-problem" title="Data fetching and the N+1 problem">Data fetching and the N+1 problem</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#authorisation-and-the-n1-problem" title="Authorisation and the N+1 problem">Authorisation and the N+1 problem</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#coupling" title="Coupling">Coupling</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#complexity" title="Complexity">Complexity</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#and-more" title="And more…">And more…</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#alternatives" title="Alternatives">Alternatives</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#gn-6년-만에-graphql을-그만둔-이유" title="GN⁺: 6년 만에 GraphQL을 그만둔 이유">GN⁺: 6년 만에 GraphQL을 그만둔 이유</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#공격-표면" title="공격 표면">공격 표면</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#권한-부여" title="권한 부여">권한 부여</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#속도-제한" title="속도 제한">속도 제한</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#쿼리-파싱" title="쿼리 파싱">쿼리 파싱</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#성능" title="성능">성능</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#데이터-페칭과-n1-문제" title="데이터 페칭과 N+1 문제">데이터 페칭과 N+1 문제</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#권한-부여와-n1-문제" title="권한 부여와 N+1 문제">권한 부여와 N+1 문제</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#결합" title="결합">결합</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#복잡성" title="복잡성">복잡성</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#대안" title="대안">대안</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#gn의-의견" title="GN⁺의 의견">GN⁺의 의견</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#hacker-news-의견" title="Hacker News 의견">Hacker News 의견</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"6crc35gbgjs11cgz7rmwdxx","title":"Why, after 6 years, I’m over GraphQL","desc":"","updated":1717130321611,"created":1717130172689,"custom":{},"fname":"dev.back-end.why-im-over-graphql","type":"note","vault":{"fsPath":"vault"},"contentHash":"12d8b19de822ea72925fae55a0091262","links":[],"anchors":{"attack-surface":{"type":"header","text":"Attack surface","value":"attack-surface","line":18,"column":0,"depth":2},"authorisation":{"type":"header","text":"Authorisation","value":"authorisation","line":22,"column":0,"depth":3},"rate-limiting":{"type":"header","text":"Rate limiting","value":"rate-limiting","line":46,"column":0,"depth":3},"query-parsing":{"type":"header","text":"Query parsing","value":"query-parsing","line":123,"column":0,"depth":3},"performance":{"type":"header","text":"Performance","value":"performance","line":137,"column":0,"depth":2},"data-fetching-and-the-n1-problem":{"type":"header","text":"Data fetching and the N+1 problem","value":"data-fetching-and-the-n1-problem","line":143,"column":0,"depth":3},"authorisation-and-the-n1-problem":{"type":"header","text":"Authorisation and the N+1 problem","value":"authorisation-and-the-n1-problem","line":166,"column":0,"depth":3},"coupling":{"type":"header","text":"Coupling","value":"coupling","line":201,"column":0,"depth":2},"complexity":{"type":"header","text":"Complexity","value":"complexity","line":214,"column":0,"depth":2},"and-more":{"type":"header","text":"And more…","value":"and-more","line":218,"column":0,"depth":2},"alternatives":{"type":"header","text":"Alternatives","value":"alternatives","line":226,"column":0,"depth":2},"gn-6년-만에-graphql을-그만둔-이유":{"type":"header","text":"GN⁺: 6년 만에 GraphQL을 그만둔 이유","value":"gn-6년-만에-graphql을-그만둔-이유","line":259,"column":0,"depth":2},"공격-표면":{"type":"header","text":"공격 표면","value":"공격-표면","line":266,"column":0,"depth":3},"권한-부여":{"type":"header","text":"권한 부여","value":"권한-부여","line":273,"column":0,"depth":4},"속도-제한":{"type":"header","text":"속도 제한","value":"속도-제한","line":278,"column":0,"depth":4},"쿼리-파싱":{"type":"header","text":"쿼리 파싱","value":"쿼리-파싱","line":284,"column":0,"depth":4},"성능":{"type":"header","text":"성능","value":"성능","line":289,"column":0,"depth":3},"데이터-페칭과-n1-문제":{"type":"header","text":"데이터 페칭과 N+1 문제","value":"데이터-페칭과-n1-문제","line":291,"column":0,"depth":4},"권한-부여와-n1-문제":{"type":"header","text":"권한 부여와 N+1 문제","value":"권한-부여와-n1-문제","line":297,"column":0,"depth":4},"결합":{"type":"header","text":"결합","value":"결합","line":302,"column":0,"depth":3},"복잡성":{"type":"header","text":"복잡성","value":"복잡성","line":307,"column":0,"depth":3},"대안":{"type":"header","text":"대안","value":"대안","line":312,"column":0,"depth":3},"gn의-의견":{"type":"header","text":"GN⁺의 의견","value":"gn의-의견","line":318,"column":0,"depth":2},"hacker-news-의견":{"type":"header","text":"Hacker News 의견","value":"hacker-news-의견","line":326,"column":0,"depth":2}},"children":[],"parent":"6w36dgapan7eummy1q6jpx1","data":{}},"body":"\u003ch1 id=\"why-after-6-years-im-over-graphql\"\u003eWhy, after 6 years, I’m over GraphQL\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#why-after-6-years-im-over-graphql\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://bessey.dev/blog/2024/05/24/why-im-over-graphql/\"\u003ehttps://bessey.dev/blog/2024/05/24/why-im-over-graphql/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eGraphQL is an incredible piece of technology that has captured a lot of mindshare since I first started slinging it in production in 2018. You won’t have to look far back on this (rather inactive) blog to see I have previously championed this technology. After building many a React SPA on top of a hodge podge of untyped JSON REST APIs, I found GraphQL a breath of fresh air. I was truly a GraphQL hype train member.\u003c/p\u003e\n\u003cp\u003eHowever, as the years have gone on and I have had the opportunity to deploy to environments where non functional requirements like security, performance, and maintainability were more of a concern, my perspective has changed. In this article I would like to take you through why today, \u003cstrong\u003eI would not recommend GraphQL to most people\u003c/strong\u003e, and what I think are better alternatives.\u003c/p\u003e\n\u003cp\u003eThroughout I will use Ruby code with the excellent \u003ca href=\"https://graphql-ruby.org/\"\u003egraphql-ruby\u003c/a\u003e library for examples, but I believe many of these problems are ubiquitous across choice of language / GraphQL library.\u003c/p\u003e\n\u003cp\u003eIf you know of better solutions and mitigations, please do leave a comment. Now, lets begin…\u003c/p\u003e\n\u003ch2 id=\"attack-surface\"\u003eAttack surface\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#attack-surface\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIt was obvious from GraphQL’s beginning that exposing a \u003cstrong\u003equery language\u003c/strong\u003e to untrusted clients increases the attack surface of the application. Nevertheless, the variety of attacks to consider was even broader than I imagined, and mitigating them is quite a burden. Here’s the worst I’ve had to deal with over the years…\u003c/p\u003e\n\u003ch3 id=\"authorisation\"\u003eAuthorisation\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#authorisation\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eI think this is the most widely understood risk of GraphQL, so I won’t go into too much depth here. TLDR: if you expose a fully self documenting query API to all clients, you better be damn sure that \u003cstrong\u003eevery field\u003c/strong\u003e is authorised against the current user appropriately to the context in which that field is being fetched. Initially authorising \u003cstrong\u003eobjects\u003c/strong\u003e seems like enough, but this quickly becomes insufficient. For example, say we are the ~Twitter~ X 🙄 API:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003equery {\n  user(id: 321) {\n    handle # ✅ I am allowed to view Users public info\n    email # 🛑 I shouldn't be able to see their PII just because I can view the User\n  }\n  user(id: 123) {\n    blockedUsers {\n      # 🛑 And sometimes I shouldn't even be able to see their public info,\n      # because context matters!\n      handle\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne wonders how much GraphQL holds responsibility for Broken Access Control climbing to the \u003ca href=\"https://owasp.org/Top10/\"\u003eOWASP Top 10’s #1 spot\u003c/a\u003e. One mitigation here is to make your API secure by default by integrating with \u003ca href=\"https://graphql-ruby.org/authorization/authorization\"\u003eyour GraphQL library’s authorisation framework\u003c/a\u003e. Every object returned and/or field resolved, your authorisation system is called to confirm that the current user has access.\u003c/p\u003e\n\u003cp\u003eCompare this to the REST world where generally speaking you would authorise \u003cstrong\u003eevery endpoint\u003c/strong\u003e, a far smaller task.\u003c/p\u003e\n\u003ch3 id=\"rate-limiting\"\u003eRate limiting\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#rate-limiting\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWith GraphQL we cannot assume that all requests are equally hard on the server. There is no limit to how big a query can be. Even in a completely empty schema, the types exposed for \u003ca href=\"https://graphql.org/learn/introspection/\"\u003eintrospection\u003c/a\u003e are cyclical, so its possible to craft a valid query that returns MBs of JSON:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003equery {\n  __schema{\n    types{\n      __typename\n      interfaces {\n        possibleTypes {\n          interfaces {\n            possibleTypes {\n              name\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI just tested this attack against a \u003cstrong\u003every\u003c/strong\u003e popular website’s GraphQL API explorer and got a 500 response back after 10 seconds. I just ate 10 seconds of someone’s CPU time running this (whitespace removed) \u003cstrong\u003e128 byte\u003c/strong\u003e query, and it doesn’t even require me to be logged in.\u003c/p\u003e\n\u003cp\u003eA common mitigation\u003csup id=\"fnref:1\" role=\"doc-noteref\"\u003e\u003ca href=\"https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fn:1\" class=\"footnote\" rel=\"footnote\"\u003e1\u003c/a\u003e\u003c/sup\u003e for this attack is to\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eEstimate the complexity of resolving \u003cstrong\u003eevery single field in the schema\u003c/strong\u003e, and abandon queries that exceed some maximum complexity value\u003c/li\u003e\n\u003cli\u003eCapture the actual complexity of the run query and take it out of bucket of credits that resets at some interval\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis calculation is a \u003ca href=\"https://graphql-ruby.org/queries/complexity_and_depth#prevent-complex-queries\"\u003edelicate affair to get right\u003c/a\u003e. It gets particularly tricky when you are returning list fields whose length is not known prior to execution. You can make an assumption about the complexity of these, but if you are wrong, you may end up rate limiting valid queries or not rate limiting invalid queries.\u003c/p\u003e\n\u003cp\u003eTo make matters worse, its common for the graph that makes up the schema to contain cycles. Lets say you run a blog with Articles which each have multiple Tags, from which you can see associated Articles.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Article {\n  title: String\n  tags: [Tag]\n}\ntype Tag {\n  name: String\n  relatedTags: [Tag]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen estimating the complexity of \u003ccode\u003eTag.relatedTags\u003c/code\u003e, you might assume that an article will never have more than 5 tags, so you set this fields complexity to \u003cstrong\u003e5\u003c/strong\u003e (or 5 * \u003ca href=\"https://graphql-ruby.org/queries/complexity_and_depth#how-complexity-scoring-works\"\u003eits children’s complexity\u003c/a\u003e). The problem here is that \u003ccode\u003eArticle.relatedTags\u003c/code\u003e can be its own child, so your estimate’s inaccuracy can compound exponentially. The formula is \u003ccode\u003eN^5 * 1\u003c/code\u003e. So given this query:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003equery {\n  tag(name: \"security\") {\n    relatedTags {\n      relatedTags {\n        relatedTags {\n          relatedTags {\n            relatedTags { name }\n          }\n        }\n      }\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou expect a complexity of \u003ccode\u003e5^5 = 3,125\u003c/code\u003e. If an attacker is able to find an Article with 10 tags, they can trigger a query with a “true” complexity of \u003ccode\u003e10^5 = 100_000\u003c/code\u003e, \u003cstrong\u003e20x\u003c/strong\u003e greater than estimated.\u003c/p\u003e\n\u003cp\u003eA partial mitigation here is to \u003ca href=\"https://graphql-ruby.org/queries/complexity_and_depth#prevent-deeply-nested-queries\"\u003eprevent deeply nested queries\u003c/a\u003e. However, the example above demonstrates that this is not really a defense, as it’ts not an unusually deep query. GraphQL Ruby’s default maximum depth is \u003cstrong\u003e13\u003c/strong\u003e, this is just 7.\u003c/p\u003e\n\u003cp\u003eCompare this to rate limiting a REST endpoint, which generally have comparable response times. In this case all you need is a bucketed rate limiter that prevents a user exceeding, say, 200 requests per minute across all endpoints. If you \u003cstrong\u003edo\u003c/strong\u003e have slower endpoints (say, a CSV report or PDF generator) you can define more aggressive rate limits for these. With some HTTP middleware this is pretty trivial:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eRack::Attack.throttle('API v1', limit: 200, period: 60) do |req|\n  if req.path =~ '/api/v1/'\n    req.env['rack.session']['session_id']\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"query-parsing\"\u003eQuery parsing\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#query-parsing\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBefore a query is executed, it is first parsed. We once received a pen-test report evidencing that its possible to craft an invalid query string that OOM’d the server. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003equery {\n  __typename @a @b @c @d @e ... # imagine 1k+ more of these\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is a \u003cstrong\u003esyntactically\u003c/strong\u003e valid query, but invalid for our schema. A spec compliant server will parse this and start building an errors response containing thousands of errors which we found consumed \u003cstrong\u003e2,000x\u003c/strong\u003e more memory than the query string itself. Because of this memory amplification, its not enough to just limit the payload size, as you will have valid queries that are larger than the the smallest dangerous malicious query.\u003c/p\u003e\n\u003cp\u003eIf your server exposes a concept of maximum number of errors to accrue before abandoning parsing, \u003ca href=\"https://github.com/rmosolgo/graphql-ruby/issues/4154\"\u003ethis can be mitigated\u003c/a\u003e. If not, you’ll have to roll your own solution. There is no REST equivalent to this attack of this severity.\u003c/p\u003e\n\u003ch2 id=\"performance\"\u003ePerformance\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#performance\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWhen it comes to performance in GraphQL people often talk about it’s incompatibility with HTTP caching. For me personally, this has not been an issue. For SaaS applications, data is usually highly user specific and serving stale data is unacceptable, so I have not found myself missing response caches (or the cache invalidation bugs they cause…).\u003c/p\u003e\n\u003cp\u003eThe major performance problems I \u003cstrong\u003edid\u003c/strong\u003e find myself dealing with were…\u003c/p\u003e\n\u003ch3 id=\"data-fetching-and-the-n1-problem\"\u003eData fetching and the N+1 problem\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#data-fetching-and-the-n1-problem\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eI think this issue is pretty widely understood nowadays. TLDR: if a field resolver hits an external data source such as a DB or HTTP API, and it is nested in a list containing N items, it will do those calls N times.\u003c/p\u003e\n\u003cp\u003eThis is not a unique problem to GraphQL, and actually the strict GraphQL resolution algorithm has allowed most libraries to share a common solution: \u003ca href=\"https://graphql-ruby.org/dataloader/overview.html\"\u003ethe Dataloader pattern\u003c/a\u003e. Unique to GraphQL though is the fact that since it is a query language, this can \u003cstrong\u003ebecome\u003c/strong\u003e a problem with no backend changes when a client modifies a query. As a result, I found you end up having to defensively introduce the Dataloader abstraction everywhere \u003cem\u003ejust in case\u003c/em\u003e a client ends up fetching a field in a list context in the future. This is a lot of boilerplate to write and maintain.\u003c/p\u003e\n\u003cp\u003eMeanwhile, in REST, we can generally hoist nested N+1 queries up to the controller, which I think is a pattern much easier to wrap your head around:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass BlogsController \u0026#x3C; ApplicationController\n  def index\n    @latest_blogs = Blog.limit(25).includes(:author, :tags)\n    render json: BlogSerializer.render(@latest_blogs)\n  end\n\n  def show\n    # No prefetching necessary here since N=1\n    @blog = Blog.find(params[:id])\n    render json: BlogSerializer.render(@blog)\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"authorisation-and-the-n1-problem\"\u003eAuthorisation and the N+1 problem\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#authorisation-and-the-n1-problem\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBut wait, there’s more N+1s! If you followed the advice earlier of integrating with your library’s authorisation framework, you’ve now got a whole new category of N+1 problems to deal with. Lets continue with our X API example from earlier:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eclass UserType \u0026#x3C; GraphQL::BaseObject\n  field :handle, String\n  field :birthday, authorize_with: :view_pii\nend\n\nclass UserPolicy \u0026#x3C; ApplicationPolicy\n  def view_pii?\n    # Oh no, I hit the DB to fetch the user's friends\n    user.friends_with?(record)\n  end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003equery {\n  me {\n    friends { # returns N Users\n      handle\n      birthday # runs UserPolicy#view_pii? N times\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is actually trickier to deal with than our previous example, because authorisation code is not always run in a GraphQL context. It may for example be run in a background job or an HTML endpoint. That means we can’t just reach for a Dataloader naively, because Dataloaders expect to be run from within GraphQL (in the Ruby implementation anyway).\u003c/p\u003e\n\u003cp\u003eIn my experience, this is actually \u003cstrong\u003ethe biggest source of performance issues\u003c/strong\u003e. We would regularly find that our queries were spending more time authorising data than anything else. Again, this problem simply does not exist in the REST world.\u003c/p\u003e\n\u003cp\u003eI have mitigated this using nasty things like \u003ca href=\"https://api.rubyonrails.org/classes/ActiveSupport/CurrentAttributes.html\"\u003erequest level globals\u003c/a\u003e to memoise data across policy calls, but its never felt great.\u003c/p\u003e\n\u003ch2 id=\"coupling\"\u003eCoupling\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#coupling\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIn my experience, in a mature GraphQL codebase, your business logic is forced into the \u003ca href=\"https://en.wikipedia.org/wiki/Transport_layer\"\u003etransport layer\u003c/a\u003e. This happens through a number of mechanisms, some of which we’ve already talked about:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSolving data authorisation leads to peppering authorisation rules throughout your GraphQL types\u003c/li\u003e\n\u003cli\u003eSolving mutation / argument authorisation leads to peppering authorisation rules throughout your GraphQL arguments\u003c/li\u003e\n\u003cli\u003eSolving resolver data fetching N+1s leads to moving this logic into GraphQL specific dataloaders\u003c/li\u003e\n\u003cli\u003eLeveraging the (lovely) \u003ca href=\"https://graphql-ruby.org/pagination/using_connections\"\u003eRelay Connection\u003c/a\u003e pattern leads to moving data fetching logic into GraphQL specific \u003ca href=\"https://graphql-ruby.org/pagination/custom_connections\"\u003ecustom connection objects\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe net effect of all of this is to meaningfully test your application you \u003cstrong\u003emust\u003c/strong\u003e extensively test at the integration layer, i.e. by running GraphQL queries. I have found this makes for a painful experience. Any errors encountered are captured by the framework, leading to the fun task of reading stack traces in JSON GraphQL error responses. Since so much around authorisation and Dataloaders happens inside the framework, debugging is often much harder as the breakpoint you want is not in application code.\u003c/p\u003e\n\u003cp\u003eAnd of course, again, since its a query language you’re going to be writing a lot more tests to confirm that all those argument and field level behaviours we mentioned are working correctly.\u003c/p\u003e\n\u003ch2 id=\"complexity\"\u003eComplexity\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#complexity\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eTaken in aggregate, the various mitigations to security and performance issues we’ve gone through add \u003cstrong\u003esignificant\u003c/strong\u003e complexity to a codebase. It’s not that REST does not have these problems (though it certainly has fewer), it’s just that the REST solutions are generally much simpler for a backend developer to implement and understand.\u003c/p\u003e\n\u003ch2 id=\"and-more\"\u003eAnd more…\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#and-more\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSo those are the major reasons I am, for the most part, over GraphQL. I have a few more peeves, but to keep this article growing further I’ll summarise them here..\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGraphQL discourages breaking changes and provides no tools to deal with them. This adds needless complexity for those who control all their clients, who will have to \u003ca href=\"https://graphql-ruby.org/changesets/overview.html\"\u003efind workarounds\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eReliance on HTTP response codes turns up everywhere in tooling, so dealing with the fact that 200 can mean everything from everything is Ok through to everything is down can be quite annoying.\u003c/li\u003e\n\u003cli\u003eFetching all your data in one query in the HTTP 2+ age is often not beneficial to response time, in fact it will worsen it if your server is not parallelised, vs sending separate requests to separate servers to process in parallel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"alternatives\"\u003eAlternatives\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#alternatives\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eOk, end of the rant. What would I recommend instead? To be up front, I am definitely early in the \u003ca href=\"https://en.wikipedia.org/wiki/Gartner_hype_cycle\"\u003ehype cycle\u003c/a\u003e here, but right now my view is that if you:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eControl all your clients\u003c/li\u003e\n\u003cli\u003eHave ≤3 clients\u003c/li\u003e\n\u003cli\u003eHave a client written in a statically typed language\u003c/li\u003e\n\u003cli\u003eAre using \u003e1 language across the server and clients\u003csup id=\"fnref:2\" role=\"doc-noteref\"\u003e\u003ca href=\"https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fn:2\" class=\"footnote\" rel=\"footnote\"\u003e2\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eYou are probably better off exposing an \u003cstrong\u003eOpenAPI 3.0+\u003c/strong\u003e compliant JSON REST API. If, as in my experience, the main thing your frontend devs like about GraphQL is its self documenting type safe nature, I think this will work well for you. Tooling in this area has improved a lot since GraphQL came on the scene; there are many options for generating typed client code even down to \u003ca href=\"https://orval.dev/overview\"\u003eframework specific data fetching libraries\u003c/a\u003e. My experience so far is pretty close to “the best parts of what \u003cstrong\u003eI\u003c/strong\u003e used GraphQL for, without the complexity Facebook needed”.\u003c/p\u003e\n\u003cp\u003eAs with GraphQL there’s a couple of implementation approach…\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eImplementation first\u003c/strong\u003e tooling generates OpenAPI specs from a typed / type hinted server. \u003ca href=\"https://fastapi.tiangolo.com/\"\u003eFastAPI\u003c/a\u003e in Python and \u003ca href=\"https://github.com/lukeautry/tsoa\"\u003etsoa\u003c/a\u003e in TypeScript are good examples of this approach\u003csup id=\"fnref:3\" role=\"doc-noteref\"\u003e\u003ca href=\"https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fn:3\" class=\"footnote\" rel=\"footnote\"\u003e3\u003c/a\u003e\u003c/sup\u003e. This is the approach I have the most experience with, and I think it works well.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSpecification first\u003c/strong\u003e is equivalent to “schema first” in GraphQL. Spec first tooling generates code from a hand written spec. I can’t say I’ve ever looked at an OpenAPI YAML file and thought “I would love to have written that myself”, but the recent release of \u003ca href=\"https://typespec.io/\"\u003eTypeSpec\u003c/a\u003e changes things entirely. With it could come a quite elegant schema first workflow:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWrite a succinct human readable TypeSpec schema\u003c/li\u003e\n\u003cli\u003eGenerate an OpenAPI YAML spec from it\u003c/li\u003e\n\u003cli\u003eGenerate statically typed API client for your frontend language of choice (e.g. \u003ca href=\"https://orval.dev/overview\"\u003eTypeScript\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003eGenerate statically typed server handlers for your backend language \u0026#x26; server framework (e.g. \u003ca href=\"https://docs.buildwithfern.com/server-boilerplate/server-boilerplate/express-js\"\u003eTypeScript + Express\u003c/a\u003e, \u003ca href=\"https://docs.buildwithfern.com/server-boilerplate/server-boilerplate/fast-api\"\u003ePython + FastAPI\u003c/a\u003e, \u003ca href=\"https://github.com/deepmap/oapi-codegen\"\u003eGo + Echo\u003c/a\u003e)\u003c/li\u003e\n\u003cli\u003eWrite an implementation for that handler that compiles, safe in the knowledge that it will be type safe\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis approach is less mature but I think has a lot of promise.\u003c/p\u003e\n\u003cp\u003eTo me, it seems like powerful \u003cstrong\u003eand\u003c/strong\u003e simpler options are here, and I’m excited to learn their drawbacks next 😄.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ePersisted queries are also a mitigation for this and many attacks, but if you actually want to expose a customer facing GraphQL API, persisted queries are not an option. \u003ca href=\"https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fnref:1\"\u003e↩\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eOtherwise a language specific solution like \u003ca href=\"https://trpc.io/\"\u003etRPC\u003c/a\u003e might be a better fit. \u003ca href=\"https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fnref:2\"\u003e↩\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eIn Ruby, I guess because type hints are not popular, there is no equivalent approach. Instead we have \u003ca href=\"https://github.com/rswag/rswag\"\u003erswag\u003c/a\u003e which generates OpenAPI specs from request specs. It would be cool if we could build an OpenAPI spec from Sorbet / RBS typed endpoints! \u003ca href=\"https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fnref:3\"\u003e↩\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2 id=\"gn-6년-만에-graphql을-그만둔-이유\"\u003eGN⁺: 6년 만에 GraphQL을 그만둔 이유\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#gn-6년-만에-graphql을-그만둔-이유\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://news.hada.io/topic?id=15097\"\u003ehttps://news.hada.io/topic?id=15097\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e2018년부터 6년간 사용 후, 진정한 GraphQL 열혈 팬이었지만 이제 회의가 듦\u003c/li\u003e\n\u003cli\u003e이제 GraphQL을 추천하지 않는 이유와 더 나은 대안이 무엇이라고 생각하는지에 대해 설명하고자 함\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"공격-표면\"\u003e공격 표면\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#공격-표면\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGraphQL은 쿼리 언어를 노출하여 공격 표면을 넓히는 위험이 있음.\u003c/li\u003e\n\u003cli\u003e권한 부여와 관련된 문제는 특히 중요함.\n\u003cul\u003e\n\u003cli\u003e모든 필드에 대해 적절한 권한 검사가 필요함.\u003c/li\u003e\n\u003cli\u003eREST API에서는 엔드포인트마다 권한을 검사하는 것이 더 간단함.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"권한-부여\"\u003e권한 부여\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#권한-부여\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e모든 필드에 대해 사용자 권한을 확인해야 함.\u003c/li\u003e\n\u003cli\u003eREST API에서는 엔드포인트마다 권한을 검사하는 것이 더 간단함.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"속도-제한\"\u003e속도 제한\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#속도-제한\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eGraphQL 쿼리는 크기 제한이 없어서 서버에 큰 부담을 줄 수 있음.\u003c/li\u003e\n\u003cli\u003e쿼리 복잡성을 추정하고, 일정 복잡성을 초과하는 쿼리를 제한하는 방법이 있음.\u003c/li\u003e\n\u003cli\u003eREST API에서는 요청 수를 제한하는 것이 더 간단함.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"쿼리-파싱\"\u003e쿼리 파싱\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#쿼리-파싱\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e잘못된 쿼리 문자열이 서버의 메모리를 과도하게 사용할 수 있음.\u003c/li\u003e\n\u003cli\u003e최대 오류 수를 설정하여 파싱을 중단하는 방법이 있음.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"성능\"\u003e성능\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#성능\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003ch4 id=\"데이터-페칭과-n1-문제\"\u003e데이터 페칭과 N+1 문제\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#데이터-페칭과-n1-문제\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e필드 리졸버가 외부 데이터 소스를 여러 번 호출할 수 있음.\u003c/li\u003e\n\u003cli\u003eDataloader 패턴을 사용하여 문제를 해결할 수 있음.\u003c/li\u003e\n\u003cli\u003eREST에서는 컨트롤러에서 N+1 문제를 해결하는 것이 더 간단함.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"권한-부여와-n1-문제\"\u003e권한 부여와 N+1 문제\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#권한-부여와-n1-문제\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e권한 부여 코드가 N+1 문제를 일으킬 수 있음.\u003c/li\u003e\n\u003cli\u003eREST에서는 이 문제가 발생하지 않음.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"결합\"\u003e결합\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#결합\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGraphQL 코드베이스는 비즈니스 로직이 전송 계층에 강하게 결합됨.\u003c/li\u003e\n\u003cli\u003e통합 테스트가 필요하고, 디버깅이 어려움.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"복잡성\"\u003e복잡성\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#복잡성\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eGraphQL의 보안 및 성능 문제를 해결하기 위한 다양한 방법들이 코드베이스의 복잡성을 증가시킴.\u003c/li\u003e\n\u003cli\u003eREST 솔루션은 일반적으로 더 간단함.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"대안\"\u003e대안\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#대안\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eOpenAPI 3.0+를 사용하는 JSON REST API를 추천함.\u003c/li\u003e\n\u003cli\u003e정적 타입 언어로 작성된 클라이언트가 있는 경우, OpenAPI가 더 나은 선택일 수 있음.\u003c/li\u003e\n\u003cli\u003eOpenAPI는 자동으로 타입 안전한 클라이언트 코드를 생성할 수 있음.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"gn의-의견\"\u003eGN⁺의 의견\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#gn의-의견\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eGraphQL은 강력하지만, 보안과 성능 문제를 해결하는 데 많은 노력이 필요함.\u003c/li\u003e\n\u003cli\u003eREST API는 상대적으로 간단하고, 많은 경우에 더 적합할 수 있음.\u003c/li\u003e\n\u003cli\u003eOpenAPI는 타입 안전성과 자동화된 도구를 제공하여 개발 생산성을 높일 수 있음.\u003c/li\u003e\n\u003cli\u003eGraphQL을 도입할 때는 보안 및 성능 문제를 충분히 고려해야 함.\u003c/li\u003e\n\u003cli\u003eREST와 GraphQL의 장단점을 비교하여 프로젝트에 맞는 기술을 선택하는 것이 중요함.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"hacker-news-의견\"\u003e\u003ca href=\"https://news.ycombinator.com/item?id=40521518\"\u003eHacker News 의견\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#hacker-news-의견\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eGraphQL 도입 후 많은 문제를 겪었음. 권한 관리와 성능 문제로 인해 더 이상 사용하고 싶지 않음. 프론트엔드에서만 사용하면 좋을 수 있지만, 백엔드와의 통합은 복잡함.\u003c/li\u003e\n\u003cli\u003eREST를 먼저 배우고 gRPC를 사용해보니 타입 안전한 API가 매력적이었음. GraphQL은 많은 이점이 없고, 데이터베이스처럼 동작할 때만 유용함.\u003c/li\u003e\n\u003cli\u003e두 개의 GraphQL 프로젝트에서 일했는데, 초기에는 작게 시작했지만 시간이 지나면서 복잡해졌음. 디버깅이 어렵고 성능 문제가 발생함. REST와 RPC가 더 간단하고 관리하기 쉬움.\u003c/li\u003e\n\u003cli\u003eHasura 창립자로서 GraphQL 사용의 진화를 보았음. GraphQL은 데이터 레이어가 없으면 구축하기 매우 어려움. REST 위에 GraphQL을 사용하는 것은 비효율적임. GraphQL의 주요 사용 사례는 여러 데이터 소비자가 있는 경우임.\u003c/li\u003e\n\u003cli\u003e프론트엔드 엔지니어들이 쿼리를 중앙 라이브러리에 저장하고 재사용하는데, 이는 GraphQL을 REST처럼 사용하는 것과 같음.\u003c/li\u003e\n\u003cli\u003eOpenAPI, GraphQL, JSON/HTTP, gRPC를 사용해본 경험으로, GraphQL 쿼리를 제한하는 것이 성능과 보안 문제를 완화할 수 있음. Buf Connect가 대부분의 프로젝트에 가장 적합한 타협점임.\u003c/li\u003e\n\u003cli\u003eFacebook에서 GraphQL을 사용한 경험으로, 많은 사람들이 GraphQL이 해결하려는 문제를 가지고 있지 않음. Facebook은 버전 관리와 복잡한 객체 모델을 다루기 위해 GraphQL을 사용함.\u003c/li\u003e\n\u003cli\u003eFacebook에서 GraphQL이 잘 작동하는 이유는 모든 사용자가 로그인하고, 보안이 모든 필드에 내재되어 있기 때문임. SPA와 로그인 요구 사항이 있는 경우 GraphQL이 유용할 수 있음.\u003c/li\u003e\n\u003cli\u003eGraphQL을 사용해보니 처음에는 좋았지만, 결국 많은 추가 작업과 중복이 필요했음. JSON-RPC 타입 엔드포인트로 시작하고 필요한 기능을 추가하는 것이 더 나았음.\u003c/li\u003e\n\u003cli\u003e작은 프로젝트에서 GraphQL을 사용해보니 거의 모든 부분이 좋았음. Apollo Client와 graphql-codegen을 사용해 Vue 3용 타입과 함수를 생성했음. 일부 문제는 있었지만, 타입 수준에서 많은 오류를 잡아줌.\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"6crc35gbgjs11cgz7rmwdxx"},"buildId":"vOE8u-mg___OsOsz4tjEg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>