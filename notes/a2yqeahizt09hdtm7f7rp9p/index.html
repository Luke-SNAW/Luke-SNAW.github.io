<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>From Common Lisp to Julia</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="From Common Lisp to Julia"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/a2yqeahizt09hdtm7f7rp9p/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="9/7/2022"/><meta property="article:modified_time" content="9/7/2022"/><link rel="canonical" href="https://luke-snaw.github.io//notes/a2yqeahizt09hdtm7f7rp9p/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/wirstT2ztC8OQsbzKjhvw/_buildManifest.js" defer=""></script><script src="/_next/static/wirstT2ztC8OQsbzKjhvw/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="from-common-lisp-to-julia">From Common Lisp to Julia<a aria-hidden="true" class="anchor-heading icon-link" href="#from-common-lisp-to-julia"></a></h1>
<blockquote>
<p><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/">https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/</a><br>
<a href="https://news.ycombinator.com/item?id=32745318">https://news.ycombinator.com/item?id=32745318</a></p>
</blockquote>
<blockquote>
<p>This post explains my reasoning for migrating from Common Lisp to Julia as my primary programming language, after a few people have asked me to elaborate. This article is the product of my experiences and opinions, and may not reflect your own. Both languages are very well designed, and work well, so I encourage you to do your own research and form your own opinions about which programming languages work best for you.</p>
</blockquote>
<h2 id="from-python-to-common-lisp"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#from_python_to_common_lisp">From Python to Common Lisp</a><a aria-hidden="true" class="anchor-heading icon-link" href="#from-python-to-common-lisp"></a></h2>
<p>I first started using Common Lisp in January of 2008. Before that, I was using Python for most of my programming tasks, and a colleague was ocassionally making fun of my code, re-implementing snippets in Common Lisp, as an unsuccessful attempt to help me see the light. I distinctly remember telling myself that I would never use such a language with so many parentheses and structure that was very much outside of the norm. I was using Python because it was easy and fast to get my ideas into working code.</p>
<p>One day, purely out of boredom, I started reading <a href="https://gigamonkeys.com/book">Practical Common Lisp</a>, a book introducing Common Lisp, which is still the oft-recommended introductory reference today. After only a few days, I found myself swimming in parentheses, fully content, and without even finishing the book. How did I go from one extreme to another? The answer was quite simple: even as a beginner to the language, I was <em>more</em> productive than I was with years of Python experience, which speaks volumes in my opinion, given that Python is often boasted as being great for rapid application development.</p>
<p>From 2008 to 2022, I was writing my code exclusively in Common Lisp, every day. I was able to get my ideas into working code quickly and effectively. The interactivity that the language was built around from the ground up made that possible. There was no latency, or waiting for the language at all. I could live in a running Lisp image and iteratively define my programs from the inside out, or in whatever way I wanted to, with immediate feedback after each change. This interactive and iterative development workflow was especially important to me, given I am mainly a graphics programmer; I write game engines, games, graphics algorithms, procedurally-generated imagery, simulations, and other related applications.</p>
<h2 id="from-common-lisp-to-julia-1"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#from_common_lisp_to_julia">From Common Lisp to Julia</a><a aria-hidden="true" class="anchor-heading icon-link" href="#from-common-lisp-to-julia-1"></a></h2>
<p>After 7 years of developing software in Common Lisp, in 2015, I started to grow increasingly frustrated with various aspects of the language, which I will mention later, so I started looking for a secondary language, as to not keep all my eggs in the same basket, so to speak. It was at this time that I first heard about Julia. I read through the entire manual and I was impressed with everything it had to offer. It was though, still in its infancy, and I didn't pursue it any further.</p>
<p>Continuing to use Common Lisp, the next stop on the timeline is 2017, when <a href="https://tamaspapp.eu/post/common-lisp-to-julia/">a notable Lisp figure made the announcement of switching to Julia</a>. I am not a data scientist, but this post still made me look into Julia once more, and I actually tried using it this time. To cut a long story short, I'll just say that I had a very rough time, and encountered quite a few surprises due to the language not being stable yet (and a year away from its v1.0 release). Once again, I dismissed it, but I kept it around for quick REPL experiments every now and then, and to watch it progress as a language with each subsequent release.</p>
<p>2020 was a depressing year for a lot of people, being stuck inside due to the pandemic. It was also depressing for me, because a long-term project of mine, a game engine, was proving to be inadequate without a serious rewrite. This was the spark that ignited my transition as a programmer into other domains, although still graphics-related. As such, I began sketching out a simple graphics math library in Julia, but I didn't get very far before I started to miss Common Lisp. This was however, my first attempt at writing Julia code, and I was impressed with the language overall. I ended up going back to Common Lisp, writing various small utilities and graphics algorithms.</p>
<p>In 2022, I realized that I was going to be "stuck" using Common Lisp forever unless I accepted the loss of some language features not present in any other language, and especially not all of them combined in a single language. I studied a handful of programming languages, including, but not limited to Scheme, Racket, Raku, Go, and Rust. Rust was the only one on this list that I have studied for many years prior, but it was the popular language gaining a lot of traction, and I re-explored it to see if I could swallow it. The answer was "no", and a "no" to all the other languages I've tried.</p>
<p>In June of 2022, I forced myself to stop using Common Lisp, and wrote a small math library in Julia over a couple of weeks in my free time. In writing this library, it helped me to see just how similar Common Lisp and Julia are to each other, which isn't obvious at the surface level. I found myself appreciating it more than ever, and I went on to write another library that received a lot of positive feedback from the community. It is now September, and I still have not touched Common Lisp, nor do I have a desire to. Julia just seems to tick all the boxes for me.</p>
<h2 id="why-i-no-longer-use-common-lisp"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#why_i_no_longer_use_common_lisp">Why I No Longer Use Common Lisp</a><a aria-hidden="true" class="anchor-heading icon-link" href="#why-i-no-longer-use-common-lisp"></a></h2>
<p>Common Lisp is a fantastic language, but it just isn't for me. Most of the problems I have with the language are social issues more than technical issues. The combination of all of the following issues, are what led me to become increasingly frustrated with the language over time, in no particular order.</p>
<h3 id="editor-support"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#editor_support">Editor support</a><a aria-hidden="true" class="anchor-heading icon-link" href="#editor-support"></a></h3>
<p>Common Lisp is not a language that is designed to just be edited in any old text editor or IDE. It was designed for total interactivity with an iterative development workflow from the ground up. This goes much farther than incremental compilation or hot code reloading found in some other languages, Julia included. Features like CLOS and the Common Lisp condition system are very dynamic and interactive in nature.</p>
<p>For example, when an exceptional situation occurs, such as, but not limited to an error, the debugger "pops up" in your editor, where you can decide what to do. Such choices might be to inspect the state of local variables in any of the stack frames, evaluate arbitrary code in the context of any of the stack frames, and more. While the debugger is active, your program is basically in a "paused" state, and you are free to go and edit functions and other definitions, and then tell the debugger to continue execution of your program after such repairs are made. You can even do this completely programmatically, with or without unwinding the stack, to take full control over what should happen for an exceptional situation. Most other languages have this feature in the form of an "exception system", but they contain only a subset of what is possible with the Common Lisp condition system, and most notably, the call stack is unwound before you get the chance to handle an exception, which means it is too late and lacking context of how to properly handle it in most cases.</p>
<p>The Common Lisp inspector lets you visually traverse an object hierarchy, exploring every bit of detail about the state of your program, or changing their values, all built-in to your editor.</p>
<p>Compiling functions and other definitions is simply a key binding with the cursor over that definition in your editor. The result is instantaneous, and changes are seen by your running program immediately.</p>
<p>All of this fancy interactivity is made possible by an editor plugin, that far exceeds the scope of a Language Server Protocol server. As such, editor support is extremely lacking in any editor that is not Emacs. There <em>is</em> support in other editors, but it is nowhere near as complete and convenient as it is in Emacs.</p>
<p>I don't really like to be forced to use a particular editing environment to program in a language. I am a Vim user at heart, and while there are similar plugins for Vim, they are very awkward to work with and only offer a subset of the abilities of the Emacs plugin. Emacs can also be made to behave similarly to Vim, but the complexity and mis-features of Emacs is still there rearing its ugly head when you least expect it. For years, I have had to deal with using Emacs as my editing environment, and I disliked every moment of it.</p>
<h3 id="language-evolution"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#language_evolution">Language Evolution</a><a aria-hidden="true" class="anchor-heading icon-link" href="#language-evolution"></a></h3>
<p>Common Lisp is not just a language; it is a document describing how to implement a language. As such, there are multiple implementations of this ANSI standard, each with their own set of features.</p>
<p>Writing portable Common Lisp can be difficult or impossible at times. One often needs to reach for portability libraries that unify the interface of particular features between the different implementations.</p>
<p>The fact that Common Lisp is a standard is both a blessing and a curse. Many developers consider this to be the former, as your code is much less likely to break over time. For others, it means that the language is frozen in time. For instance, it:</p>
<ul>
<li>predates Unicode</li>
<li>makes no mention of threading</li>
<li>does not mandate IEEE-754 floating-point encoding</li>
<li>no foreign function interface (FFI) described</li>
<li>no garbage-collection interface defined</li>
<li>no networking support</li>
</ul>
<p>and much more. All of these features are left to be implemented by third-party libraries, and if possible, portability libraries that allow them to function with a unified interface between all implementations of Common Lisp.</p>
<p>Additionally, the standard is incredibly hard to navigate, especially as a beginner trying to learn the language. In many places it is very ambiguous, or erroneous, and often leads to long debates in the Common Lisp communication forums.</p>
<h3 id="software-versioning-and-deployment"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#software_versioning_and_deployment">Software Versioning and Deployment</a><a aria-hidden="true" class="anchor-heading icon-link" href="#software-versioning-and-deployment"></a></h3>
<p>There is no built-in package<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> manager for Common Lisp. Installing new software is done with a third-party library, that is usually included in each implementation of Common Lisp, but is not part of the language standard. Implementations often include very old versions of this software, so updating it with a local copy is often a good idea. Additionally, this software (<a href="https://asdf.common-lisp.dev/asdf.html">ASDF</a>), does not handle downloading software from the Internet; all software must exist locally on your filesystem.</p>
<p>There exists another third-party piece of software, <a href="https://www.quicklisp.org/beta/">Quicklisp</a>, that wraps ASDF, and is used to download newer software versions from the Internet, forwarding the installation to the underlying ASDF utility.</p>
<p>Quicklisp, while it works well for the small open-source Common Lisp community, is far from ideal. It ships with one "dist" installed, the "quicklisp" dist. This is a collection of metadata that describes where the latest version of each package can be downloaded, and its dependencies. When you install a piece of software, you are installing it from the official Quicklisp dist repository, not from the upstream repository.</p>
<p>The Quicklisp dist is curated by the Quicklisp maintainer, who ensures that all software builds successfully (in isolation; no checks are done to ensure that a piece of software is compatible with other software in the same dist). The Quicklisp maintainer downloads software from upstream once every month or two, to be included in a dist. No versioning or compatibility information is taken into account; users just receive the latest version of a piece of software that may or may not be compatible with other software a developer uses with it.</p>
<p>Infact, Common Lisp developers rarely version their software at all, because they offload the responsibility of deployment to the Quicklisp maintainer, with nothing to be done on their part. This model is far from ideal for any serious developer in my honest opinion. You never know what version of your software users will receive, unless you submit a particular branch for Quicklisp to track, rather than the main branch of your repository. Even if you employ this approach, users of your "stable" software will be pulling in transitive dependencies that may not employ this approach, and there is practically no way for you to deploy your software with compatibile dependencies without maintaining your very own Quicklisp dist. Most users will not go through the trouble of installing more than the builtin Quicklisp dist though. Common Lisp developers seem not to care much about reproducible builds, or taking on the responsibility of software deployment on their own.</p>
<p>Because the official Quicklisp dists are released once every month or two (which is an eternity in the software world), developers cannot push hot-fixes or address user-reported problems in a timely manner, unless they run their own dist and convince their users to use that, or convince their users to clone directly from upstream, and place it in a particular location on their filesystem that Quicklisp looks for to override dist versions.</p>
<p>I am of the very strong opinion that developers should be responsible for deploying and versioning their own software, without the aforementioned downsides of relying on a single point of failure to do so for them.</p>
<h3 id="documentation"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#documentation">Documentation</a><a aria-hidden="true" class="anchor-heading icon-link" href="#documentation"></a></h3>
<p>Common Lisp libraries are rarely ever documented. "Docstrings" and code comments are not user documentation. A successful open-source project to be well-received by the public needs to have real offline user documentation, complete with plentiful usage examples, tutorials, imagery, and anything else that will transition a user more easily. This does not really need much explaining – Common Lisp software is mainly targeted at other developers that aren't afraid to read code and modify it to their liking.</p>
<h3 id="software-quality"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#software_quality">Software Quality</a><a aria-hidden="true" class="anchor-heading icon-link" href="#software-quality"></a></h3>
<p>Common Lisp software is of usually very high quality – if you take into consideration that it was more than likely developed by a single person and then stopped being maintained shortly thereafter. Common Lisp programmers are usually exceptional thinkers and writers of code, but they are often just one person – they cannot think of every edge case, find every major bug, write documentation, or keep interest over other priorities for very long.</p>
<p>This hints at a very real problem with Common Lisp: it has a tendency to attract people that employ the 'NIH syndrome' and refuse to collaborate. There is a large overlap of software available, and there is a large selection of low-hanging fruit for new developers. This coupled with the fact that the language is small, relatively speaking, hurts the language immensely.</p>
<p>In my opinion, this is due to the language being incredibly malleable. <a href="https://news.ycombinator.com/item?id=13441793">It is usually much easier to re-implement an idea than it is to use/fix someone else's implementation</a>. This is because Common Lisp code is so flexible that one can shape it to one's own thought processes. After all, code is just a projection of one's thought processes.</p>
<p>This problem is recursive, in that we have many "50%" solutions to the same problems, and the next round of developers will create another set of solutions to add to the pile.</p>
<p>Common Lisp, due to its flexibility, seems to cater very much towards single developers, and this shows brightly in the library ecosystem.</p>
<h3 id="programming-paradigm"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#programming_paradigm">Programming Paradigm</a><a aria-hidden="true" class="anchor-heading icon-link" href="#programming-paradigm"></a></h3>
<p>Common Lisp is a multi-paradigm programming language. That said, it's most prominent feature enables object-oriented programming in a unique way. While you can mix programming paradigms, it is nearly impossible to get away from OOP, with it being baked deep into the language.</p>
<p>Arguably, one of the best features of Common Lisp is the Common Lisp Object System (CLOS). The language is designed from the ground up with an object-oriented approach, though most modern programmers would not recognize it as object oriented because it has a very unique approach. A major difference in CLOS relative to most other object systems is that it disassociates methods from classes, and solves some real problems that have plagued other OOP implementations, such as multiple inheritance. Additionally, the object system is fully customizable with the Meta-Object Protocol (MOP), allowing one to change how the object system behaves at every level.</p>
<p>While I do think that CLOS is very nice, and it is hard to live without it, I also think that OOP in general does not fit every programming problem. Infact, for most applications, I would much rather have parametric polymorphism instead of ad-hoc polymorphism that you get with Common Lisp generic functions.</p>
<p>Generic functions in Common Lisp do not have arity-overloading like they do in Julia and other languages with generic functions. A generic function in Common Lisp has a fixed arity, and defines a protocol. Many people like this idea, but I don't.</p>
<p>Additionally, most of the language proper is not generic. For example, you cannot redefine what it is to be a sequence, extending them to other collection types or iterators. There is an extension present in some implementations called "extensible sequences" that partially solves this problem, but it cannot be made portable having its existence in only a handful of implementations. The reason for this comes down to the fact that invoking generic code in Common Lisp carries a small performance penalty, so any code which might be used in a performance-critical context, will be pressured to be made non-generic.</p>
<p>User-defined types in Common Lisp come in three forms: classes, structs, and types. <code>defclass</code> defines a class, <code>defstruct</code> defines a struct, and <code>deftype</code> defines a type.</p>
<p>Structs are rarely ever used except in performance-critical code, as they do not work seamlessly with the interactive development workflow of Common Lisp; redefining them is undefined behavior. Additionally, they only support single-inheritance.</p>
<p>User-defined types are merely type aliases for existing types.</p>
<p>Generic functions can only specialize their parameters on a class name, not a type. While every class has a type of the same name, the inverse is not true. One cannot define a method that operates on the integral range <code>[0, 10)</code> for example. It is however, possible to dispatch on a value, but only if that value is <code>EQL</code>-comparable, which is the case for scalars, not aggregates.</p>
<p>While CLOS is extremely powerful, and can be bent to do all sorts of nice tricks, these fundamental flaws are encountered on an almost daily basis in my programming, and I always wish for true parametric polymorphism with generic type parameters to stand in for a class of types.</p>
<h3 id="community"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#community">Community</a><a aria-hidden="true" class="anchor-heading icon-link" href="#community"></a></h3>
<p>The open-source Common Lisp community is the smallest out of any programming language community I have participated in. It is often hard to get the help you need, and even more difficult to find someone to collaborate with on a project, as most developers prefer to work alone.</p>
<p>Getting help is also often a problem. Experienced Common Lispers assume a basic understanding of the language, good style practice, and familiarity with Emacs and the associated Common Lisp tooling installed. Asking for help as a beginner, and posting a small snippet of code, more often than not results in a wall of text of replies asking the user to fix their style before they can consider helping. This is quite dissuading as a newcomer, and detracts from the user's learning path. In extreme cases, which are not rare at all, the community can be quite inflammatory towards newcomer questions, as they often get very upset over incorrect terminology or improperly formatted code.</p>
<p>Even as an experienced Common Lisper, I tend not to partake in such discussions, as it is bad for my health. I actually have a disability, and there have been times when engaging in these discussions have contributed adversely to my condition. <a href="https://eli.thegreenplace.net/2006/10/27/the-sad-state-of-the-lisp-user-community/">The community can just be flat-out toxic a lot of the time</a>.</p>
<h3 id="performance"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#performance">Performance</a><a aria-hidden="true" class="anchor-heading icon-link" href="#performance"></a></h3>
<p>If ultimate performance is your goal, Common Lisp is not the best choice for a language. While it is entirely possible to write code that can compete with the speed of C, it largely depends on the Common Lisp implementation, and making trade-offs that cripple the interactivity of the language.</p>
<p>Runtime performance gains can be achieved by not utilizing the dynamic dispatch feature of generic functions, which are inherent to class-based programming with CLOS. Instead, structs are typically used for creating aggregate types, as their field accessors are not generic, but regular functions, and redefining their definitions is undefined behavior.</p>
<p>Type annotations usually have to be sprinkled throughout the code, and macros and compiler macros have to be used to transform code into more efficient representations at compile time.</p>
<p>Arrays need to be specialized to pack immediate values into memory, rather than pointers to be chased to somewhere in heap memory. Element types that can be specialized are completely implementation-dependent, and almost always limited to scalars only. Arrays of structs, arrays of arrays, and many other data structures are usually not possible without performance implications.</p>
<p>Writing performant code in Common Lisp is not for everyone, and it most certainly cannot be done portably; what might run fast on one implementation may run poorly on another. The moment you start writing implementation-specific code, in my honest opinion, you are better off using another programming language (which can also be considered writing implementation-specific code).</p>
<h2 id="why-i-prefer-julia-as-my-primary-programming-language"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#why_i_prefer_julia_as_my_primary_programming_language">Why I Prefer Julia As My Primary Programming Language</a><a aria-hidden="true" class="anchor-heading icon-link" href="#why-i-prefer-julia-as-my-primary-programming-language"></a></h2>
<p>Julia is such a wonderful language. It's hard to describe why I like it so much, but some of the reasons are listed below. In short, Julia is very similar to Common Lisp, but brings a lot of extra niceties to the table.</p>
<h3 id="editor-support-1"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#editor_support__2">Editor support</a><a aria-hidden="true" class="anchor-heading icon-link" href="#editor-support-1"></a></h3>
<p>Julia editor support is among the top in its class. You are not limited to a single editor to get the full experience of this dynamic programming language. There are well-polished editor plugins for a variety of editors, and there even exists <a href="https://github.com/JuliaEditorSupport">an organization</a> dedicated to improving the Julia editor tooling.</p>
<p>Personally, I use Vim (Neovim, actually) along with <a href="https://github.com/julia-vscode/LanguageServer.jl">LanguageServer.jl</a> and the experience is very pleasant.</p>
<h3 id="language-evolution-1"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#language_evolution__2">Language Evolution</a><a aria-hidden="true" class="anchor-heading icon-link" href="#language-evolution-1"></a></h3>
<p>Julia does not have a language standard like Common Lisp does. It is free to evolve as the unique problem space it is attempting to address is further explored.</p>
<p>I consider this a good thing. I do not want a language frozen in time. I like to see growth, and Julia has been growing rapidly for many years, both in terms of adoption and the rate of new packages becoming available.</p>
<h3 id="software-versioning-and-deployment-1"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#software_versioning_and_deployment__2">Software Versioning and Deployment</a><a aria-hidden="true" class="anchor-heading icon-link" href="#software-versioning-and-deployment-1"></a></h3>
<p>Unlike Common Lisp, Julia gives the developer the responsibility of distributing their software. This is, however, very painless due to the built-in package manager, <a href="https://pkgdocs.julialang.org/">Pkg.jl</a>, in addition to package registries and related tools.</p>
<p>I host my software on GitHub, and the process of making my software discoverable to the wider Julia community is very simple. All I have to do is leave a comment on the commit I want to publish, and a GitHub bot takes care of analyzing my software, and merging it into the official package registry if it meets all of the requirements. The process is similarly simple for other hosting platforms, or if self-hosting.</p>
<p>Once a package is in the official registry, it can be installed by anyone using the builtin package manager, which conveniently has a special mode built in the the REPL for managing packages.</p>
<p>Reproducibility of builds is also handled very well. All Julia project environments contain a manifest file that records the exact versions of all transitive dependencies, along with a unique identifier for disambiguation, should the name of a project be found in multiple registries. Distributing this manifest file to a colleague is all that is needed for them to reproduce your exact development environment. It's all very painless.</p>
<p>Pkg.jl is a very well-designed package manager offering a lot of features. I encourage you to read the documentation to discover everything it can do. It is by far the best package manager I have ever used.</p>
<h3 id="programming-paradigm-1"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#programming_paradigm__2">Programming Paradigm</a><a aria-hidden="true" class="anchor-heading icon-link" href="#programming-paradigm-1"></a></h3>
<p>Julia is not an object-oriented language. Infact, it doesn't have classes at all. It has a unique type system that, at first glance, seems quite limiting in that only leaf nodes of the hierarchy can be instantiated. Intermediary nodes are abstract types which cannot be instantiated, but can be used to define behavior on entire classes of objects, even disjoint hierarchies by means of traits.</p>
<p>The fact that you can only instantiate concrete leaf node types may seem a bit limiting, but it drastically simplifies generic function method applicability, makes it much easier to reason about programs, and encourages developers to employ a composition over inheritance architecture.</p>
<p>Type parameterization and zero-cost generic functions are one of the primary reasons I switched to Julia. Writing efficient code couldn't be easier, and I don't have to sacrifice code clarity in doing so. Infact, I don't have to think about efficiency much at all apart from having a strong understanding of data structures and algorithms that every computer scientist should have.</p>
<p>One other notable difference between Common Lisp and Julia generic functions, is optional parameters can have specializations in Julia, in which case multiple methods are generated for each arity. Common Lisp forbids generic functions from differing in signature, so this is simply not possible in Common Lisp without a Meta-Object Protocol extension.</p>
<h3 id="community-1"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#community__2">Community</a><a aria-hidden="true" class="anchor-heading icon-link" href="#community-1"></a></h3>
<p>The Julia community is one of its strongest qualities, and is quite large. It is fragmented into various sub-communities: Slack, Zulip, Discourse, Discord, and IRC, to name a few. I am an active member of the Julia Zulip community, and questions I have get answered almost immediately. Additionally, this group of people is very welcoming to new users, and make me feel like part of the team.</p>
<p>Languages looking to improve their community image should look no further than Julia. It is truly a wonderful group of people to be a part of.</p>
<h3 id="performance-1"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#performance__2">Performance</a><a aria-hidden="true" class="anchor-heading icon-link" href="#performance-1"></a></h3>
<p>Julia code is fast – very fast. Even without knowing about common pitfalls like abstractly-typed fields, and type instability, in my experience, code runs much faster than highly hand-optimized Common Lisp code using an implementation known to generate efficient machine code.</p>
<p>Infact, the first version of my most recent project saw an order of magnitude difference when ported from Common Lisp to Julia, without any effort or attention to optimization techniques. This says a lot to me, because a great deal of time was spent optimizing the Common Lisp code to be as fast as possible without sacrificing maintainability or readability.</p>
<p>Julia code just performs good, and is very readable by default.</p>
<p>The final stable version of my recent project ported to Julia, complete with minor optimizations, saw a performance increase of 2 to 3 orders of magnitude. Functions that took milliseconds to execute were on the scale of nanoseconds in Julia, and code quality didn't suffer.</p>
<p>This is largely due to the excellent JIT compiler of Julia, and its rich type system. Generic functions in Julia do not carry any performance overhead, and type parameterization is even possible, allowing one to define functionality for a whole class of types without any runtime dispatch penalty.</p>
<h2 id="conclusion"><a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#conclusion">Conclusion</a><a aria-hidden="true" class="anchor-heading icon-link" href="#conclusion"></a></h2>
<p>I have had my eye on Julia for many years, and I now consider it ready to be my "everyday" programming language.</p>
<p>Its strong focus on types and generic programming make it ideal to solve complex problems in an efficient manner, and without type annotations all over the place. Julia's type inference engine is actually extremely good, and constant propagation always surprises me at just how well it works.</p>
<p>Being able to use Julia in my editor of choice was another big plus in my book. I <em>really</em> dislike Emacs <em>that</em> much.</p>
<p>The community is very friendly, knowledgeable, and inclusive.</p>
<p>One thing I did not compare above is both languages' macro systems. This is because Julia macros are very similar to Common Lisp, and there are better resources to learn about them. One thing I will point out, is that Julia macros do automatic gensym'ing, as opposed to opt-in with Common Lisp, though you can opt-out on a per-symbol basis. This makes macros hygienic by default. Additionally, Julia has "generated functions", which to a Common Lisper, can be thought of as a compiler macro; their input arguments are types, not expressions, that are expanded after type inference. This allows you to generate more efficient code that cannot be determined at the syntax level.</p>
<p>Also not mentioned, is Julia's module system, which is very similar to Common Lisp's package system. Symbols are string-interned by the parser in much the same way as Common Lisp. The only thing worth pointing out here, is that modules can be hierarchical, unlike Common Lisp packages, and there is no need for Common Lisp's "package-local nicknames" extension, as this feature is baked into the Julia module system already.</p>
<p>In summary, you can tell the Julia designers were well aware of Common Lisp, and their attempts to make its ideas more convenient really shows once you become familiar enough with the language. I consider Julia to be a Lisp, just without the parentheses. It <em>really</em> is not that far off from Common Lisp if you squint really hard, and that eased my transition quite a bit.</p>
<p><sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup> The term <em>package</em> in Common Lisp is actually similar to <em>module</em> in Julia. Common Lisp developers refer to what most other languages refer to as packages, as <em>systems</em> instead.</p></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#from-python-to-common-lisp" title="From Python to Common Lisp">From Python to Common Lisp</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#from-common-lisp-to-julia" title="From Common Lisp to Julia">From Common Lisp to Julia</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#why-i-no-longer-use-common-lisp" title="Why I No Longer Use Common Lisp">Why I No Longer Use Common Lisp</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#editor-support" title="Editor support">Editor support</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#language-evolution" title="Language Evolution">Language Evolution</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#software-versioning-and-deployment" title="Software Versioning and Deployment">Software Versioning and Deployment</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#documentation" title="Documentation">Documentation</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#software-quality" title="Software Quality">Software Quality</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#programming-paradigm" title="Programming Paradigm">Programming Paradigm</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#community" title="Community">Community</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#performance" title="Performance">Performance</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#why-i-prefer-julia-as-my-primary-programming-language" title="Why I Prefer Julia As My Primary Programming Language">Why I Prefer Julia As My Primary Programming Language</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#editor-support-1" title="Editor support">Editor support</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#language-evolution-1" title="Language Evolution">Language Evolution</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#software-versioning-and-deployment-1" title="Software Versioning and Deployment">Software Versioning and Deployment</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#programming-paradigm-1" title="Programming Paradigm">Programming Paradigm</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#community-1" title="Community">Community</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#performance-1" title="Performance">Performance</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#conclusion" title="Conclusion">Conclusion</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"a2yqeahizt09hdtm7f7rp9p","title":"From Common Lisp to Julia","desc":"","updated":1662526964781,"created":1662526521200,"custom":{},"fname":"dev.program-languages.from-common-lisp-to-julia","type":"note","vault":{"fsPath":"vault"},"contentHash":"29db0b19d6f9421cc2ff4d94e99cf1fc","links":[],"anchors":{"from-python-to-common-lisp":{"type":"header","text":"From Python to Common Lisp","value":"from-python-to-common-lisp","line":13,"column":0,"depth":2},"from-common-lisp-to-julia":{"type":"header","text":"From Common Lisp to Julia","value":"from-common-lisp-to-julia","line":21,"column":0,"depth":2},"why-i-no-longer-use-common-lisp":{"type":"header","text":"Why I No Longer Use Common Lisp","value":"why-i-no-longer-use-common-lisp","line":33,"column":0,"depth":2},"editor-support":{"type":"header","text":"Editor support","value":"editor-support","line":37,"column":0,"depth":3},"language-evolution":{"type":"header","text":"Language Evolution","value":"language-evolution","line":51,"column":0,"depth":3},"software-versioning-and-deployment":{"type":"header","text":"Software Versioning and Deployment","value":"software-versioning-and-deployment","line":70,"column":0,"depth":3},"documentation":{"type":"header","text":"Documentation","value":"documentation","line":86,"column":0,"depth":3},"software-quality":{"type":"header","text":"Software Quality","value":"software-quality","line":90,"column":0,"depth":3},"programming-paradigm":{"type":"header","text":"Programming Paradigm","value":"programming-paradigm","line":102,"column":0,"depth":3},"community":{"type":"header","text":"Community","value":"community","line":124,"column":0,"depth":3},"performance":{"type":"header","text":"Performance","value":"performance","line":132,"column":0,"depth":3},"why-i-prefer-julia-as-my-primary-programming-language":{"type":"header","text":"Why I Prefer Julia As My Primary Programming Language","value":"why-i-prefer-julia-as-my-primary-programming-language","line":144,"column":0,"depth":2},"editor-support-1":{"type":"header","text":"Editor support","value":"editor-support-1","line":148,"column":0,"depth":3},"language-evolution-1":{"type":"header","text":"Language Evolution","value":"language-evolution-1","line":154,"column":0,"depth":3},"software-versioning-and-deployment-1":{"type":"header","text":"Software Versioning and Deployment","value":"software-versioning-and-deployment-1","line":160,"column":0,"depth":3},"programming-paradigm-1":{"type":"header","text":"Programming Paradigm","value":"programming-paradigm-1","line":172,"column":0,"depth":3},"community-1":{"type":"header","text":"Community","value":"community-1","line":182,"column":0,"depth":3},"performance-1":{"type":"header","text":"Performance","value":"performance-1","line":188,"column":0,"depth":3},"conclusion":{"type":"header","text":"Conclusion","value":"conclusion","line":200,"column":0,"depth":2}},"children":[],"parent":"cnzc1i8ojequt9lhg3zpkgo","data":{}},"body":"\u003ch1 id=\"from-common-lisp-to-julia\"\u003eFrom Common Lisp to Julia\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#from-common-lisp-to-julia\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/\"\u003ehttps://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://news.ycombinator.com/item?id=32745318\"\u003ehttps://news.ycombinator.com/item?id=32745318\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis post explains my reasoning for migrating from Common Lisp to Julia as my primary programming language, after a few people have asked me to elaborate. This article is the product of my experiences and opinions, and may not reflect your own. Both languages are very well designed, and work well, so I encourage you to do your own research and form your own opinions about which programming languages work best for you.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"from-python-to-common-lisp\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#from_python_to_common_lisp\"\u003eFrom Python to Common Lisp\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#from-python-to-common-lisp\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eI first started using Common Lisp in January of 2008. Before that, I was using Python for most of my programming tasks, and a colleague was ocassionally making fun of my code, re-implementing snippets in Common Lisp, as an unsuccessful attempt to help me see the light. I distinctly remember telling myself that I would never use such a language with so many parentheses and structure that was very much outside of the norm. I was using Python because it was easy and fast to get my ideas into working code.\u003c/p\u003e\n\u003cp\u003eOne day, purely out of boredom, I started reading \u003ca href=\"https://gigamonkeys.com/book\"\u003ePractical Common Lisp\u003c/a\u003e, a book introducing Common Lisp, which is still the oft-recommended introductory reference today. After only a few days, I found myself swimming in parentheses, fully content, and without even finishing the book. How did I go from one extreme to another? The answer was quite simple: even as a beginner to the language, I was \u003cem\u003emore\u003c/em\u003e productive than I was with years of Python experience, which speaks volumes in my opinion, given that Python is often boasted as being great for rapid application development.\u003c/p\u003e\n\u003cp\u003eFrom 2008 to 2022, I was writing my code exclusively in Common Lisp, every day. I was able to get my ideas into working code quickly and effectively. The interactivity that the language was built around from the ground up made that possible. There was no latency, or waiting for the language at all. I could live in a running Lisp image and iteratively define my programs from the inside out, or in whatever way I wanted to, with immediate feedback after each change. This interactive and iterative development workflow was especially important to me, given I am mainly a graphics programmer; I write game engines, games, graphics algorithms, procedurally-generated imagery, simulations, and other related applications.\u003c/p\u003e\n\u003ch2 id=\"from-common-lisp-to-julia-1\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#from_common_lisp_to_julia\"\u003eFrom Common Lisp to Julia\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#from-common-lisp-to-julia-1\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAfter 7 years of developing software in Common Lisp, in 2015, I started to grow increasingly frustrated with various aspects of the language, which I will mention later, so I started looking for a secondary language, as to not keep all my eggs in the same basket, so to speak. It was at this time that I first heard about Julia. I read through the entire manual and I was impressed with everything it had to offer. It was though, still in its infancy, and I didn't pursue it any further.\u003c/p\u003e\n\u003cp\u003eContinuing to use Common Lisp, the next stop on the timeline is 2017, when \u003ca href=\"https://tamaspapp.eu/post/common-lisp-to-julia/\"\u003ea notable Lisp figure made the announcement of switching to Julia\u003c/a\u003e. I am not a data scientist, but this post still made me look into Julia once more, and I actually tried using it this time. To cut a long story short, I'll just say that I had a very rough time, and encountered quite a few surprises due to the language not being stable yet (and a year away from its v1.0 release). Once again, I dismissed it, but I kept it around for quick REPL experiments every now and then, and to watch it progress as a language with each subsequent release.\u003c/p\u003e\n\u003cp\u003e2020 was a depressing year for a lot of people, being stuck inside due to the pandemic. It was also depressing for me, because a long-term project of mine, a game engine, was proving to be inadequate without a serious rewrite. This was the spark that ignited my transition as a programmer into other domains, although still graphics-related. As such, I began sketching out a simple graphics math library in Julia, but I didn't get very far before I started to miss Common Lisp. This was however, my first attempt at writing Julia code, and I was impressed with the language overall. I ended up going back to Common Lisp, writing various small utilities and graphics algorithms.\u003c/p\u003e\n\u003cp\u003eIn 2022, I realized that I was going to be \"stuck\" using Common Lisp forever unless I accepted the loss of some language features not present in any other language, and especially not all of them combined in a single language. I studied a handful of programming languages, including, but not limited to Scheme, Racket, Raku, Go, and Rust. Rust was the only one on this list that I have studied for many years prior, but it was the popular language gaining a lot of traction, and I re-explored it to see if I could swallow it. The answer was \"no\", and a \"no\" to all the other languages I've tried.\u003c/p\u003e\n\u003cp\u003eIn June of 2022, I forced myself to stop using Common Lisp, and wrote a small math library in Julia over a couple of weeks in my free time. In writing this library, it helped me to see just how similar Common Lisp and Julia are to each other, which isn't obvious at the surface level. I found myself appreciating it more than ever, and I went on to write another library that received a lot of positive feedback from the community. It is now September, and I still have not touched Common Lisp, nor do I have a desire to. Julia just seems to tick all the boxes for me.\u003c/p\u003e\n\u003ch2 id=\"why-i-no-longer-use-common-lisp\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#why_i_no_longer_use_common_lisp\"\u003eWhy I No Longer Use Common Lisp\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#why-i-no-longer-use-common-lisp\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eCommon Lisp is a fantastic language, but it just isn't for me. Most of the problems I have with the language are social issues more than technical issues. The combination of all of the following issues, are what led me to become increasingly frustrated with the language over time, in no particular order.\u003c/p\u003e\n\u003ch3 id=\"editor-support\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#editor_support\"\u003eEditor support\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#editor-support\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCommon Lisp is not a language that is designed to just be edited in any old text editor or IDE. It was designed for total interactivity with an iterative development workflow from the ground up. This goes much farther than incremental compilation or hot code reloading found in some other languages, Julia included. Features like CLOS and the Common Lisp condition system are very dynamic and interactive in nature.\u003c/p\u003e\n\u003cp\u003eFor example, when an exceptional situation occurs, such as, but not limited to an error, the debugger \"pops up\" in your editor, where you can decide what to do. Such choices might be to inspect the state of local variables in any of the stack frames, evaluate arbitrary code in the context of any of the stack frames, and more. While the debugger is active, your program is basically in a \"paused\" state, and you are free to go and edit functions and other definitions, and then tell the debugger to continue execution of your program after such repairs are made. You can even do this completely programmatically, with or without unwinding the stack, to take full control over what should happen for an exceptional situation. Most other languages have this feature in the form of an \"exception system\", but they contain only a subset of what is possible with the Common Lisp condition system, and most notably, the call stack is unwound before you get the chance to handle an exception, which means it is too late and lacking context of how to properly handle it in most cases.\u003c/p\u003e\n\u003cp\u003eThe Common Lisp inspector lets you visually traverse an object hierarchy, exploring every bit of detail about the state of your program, or changing their values, all built-in to your editor.\u003c/p\u003e\n\u003cp\u003eCompiling functions and other definitions is simply a key binding with the cursor over that definition in your editor. The result is instantaneous, and changes are seen by your running program immediately.\u003c/p\u003e\n\u003cp\u003eAll of this fancy interactivity is made possible by an editor plugin, that far exceeds the scope of a Language Server Protocol server. As such, editor support is extremely lacking in any editor that is not Emacs. There \u003cem\u003eis\u003c/em\u003e support in other editors, but it is nowhere near as complete and convenient as it is in Emacs.\u003c/p\u003e\n\u003cp\u003eI don't really like to be forced to use a particular editing environment to program in a language. I am a Vim user at heart, and while there are similar plugins for Vim, they are very awkward to work with and only offer a subset of the abilities of the Emacs plugin. Emacs can also be made to behave similarly to Vim, but the complexity and mis-features of Emacs is still there rearing its ugly head when you least expect it. For years, I have had to deal with using Emacs as my editing environment, and I disliked every moment of it.\u003c/p\u003e\n\u003ch3 id=\"language-evolution\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#language_evolution\"\u003eLanguage Evolution\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#language-evolution\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCommon Lisp is not just a language; it is a document describing how to implement a language. As such, there are multiple implementations of this ANSI standard, each with their own set of features.\u003c/p\u003e\n\u003cp\u003eWriting portable Common Lisp can be difficult or impossible at times. One often needs to reach for portability libraries that unify the interface of particular features between the different implementations.\u003c/p\u003e\n\u003cp\u003eThe fact that Common Lisp is a standard is both a blessing and a curse. Many developers consider this to be the former, as your code is much less likely to break over time. For others, it means that the language is frozen in time. For instance, it:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epredates Unicode\u003c/li\u003e\n\u003cli\u003emakes no mention of threading\u003c/li\u003e\n\u003cli\u003edoes not mandate IEEE-754 floating-point encoding\u003c/li\u003e\n\u003cli\u003eno foreign function interface (FFI) described\u003c/li\u003e\n\u003cli\u003eno garbage-collection interface defined\u003c/li\u003e\n\u003cli\u003eno networking support\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eand much more. All of these features are left to be implemented by third-party libraries, and if possible, portability libraries that allow them to function with a unified interface between all implementations of Common Lisp.\u003c/p\u003e\n\u003cp\u003eAdditionally, the standard is incredibly hard to navigate, especially as a beginner trying to learn the language. In many places it is very ambiguous, or erroneous, and often leads to long debates in the Common Lisp communication forums.\u003c/p\u003e\n\u003ch3 id=\"software-versioning-and-deployment\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#software_versioning_and_deployment\"\u003eSoftware Versioning and Deployment\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#software-versioning-and-deployment\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThere is no built-in package\u003csup id=\"fnref-1\"\u003e\u003ca href=\"#fn-1\" class=\"footnote-ref\"\u003e1\u003c/a\u003e\u003c/sup\u003e manager for Common Lisp. Installing new software is done with a third-party library, that is usually included in each implementation of Common Lisp, but is not part of the language standard. Implementations often include very old versions of this software, so updating it with a local copy is often a good idea. Additionally, this software (\u003ca href=\"https://asdf.common-lisp.dev/asdf.html\"\u003eASDF\u003c/a\u003e), does not handle downloading software from the Internet; all software must exist locally on your filesystem.\u003c/p\u003e\n\u003cp\u003eThere exists another third-party piece of software, \u003ca href=\"https://www.quicklisp.org/beta/\"\u003eQuicklisp\u003c/a\u003e, that wraps ASDF, and is used to download newer software versions from the Internet, forwarding the installation to the underlying ASDF utility.\u003c/p\u003e\n\u003cp\u003eQuicklisp, while it works well for the small open-source Common Lisp community, is far from ideal. It ships with one \"dist\" installed, the \"quicklisp\" dist. This is a collection of metadata that describes where the latest version of each package can be downloaded, and its dependencies. When you install a piece of software, you are installing it from the official Quicklisp dist repository, not from the upstream repository.\u003c/p\u003e\n\u003cp\u003eThe Quicklisp dist is curated by the Quicklisp maintainer, who ensures that all software builds successfully (in isolation; no checks are done to ensure that a piece of software is compatible with other software in the same dist). The Quicklisp maintainer downloads software from upstream once every month or two, to be included in a dist. No versioning or compatibility information is taken into account; users just receive the latest version of a piece of software that may or may not be compatible with other software a developer uses with it.\u003c/p\u003e\n\u003cp\u003eInfact, Common Lisp developers rarely version their software at all, because they offload the responsibility of deployment to the Quicklisp maintainer, with nothing to be done on their part. This model is far from ideal for any serious developer in my honest opinion. You never know what version of your software users will receive, unless you submit a particular branch for Quicklisp to track, rather than the main branch of your repository. Even if you employ this approach, users of your \"stable\" software will be pulling in transitive dependencies that may not employ this approach, and there is practically no way for you to deploy your software with compatibile dependencies without maintaining your very own Quicklisp dist. Most users will not go through the trouble of installing more than the builtin Quicklisp dist though. Common Lisp developers seem not to care much about reproducible builds, or taking on the responsibility of software deployment on their own.\u003c/p\u003e\n\u003cp\u003eBecause the official Quicklisp dists are released once every month or two (which is an eternity in the software world), developers cannot push hot-fixes or address user-reported problems in a timely manner, unless they run their own dist and convince their users to use that, or convince their users to clone directly from upstream, and place it in a particular location on their filesystem that Quicklisp looks for to override dist versions.\u003c/p\u003e\n\u003cp\u003eI am of the very strong opinion that developers should be responsible for deploying and versioning their own software, without the aforementioned downsides of relying on a single point of failure to do so for them.\u003c/p\u003e\n\u003ch3 id=\"documentation\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#documentation\"\u003eDocumentation\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#documentation\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCommon Lisp libraries are rarely ever documented. \"Docstrings\" and code comments are not user documentation. A successful open-source project to be well-received by the public needs to have real offline user documentation, complete with plentiful usage examples, tutorials, imagery, and anything else that will transition a user more easily. This does not really need much explaining – Common Lisp software is mainly targeted at other developers that aren't afraid to read code and modify it to their liking.\u003c/p\u003e\n\u003ch3 id=\"software-quality\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#software_quality\"\u003eSoftware Quality\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#software-quality\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCommon Lisp software is of usually very high quality – if you take into consideration that it was more than likely developed by a single person and then stopped being maintained shortly thereafter. Common Lisp programmers are usually exceptional thinkers and writers of code, but they are often just one person – they cannot think of every edge case, find every major bug, write documentation, or keep interest over other priorities for very long.\u003c/p\u003e\n\u003cp\u003eThis hints at a very real problem with Common Lisp: it has a tendency to attract people that employ the 'NIH syndrome' and refuse to collaborate. There is a large overlap of software available, and there is a large selection of low-hanging fruit for new developers. This coupled with the fact that the language is small, relatively speaking, hurts the language immensely.\u003c/p\u003e\n\u003cp\u003eIn my opinion, this is due to the language being incredibly malleable. \u003ca href=\"https://news.ycombinator.com/item?id=13441793\"\u003eIt is usually much easier to re-implement an idea than it is to use/fix someone else's implementation\u003c/a\u003e. This is because Common Lisp code is so flexible that one can shape it to one's own thought processes. After all, code is just a projection of one's thought processes.\u003c/p\u003e\n\u003cp\u003eThis problem is recursive, in that we have many \"50%\" solutions to the same problems, and the next round of developers will create another set of solutions to add to the pile.\u003c/p\u003e\n\u003cp\u003eCommon Lisp, due to its flexibility, seems to cater very much towards single developers, and this shows brightly in the library ecosystem.\u003c/p\u003e\n\u003ch3 id=\"programming-paradigm\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#programming_paradigm\"\u003eProgramming Paradigm\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#programming-paradigm\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eCommon Lisp is a multi-paradigm programming language. That said, it's most prominent feature enables object-oriented programming in a unique way. While you can mix programming paradigms, it is nearly impossible to get away from OOP, with it being baked deep into the language.\u003c/p\u003e\n\u003cp\u003eArguably, one of the best features of Common Lisp is the Common Lisp Object System (CLOS). The language is designed from the ground up with an object-oriented approach, though most modern programmers would not recognize it as object oriented because it has a very unique approach. A major difference in CLOS relative to most other object systems is that it disassociates methods from classes, and solves some real problems that have plagued other OOP implementations, such as multiple inheritance. Additionally, the object system is fully customizable with the Meta-Object Protocol (MOP), allowing one to change how the object system behaves at every level.\u003c/p\u003e\n\u003cp\u003eWhile I do think that CLOS is very nice, and it is hard to live without it, I also think that OOP in general does not fit every programming problem. Infact, for most applications, I would much rather have parametric polymorphism instead of ad-hoc polymorphism that you get with Common Lisp generic functions.\u003c/p\u003e\n\u003cp\u003eGeneric functions in Common Lisp do not have arity-overloading like they do in Julia and other languages with generic functions. A generic function in Common Lisp has a fixed arity, and defines a protocol. Many people like this idea, but I don't.\u003c/p\u003e\n\u003cp\u003eAdditionally, most of the language proper is not generic. For example, you cannot redefine what it is to be a sequence, extending them to other collection types or iterators. There is an extension present in some implementations called \"extensible sequences\" that partially solves this problem, but it cannot be made portable having its existence in only a handful of implementations. The reason for this comes down to the fact that invoking generic code in Common Lisp carries a small performance penalty, so any code which might be used in a performance-critical context, will be pressured to be made non-generic.\u003c/p\u003e\n\u003cp\u003eUser-defined types in Common Lisp come in three forms: classes, structs, and types. \u003ccode\u003edefclass\u003c/code\u003e defines a class, \u003ccode\u003edefstruct\u003c/code\u003e defines a struct, and \u003ccode\u003edeftype\u003c/code\u003e defines a type.\u003c/p\u003e\n\u003cp\u003eStructs are rarely ever used except in performance-critical code, as they do not work seamlessly with the interactive development workflow of Common Lisp; redefining them is undefined behavior. Additionally, they only support single-inheritance.\u003c/p\u003e\n\u003cp\u003eUser-defined types are merely type aliases for existing types.\u003c/p\u003e\n\u003cp\u003eGeneric functions can only specialize their parameters on a class name, not a type. While every class has a type of the same name, the inverse is not true. One cannot define a method that operates on the integral range \u003ccode\u003e[0, 10)\u003c/code\u003e for example. It is however, possible to dispatch on a value, but only if that value is \u003ccode\u003eEQL\u003c/code\u003e-comparable, which is the case for scalars, not aggregates.\u003c/p\u003e\n\u003cp\u003eWhile CLOS is extremely powerful, and can be bent to do all sorts of nice tricks, these fundamental flaws are encountered on an almost daily basis in my programming, and I always wish for true parametric polymorphism with generic type parameters to stand in for a class of types.\u003c/p\u003e\n\u003ch3 id=\"community\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#community\"\u003eCommunity\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#community\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe open-source Common Lisp community is the smallest out of any programming language community I have participated in. It is often hard to get the help you need, and even more difficult to find someone to collaborate with on a project, as most developers prefer to work alone.\u003c/p\u003e\n\u003cp\u003eGetting help is also often a problem. Experienced Common Lispers assume a basic understanding of the language, good style practice, and familiarity with Emacs and the associated Common Lisp tooling installed. Asking for help as a beginner, and posting a small snippet of code, more often than not results in a wall of text of replies asking the user to fix their style before they can consider helping. This is quite dissuading as a newcomer, and detracts from the user's learning path. In extreme cases, which are not rare at all, the community can be quite inflammatory towards newcomer questions, as they often get very upset over incorrect terminology or improperly formatted code.\u003c/p\u003e\n\u003cp\u003eEven as an experienced Common Lisper, I tend not to partake in such discussions, as it is bad for my health. I actually have a disability, and there have been times when engaging in these discussions have contributed adversely to my condition. \u003ca href=\"https://eli.thegreenplace.net/2006/10/27/the-sad-state-of-the-lisp-user-community/\"\u003eThe community can just be flat-out toxic a lot of the time\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"performance\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#performance\"\u003ePerformance\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#performance\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eIf ultimate performance is your goal, Common Lisp is not the best choice for a language. While it is entirely possible to write code that can compete with the speed of C, it largely depends on the Common Lisp implementation, and making trade-offs that cripple the interactivity of the language.\u003c/p\u003e\n\u003cp\u003eRuntime performance gains can be achieved by not utilizing the dynamic dispatch feature of generic functions, which are inherent to class-based programming with CLOS. Instead, structs are typically used for creating aggregate types, as their field accessors are not generic, but regular functions, and redefining their definitions is undefined behavior.\u003c/p\u003e\n\u003cp\u003eType annotations usually have to be sprinkled throughout the code, and macros and compiler macros have to be used to transform code into more efficient representations at compile time.\u003c/p\u003e\n\u003cp\u003eArrays need to be specialized to pack immediate values into memory, rather than pointers to be chased to somewhere in heap memory. Element types that can be specialized are completely implementation-dependent, and almost always limited to scalars only. Arrays of structs, arrays of arrays, and many other data structures are usually not possible without performance implications.\u003c/p\u003e\n\u003cp\u003eWriting performant code in Common Lisp is not for everyone, and it most certainly cannot be done portably; what might run fast on one implementation may run poorly on another. The moment you start writing implementation-specific code, in my honest opinion, you are better off using another programming language (which can also be considered writing implementation-specific code).\u003c/p\u003e\n\u003ch2 id=\"why-i-prefer-julia-as-my-primary-programming-language\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#why_i_prefer_julia_as_my_primary_programming_language\"\u003eWhy I Prefer Julia As My Primary Programming Language\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#why-i-prefer-julia-as-my-primary-programming-language\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eJulia is such a wonderful language. It's hard to describe why I like it so much, but some of the reasons are listed below. In short, Julia is very similar to Common Lisp, but brings a lot of extra niceties to the table.\u003c/p\u003e\n\u003ch3 id=\"editor-support-1\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#editor_support__2\"\u003eEditor support\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#editor-support-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eJulia editor support is among the top in its class. You are not limited to a single editor to get the full experience of this dynamic programming language. There are well-polished editor plugins for a variety of editors, and there even exists \u003ca href=\"https://github.com/JuliaEditorSupport\"\u003ean organization\u003c/a\u003e dedicated to improving the Julia editor tooling.\u003c/p\u003e\n\u003cp\u003ePersonally, I use Vim (Neovim, actually) along with \u003ca href=\"https://github.com/julia-vscode/LanguageServer.jl\"\u003eLanguageServer.jl\u003c/a\u003e and the experience is very pleasant.\u003c/p\u003e\n\u003ch3 id=\"language-evolution-1\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#language_evolution__2\"\u003eLanguage Evolution\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#language-evolution-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eJulia does not have a language standard like Common Lisp does. It is free to evolve as the unique problem space it is attempting to address is further explored.\u003c/p\u003e\n\u003cp\u003eI consider this a good thing. I do not want a language frozen in time. I like to see growth, and Julia has been growing rapidly for many years, both in terms of adoption and the rate of new packages becoming available.\u003c/p\u003e\n\u003ch3 id=\"software-versioning-and-deployment-1\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#software_versioning_and_deployment__2\"\u003eSoftware Versioning and Deployment\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#software-versioning-and-deployment-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eUnlike Common Lisp, Julia gives the developer the responsibility of distributing their software. This is, however, very painless due to the built-in package manager, \u003ca href=\"https://pkgdocs.julialang.org/\"\u003ePkg.jl\u003c/a\u003e, in addition to package registries and related tools.\u003c/p\u003e\n\u003cp\u003eI host my software on GitHub, and the process of making my software discoverable to the wider Julia community is very simple. All I have to do is leave a comment on the commit I want to publish, and a GitHub bot takes care of analyzing my software, and merging it into the official package registry if it meets all of the requirements. The process is similarly simple for other hosting platforms, or if self-hosting.\u003c/p\u003e\n\u003cp\u003eOnce a package is in the official registry, it can be installed by anyone using the builtin package manager, which conveniently has a special mode built in the the REPL for managing packages.\u003c/p\u003e\n\u003cp\u003eReproducibility of builds is also handled very well. All Julia project environments contain a manifest file that records the exact versions of all transitive dependencies, along with a unique identifier for disambiguation, should the name of a project be found in multiple registries. Distributing this manifest file to a colleague is all that is needed for them to reproduce your exact development environment. It's all very painless.\u003c/p\u003e\n\u003cp\u003ePkg.jl is a very well-designed package manager offering a lot of features. I encourage you to read the documentation to discover everything it can do. It is by far the best package manager I have ever used.\u003c/p\u003e\n\u003ch3 id=\"programming-paradigm-1\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#programming_paradigm__2\"\u003eProgramming Paradigm\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#programming-paradigm-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eJulia is not an object-oriented language. Infact, it doesn't have classes at all. It has a unique type system that, at first glance, seems quite limiting in that only leaf nodes of the hierarchy can be instantiated. Intermediary nodes are abstract types which cannot be instantiated, but can be used to define behavior on entire classes of objects, even disjoint hierarchies by means of traits.\u003c/p\u003e\n\u003cp\u003eThe fact that you can only instantiate concrete leaf node types may seem a bit limiting, but it drastically simplifies generic function method applicability, makes it much easier to reason about programs, and encourages developers to employ a composition over inheritance architecture.\u003c/p\u003e\n\u003cp\u003eType parameterization and zero-cost generic functions are one of the primary reasons I switched to Julia. Writing efficient code couldn't be easier, and I don't have to sacrifice code clarity in doing so. Infact, I don't have to think about efficiency much at all apart from having a strong understanding of data structures and algorithms that every computer scientist should have.\u003c/p\u003e\n\u003cp\u003eOne other notable difference between Common Lisp and Julia generic functions, is optional parameters can have specializations in Julia, in which case multiple methods are generated for each arity. Common Lisp forbids generic functions from differing in signature, so this is simply not possible in Common Lisp without a Meta-Object Protocol extension.\u003c/p\u003e\n\u003ch3 id=\"community-1\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#community__2\"\u003eCommunity\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#community-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe Julia community is one of its strongest qualities, and is quite large. It is fragmented into various sub-communities: Slack, Zulip, Discourse, Discord, and IRC, to name a few. I am an active member of the Julia Zulip community, and questions I have get answered almost immediately. Additionally, this group of people is very welcoming to new users, and make me feel like part of the team.\u003c/p\u003e\n\u003cp\u003eLanguages looking to improve their community image should look no further than Julia. It is truly a wonderful group of people to be a part of.\u003c/p\u003e\n\u003ch3 id=\"performance-1\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#performance__2\"\u003ePerformance\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#performance-1\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eJulia code is fast – very fast. Even without knowing about common pitfalls like abstractly-typed fields, and type instability, in my experience, code runs much faster than highly hand-optimized Common Lisp code using an implementation known to generate efficient machine code.\u003c/p\u003e\n\u003cp\u003eInfact, the first version of my most recent project saw an order of magnitude difference when ported from Common Lisp to Julia, without any effort or attention to optimization techniques. This says a lot to me, because a great deal of time was spent optimizing the Common Lisp code to be as fast as possible without sacrificing maintainability or readability.\u003c/p\u003e\n\u003cp\u003eJulia code just performs good, and is very readable by default.\u003c/p\u003e\n\u003cp\u003eThe final stable version of my recent project ported to Julia, complete with minor optimizations, saw a performance increase of 2 to 3 orders of magnitude. Functions that took milliseconds to execute were on the scale of nanoseconds in Julia, and code quality didn't suffer.\u003c/p\u003e\n\u003cp\u003eThis is largely due to the excellent JIT compiler of Julia, and its rich type system. Generic functions in Julia do not carry any performance overhead, and type parameterization is even possible, allowing one to define functionality for a whole class of types without any runtime dispatch penalty.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003e\u003ca href=\"https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#conclusion\"\u003eConclusion\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#conclusion\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eI have had my eye on Julia for many years, and I now consider it ready to be my \"everyday\" programming language.\u003c/p\u003e\n\u003cp\u003eIts strong focus on types and generic programming make it ideal to solve complex problems in an efficient manner, and without type annotations all over the place. Julia's type inference engine is actually extremely good, and constant propagation always surprises me at just how well it works.\u003c/p\u003e\n\u003cp\u003eBeing able to use Julia in my editor of choice was another big plus in my book. I \u003cem\u003ereally\u003c/em\u003e dislike Emacs \u003cem\u003ethat\u003c/em\u003e much.\u003c/p\u003e\n\u003cp\u003eThe community is very friendly, knowledgeable, and inclusive.\u003c/p\u003e\n\u003cp\u003eOne thing I did not compare above is both languages' macro systems. This is because Julia macros are very similar to Common Lisp, and there are better resources to learn about them. One thing I will point out, is that Julia macros do automatic gensym'ing, as opposed to opt-in with Common Lisp, though you can opt-out on a per-symbol basis. This makes macros hygienic by default. Additionally, Julia has \"generated functions\", which to a Common Lisper, can be thought of as a compiler macro; their input arguments are types, not expressions, that are expanded after type inference. This allows you to generate more efficient code that cannot be determined at the syntax level.\u003c/p\u003e\n\u003cp\u003eAlso not mentioned, is Julia's module system, which is very similar to Common Lisp's package system. Symbols are string-interned by the parser in much the same way as Common Lisp. The only thing worth pointing out here, is that modules can be hierarchical, unlike Common Lisp packages, and there is no need for Common Lisp's \"package-local nicknames\" extension, as this feature is baked into the Julia module system already.\u003c/p\u003e\n\u003cp\u003eIn summary, you can tell the Julia designers were well aware of Common Lisp, and their attempts to make its ideas more convenient really shows once you become familiar enough with the language. I consider Julia to be a Lisp, just without the parentheses. It \u003cem\u003ereally\u003c/em\u003e is not that far off from Common Lisp if you squint really hard, and that eased my transition quite a bit.\u003c/p\u003e\n\u003cp\u003e\u003csup id=\"fnref-1\"\u003e\u003ca href=\"#fn-1\" class=\"footnote-ref\"\u003e1\u003c/a\u003e\u003c/sup\u003e The term \u003cem\u003epackage\u003c/em\u003e in Common Lisp is actually similar to \u003cem\u003emodule\u003c/em\u003e in Julia. Common Lisp developers refer to what most other languages refer to as packages, as \u003cem\u003esystems\u003c/em\u003e instead.\u003c/p\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1766965759366,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"a724de3efd251cf89fe82a5860d9008b","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":43,"column":5,"offset":2710},"end":{"line":43,"column":29,"offset":2734},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2026.articles","alias":"What I read in 2026","position":{"start":{"line":72,"column":3,"offset":4440},"end":{"line":72,"column":45,"offset":4482},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2026.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2025.articles","alias":"2025","position":{"start":{"line":73,"column":5,"offset":4487},"end":{"line":73,"column":32,"offset":4514},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2025.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2024.articles","alias":"2024","position":{"start":{"line":74,"column":5,"offset":4519},"end":{"line":74,"column":32,"offset":4546},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2024.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2023.articles","alias":"2023","position":{"start":{"line":75,"column":5,"offset":4551},"end":{"line":75,"column":32,"offset":4578},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2023.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2022.articles","alias":"2022","position":{"start":{"line":76,"column":5,"offset":4583},"end":{"line":76,"column":32,"offset":4610},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2022.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":82,"column":3,"offset":4746},"end":{"line":82,"column":39,"offset":4782},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":76,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","o7xruzrah5wzqetottecss7","z1zo2mp6ddji5p317i4x9xw","v06c2tjelh341x4resa50fh","0yqesk4rcffwgyuab5x8rfa","sy2vkbtyu671chkvgn1yt8j","ufixpmxoydiccoh59kphrib","alswadkx4wb05y1z9iwfzfv","1daut9dpw70xd0zh5a7j5p4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 현실은 인간의 연산으로 완전히 파악할 수 없는 복잡계. 주어진 상황과 능력으로 할 수 있는 최선의 적응은 단순함과 꾸준함.\n\n  - 파산을 면하는 선에서 여러가지를 해보고 자신에게 맞는 걸 위주로 꾸준히. 그를 위해 단순, 편안, 쾌적함이 필요.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2026|read.2026.articles]]\n  - [[2025|read.2025.articles]]\n  - [[2024|read.2024.articles]]\n  - [[2023|read.2023.articles]]\n  - [[2022|read.2022.articles]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"a2yqeahizt09hdtm7f7rp9p"},"buildId":"wirstT2ztC8OQsbzKjhvw","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>