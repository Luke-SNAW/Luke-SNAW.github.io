<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Why I Am Learning Category Theory 1</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Why I Am Learning Category Theory 1"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/m3zpjkkh97bf1ao5rgm3k8l/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="12/5/2022"/><meta property="article:modified_time" content="12/5/2022"/><link rel="canonical" href="https://luke-snaw.github.io//notes/m3zpjkkh97bf1ao5rgm3k8l/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_buildManifest.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="why-i-am-learning-category-theory-1">Why I Am Learning Category Theory 1<a aria-hidden="true" class="anchor-heading icon-link" href="#why-i-am-learning-category-theory-1"></a></h1>
<blockquote>
<p><a href="https://the.scapegoat.dev/why-i-am-learning-category-theory-1/">https://the.scapegoat.dev/why-i-am-learning-category-theory-1/</a><br>
<a href="https://news.ycombinator.com/item?id=33802844">https://news.ycombinator.com/item?id=33802844</a></p>
</blockquote>
<p>Category theory is a domain of mathematics that exerts a strange influence over programmers. One thing that can be said for sure about category theory is that it is highly abstract, and its relationship to software engineering is not immediately obvious. I consider myself to be more on the pragmatic side of software engineering, so <strong>why did I set out to learn category theory beyond the few concepts popularized by functional programming?</strong></p>
<p>In particular, I have been following along <a href="http://brendanfong.com/programmingcats.html">MIT 18.S097: Programming with Categories</a> and reading <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category Theory for Programmers</a> by Bartosz Milewski along with a few books like Steve Awodey's <a href="https://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182">Category Theory</a> and <a href="https://www.amazon.com/Invitation-Applied-Category-Theory-Compositionality/dp/1108711820/ref=d_bpx_wsirn_iabw_v1_sccl_2_1/144-6076266-4505621">Seven Sketches in Compositionality</a>. I want to thank my fellow Recursers who are taking part in our category theory reading group, as I wouldn't have nearly as much fun as I have.</p>
<h2 id="my-background-in-functional-programming">My background in functional programming<a aria-hidden="true" class="anchor-heading icon-link" href="#my-background-in-functional-programming"></a></h2>
<p><strong>My background is in systems programming</strong>; I work mostly on embedded and full-stack web development. Having been a Common Lisp aficionado, I use a lot of functional programming patterns. Until recently, my knowledge of category theory was a set of applied patterns: functors, monoids, foldables, applicatives, and especially monads.</p>
<p>I rarely use these concepts explicitly, but they help me build software: I know when to fold a monoidal data structure, how to lift a functor into another, and how to use applicatives to validate data (if these sound abstract, that's because I wanted it to sound abstract. The programming itself is very pedestrian).</p>
<p>Since I write mostly C++, PHP or Javascript, I use functions and simple data structures and don't go heavy on generics and type system magic. However, <strong>because of its theoretical underpinnings, my code can (usually) be cleanly composed into larger structures.</strong></p>
<p>Yet, I always knew my approach to be a "pop-sci" version of category theory: I never bothered to look up the actual mathematical theory. The rare times I opened up a textbook, I was taken aback by millions of words I didn't know—I would look things up on Wikipedia or nlab and be utterly confused.</p>
<p>My gut, however, was telling me that there was a lot of potential to be unlocked by delving deeper.</p>
<h2 id="turning-diagrams-into-code">Turning diagrams into code<a aria-hidden="true" class="anchor-heading icon-link" href="#turning-diagrams-into-code"></a></h2>
<p>Since I was a kid, I have been fascinated with <a href="https://the.scapegoat.dev/diagrams/">diagrams</a>.</p>
<p>Nowadays, <strong>I write code by first drawing simple boxes and arrows and doodles, then iteratively transforming them into more formal constructs</strong>. The drawings can represent time sequences, data structures, schema evolution, infrastructure, and state machines. At some point, the design is concrete enough that it can be turned into code.</p>
<p><strong>Using these diagrams made collaboration with engineers in other disciplines very effective.</strong> For example, when drawing state machine diagrams and sequence diagrams, mechanical engineers I collaborated with were able to point out subtle race conditions, missed transitions, and faulty logic in my firmware.</p>
<p>I "discovered" monads by trying really hard to encode the "arrows" of my state machines into more mundane programming languages like PHP or C++. It was a very autodidact approach, and I knew intuitively that there were formal ways of turning this visual approach to problem-solving into robust software.</p>
<p>It was only years later that I realized that I had been implementing monads all along. This was a deep moment of insight for me. It allowed me to reduce tricky programming problems (concurrency in embedded systems, transaction sequencing, and error handling in distributed systems) into a single, concise concept, along with almost trivial-looking code.</p>
<p>Category theory is literally the mathematics of boxes (objects), arrows (morphisms), and composition. <strong>Composition is how we build large software out of smaller parts while keeping complexity in check.</strong> Boxes and arrows is also how humans think in other disciplines, which makes category theory a powerful tool for uncovering cross-disciplinary analogies.</p>
<h2 id="putting-words-to-my-thinking">Putting words to my thinking<a aria-hidden="true" class="anchor-heading icon-link" href="#putting-words-to-my-thinking"></a></h2>
<p><strong>I have always had an "expanding," holistic way of thinking about software systems.</strong> Going back to software I wrote as a junior developer, like this <a href="https://github.com/wesen/avr-bt-stack">AVR Bluetooth Stack</a>, I wonder if I would write it any differently nowadays. My understanding of composition, naming, and components seem to already be fully formed, despite my inexperience (I only knew BASIC, assembly, and C when I wrote the above).</p>
<p>This holistic approach encompasses systems (the above stack runs on both the host and 8-bit microcontrollers, which wasn't a common pattern back in 2001), machine and human (I always try to think of the developer as an <a href="https://the.scapegoat.dev/you-the-developer-are-a-user-too/">actual user of the software they write</a>, code structure, runtime behavior, among other things. Of course, 18-year-old me didn't come up with these patterns out of the box, and they are influenced by the design of the Bluetooth specification, but the fact that I knew to recognize and apply them speaks to an innate sense of structure.</p>
<p>As described in the previous paragraph, I build software by drawing boxes and arrows first and refining them until I can encode them as software.</p>
<p>This structural approach encompasses much more than just code and data structures. I apply it to:</p>
<ul>
<li>product thinking</li>
<li>communication structures</li>
<li>schema design and evolution (database design, data schema evolution)</li>
<li>logging and debugging (events, logging schema)</li>
<li>runtime behavior (event loops, state machines, sequence diagrams)</li>
<li>module and codebase decoupling</li>
<li>software engineering workflow (git workflow, issues, and project management)</li>
</ul>
<p>Breaking things into boxes and arrows allows me to recognize commonalities across domains, so much so that I, for example, consider <a href="https://the.scapegoat.dev/embedded-programming-is-like-web-development/">web development to be the same as embedded development</a>. I thought this statement would be quite uncontroversial, but it turns out that I got a lot of pushback. The reason I consider the two to be similar, if not the same, is that I have been able to form abstractions that carry across from embedded development to web development. <strong>An abstraction is a controlled form of forgetting the details to focus on something more fundamental, allowing one to make statements that are shorter to state yet broader in meaning.</strong></p>
<p>Category theory is really the mathematics of composition, reducing everything it encounters to simple structures of objects and morphisms (boxes and arrows, really) and showing where they are similar and where they aren't based on how they can be composed. Once a system has been abstracted, that abstraction is abstracted: categories, functors, and monoids themselves form categories, which are yet more categories that can be put into relation with other categories.</p>
<p><strong>I hope that category theory will allow me to formalize my intuitive understanding of abstraction, put words to it, and use those words (or, better, words others have written) to explain my thinking.</strong> The hardest about abstraction is that it requires effort to form yet becomes trivial once understood. This leads to a myriad of confusing monad tutorials that assume that there is one easy way to form the mental chunk for that abstraction when really understanding monads about the repeated struggle to work with the concept until it finally clicks. Everybody's favorite monad tutorial is the third they worked through.</p>
<h2 id="writing-more-expressive-software">Writing more expressive software<a aria-hidden="true" class="anchor-heading icon-link" href="#writing-more-expressive-software"></a></h2>
<p>Finally, I am seeing how learning about concepts I already had a good intuitive feel for (monoids, functors, ...) unlocks a whole new world of abstraction. I was swimming at the surface of seemingly simple concepts that actually have incredible depth, depths talented mathematicians have been studying for centuries. A good podcast about this is <a href="https://corecursive.com/050-sam-ritchie-portal-abstractions-2/">corecursive's episode about portal abstractions with Sam Ritchie</a>.</p>
<p>While I already use a lot of these patterns when writing functional code, there is so much more to be gained from understanding monoids or functors as formulated in category theory language. I started recognizing them in schema migrations, database transactions, state transitions in embedded systems, wire protocols, etc.</p>
<p><strong>While I rarely call my classes or functions or modules mathematical names (in fact, due to the messy imperative languages I tend to use, I often can't, as their type system is rarely powerful enough), my thinking is heavily inspired by the underlying mathematical concept</strong>. That doesn't really matter much to me since writing verbose code due to not having programming language support doesn't impact the abstraction and its validity as such.</p>
<p><strong>The soundness of the abstractions unearthed by thinking about a domain in terms of category theory means that elegant, concise, and, most importantly, composable domain-specific languages can be designed.</strong> This might be the most important result I get from learning more about mathematics. To me, a domain-specific language doesn't need to be an actual language but also encompasses API and protocol design.</p>
<h2 id="a-never-ending-journey">A never-ending journey<a aria-hidden="true" class="anchor-heading icon-link" href="#a-never-ending-journey"></a></h2>
<p>I am still at the very surface of category theory and just hit the first wall by working on F-algebras and recursion schemes. Yet, the value I got from sitting down and understanding functors, monoids, and adjunctions at a rigorous mathematical level, as well as working with the "actual" definition of categories, has already brought me a lot of confidence in my current approach to software design.</p>
<p>I couldn't be more excited about what is coming next.</p></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#my-background-in-functional-programming" title="My background in functional programming">My background in functional programming</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#turning-diagrams-into-code" title="Turning diagrams into code">Turning diagrams into code</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#putting-words-to-my-thinking" title="Putting words to my thinking">Putting words to my thinking</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#writing-more-expressive-software" title="Writing more expressive software">Writing more expressive software</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#a-never-ending-journey" title="A never-ending journey">A never-ending journey</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"m3zpjkkh97bf1ao5rgm3k8l","title":"Why I Am Learning Category Theory 1","desc":"","updated":1670205125662,"created":1670204953258,"custom":{},"fname":"dev.functional-programming.why-i-am-learning-category-theory-1","type":"note","vault":{"fsPath":"vault"},"contentHash":"eb5ed16f3ab5497d3f91e8ac688c44db","links":[],"anchors":{"my-background-in-functional-programming":{"type":"header","text":"My background in functional programming","value":"my-background-in-functional-programming","line":15,"column":0,"depth":2},"turning-diagrams-into-code":{"type":"header","text":"Turning diagrams into code","value":"turning-diagrams-into-code","line":27,"column":0,"depth":2},"putting-words-to-my-thinking":{"type":"header","text":"Putting words to my thinking","value":"putting-words-to-my-thinking","line":41,"column":0,"depth":2},"writing-more-expressive-software":{"type":"header","text":"Writing more expressive software","value":"writing-more-expressive-software","line":65,"column":0,"depth":2},"a-never-ending-journey":{"type":"header","text":"A never-ending journey","value":"a-never-ending-journey","line":75,"column":0,"depth":2}},"children":[],"parent":"HtVLXiN97I2jTm8h2NEVQ","data":{}},"body":"\u003ch1 id=\"why-i-am-learning-category-theory-1\"\u003eWhy I Am Learning Category Theory 1\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#why-i-am-learning-category-theory-1\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://the.scapegoat.dev/why-i-am-learning-category-theory-1/\"\u003ehttps://the.scapegoat.dev/why-i-am-learning-category-theory-1/\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://news.ycombinator.com/item?id=33802844\"\u003ehttps://news.ycombinator.com/item?id=33802844\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eCategory theory is a domain of mathematics that exerts a strange influence over programmers. One thing that can be said for sure about category theory is that it is highly abstract, and its relationship to software engineering is not immediately obvious. I consider myself to be more on the pragmatic side of software engineering, so \u003cstrong\u003ewhy did I set out to learn category theory beyond the few concepts popularized by functional programming?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eIn particular, I have been following along \u003ca href=\"http://brendanfong.com/programmingcats.html\"\u003eMIT 18.S097: Programming with Categories\u003c/a\u003e and reading \u003ca href=\"https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/\"\u003eCategory Theory for Programmers\u003c/a\u003e by Bartosz Milewski along with a few books like Steve Awodey's \u003ca href=\"https://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182\"\u003eCategory Theory\u003c/a\u003e and \u003ca href=\"https://www.amazon.com/Invitation-Applied-Category-Theory-Compositionality/dp/1108711820/ref=d_bpx_wsirn_iabw_v1_sccl_2_1/144-6076266-4505621\"\u003eSeven Sketches in Compositionality\u003c/a\u003e. I want to thank my fellow Recursers who are taking part in our category theory reading group, as I wouldn't have nearly as much fun as I have.\u003c/p\u003e\n\u003ch2 id=\"my-background-in-functional-programming\"\u003eMy background in functional programming\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#my-background-in-functional-programming\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eMy background is in systems programming\u003c/strong\u003e; I work mostly on embedded and full-stack web development. Having been a Common Lisp aficionado, I use a lot of functional programming patterns. Until recently, my knowledge of category theory was a set of applied patterns: functors, monoids, foldables, applicatives, and especially monads.\u003c/p\u003e\n\u003cp\u003eI rarely use these concepts explicitly, but they help me build software: I know when to fold a monoidal data structure, how to lift a functor into another, and how to use applicatives to validate data (if these sound abstract, that's because I wanted it to sound abstract. The programming itself is very pedestrian).\u003c/p\u003e\n\u003cp\u003eSince I write mostly C++, PHP or Javascript, I use functions and simple data structures and don't go heavy on generics and type system magic. However, \u003cstrong\u003ebecause of its theoretical underpinnings, my code can (usually) be cleanly composed into larger structures.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eYet, I always knew my approach to be a \"pop-sci\" version of category theory: I never bothered to look up the actual mathematical theory. The rare times I opened up a textbook, I was taken aback by millions of words I didn't know—I would look things up on Wikipedia or nlab and be utterly confused.\u003c/p\u003e\n\u003cp\u003eMy gut, however, was telling me that there was a lot of potential to be unlocked by delving deeper.\u003c/p\u003e\n\u003ch2 id=\"turning-diagrams-into-code\"\u003eTurning diagrams into code\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#turning-diagrams-into-code\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSince I was a kid, I have been fascinated with \u003ca href=\"https://the.scapegoat.dev/diagrams/\"\u003ediagrams\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eNowadays, \u003cstrong\u003eI write code by first drawing simple boxes and arrows and doodles, then iteratively transforming them into more formal constructs\u003c/strong\u003e. The drawings can represent time sequences, data structures, schema evolution, infrastructure, and state machines. At some point, the design is concrete enough that it can be turned into code.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUsing these diagrams made collaboration with engineers in other disciplines very effective.\u003c/strong\u003e For example, when drawing state machine diagrams and sequence diagrams, mechanical engineers I collaborated with were able to point out subtle race conditions, missed transitions, and faulty logic in my firmware.\u003c/p\u003e\n\u003cp\u003eI \"discovered\" monads by trying really hard to encode the \"arrows\" of my state machines into more mundane programming languages like PHP or C++. It was a very autodidact approach, and I knew intuitively that there were formal ways of turning this visual approach to problem-solving into robust software.\u003c/p\u003e\n\u003cp\u003eIt was only years later that I realized that I had been implementing monads all along. This was a deep moment of insight for me. It allowed me to reduce tricky programming problems (concurrency in embedded systems, transaction sequencing, and error handling in distributed systems) into a single, concise concept, along with almost trivial-looking code.\u003c/p\u003e\n\u003cp\u003eCategory theory is literally the mathematics of boxes (objects), arrows (morphisms), and composition. \u003cstrong\u003eComposition is how we build large software out of smaller parts while keeping complexity in check.\u003c/strong\u003e Boxes and arrows is also how humans think in other disciplines, which makes category theory a powerful tool for uncovering cross-disciplinary analogies.\u003c/p\u003e\n\u003ch2 id=\"putting-words-to-my-thinking\"\u003ePutting words to my thinking\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#putting-words-to-my-thinking\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eI have always had an \"expanding,\" holistic way of thinking about software systems.\u003c/strong\u003e Going back to software I wrote as a junior developer, like this \u003ca href=\"https://github.com/wesen/avr-bt-stack\"\u003eAVR Bluetooth Stack\u003c/a\u003e, I wonder if I would write it any differently nowadays. My understanding of composition, naming, and components seem to already be fully formed, despite my inexperience (I only knew BASIC, assembly, and C when I wrote the above).\u003c/p\u003e\n\u003cp\u003eThis holistic approach encompasses systems (the above stack runs on both the host and 8-bit microcontrollers, which wasn't a common pattern back in 2001), machine and human (I always try to think of the developer as an \u003ca href=\"https://the.scapegoat.dev/you-the-developer-are-a-user-too/\"\u003eactual user of the software they write\u003c/a\u003e, code structure, runtime behavior, among other things. Of course, 18-year-old me didn't come up with these patterns out of the box, and they are influenced by the design of the Bluetooth specification, but the fact that I knew to recognize and apply them speaks to an innate sense of structure.\u003c/p\u003e\n\u003cp\u003eAs described in the previous paragraph, I build software by drawing boxes and arrows first and refining them until I can encode them as software.\u003c/p\u003e\n\u003cp\u003eThis structural approach encompasses much more than just code and data structures. I apply it to:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eproduct thinking\u003c/li\u003e\n\u003cli\u003ecommunication structures\u003c/li\u003e\n\u003cli\u003eschema design and evolution (database design, data schema evolution)\u003c/li\u003e\n\u003cli\u003elogging and debugging (events, logging schema)\u003c/li\u003e\n\u003cli\u003eruntime behavior (event loops, state machines, sequence diagrams)\u003c/li\u003e\n\u003cli\u003emodule and codebase decoupling\u003c/li\u003e\n\u003cli\u003esoftware engineering workflow (git workflow, issues, and project management)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBreaking things into boxes and arrows allows me to recognize commonalities across domains, so much so that I, for example, consider \u003ca href=\"https://the.scapegoat.dev/embedded-programming-is-like-web-development/\"\u003eweb development to be the same as embedded development\u003c/a\u003e. I thought this statement would be quite uncontroversial, but it turns out that I got a lot of pushback. The reason I consider the two to be similar, if not the same, is that I have been able to form abstractions that carry across from embedded development to web development. \u003cstrong\u003eAn abstraction is a controlled form of forgetting the details to focus on something more fundamental, allowing one to make statements that are shorter to state yet broader in meaning.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eCategory theory is really the mathematics of composition, reducing everything it encounters to simple structures of objects and morphisms (boxes and arrows, really) and showing where they are similar and where they aren't based on how they can be composed. Once a system has been abstracted, that abstraction is abstracted: categories, functors, and monoids themselves form categories, which are yet more categories that can be put into relation with other categories.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eI hope that category theory will allow me to formalize my intuitive understanding of abstraction, put words to it, and use those words (or, better, words others have written) to explain my thinking.\u003c/strong\u003e The hardest about abstraction is that it requires effort to form yet becomes trivial once understood. This leads to a myriad of confusing monad tutorials that assume that there is one easy way to form the mental chunk for that abstraction when really understanding monads about the repeated struggle to work with the concept until it finally clicks. Everybody's favorite monad tutorial is the third they worked through.\u003c/p\u003e\n\u003ch2 id=\"writing-more-expressive-software\"\u003eWriting more expressive software\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#writing-more-expressive-software\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFinally, I am seeing how learning about concepts I already had a good intuitive feel for (monoids, functors, ...) unlocks a whole new world of abstraction. I was swimming at the surface of seemingly simple concepts that actually have incredible depth, depths talented mathematicians have been studying for centuries. A good podcast about this is \u003ca href=\"https://corecursive.com/050-sam-ritchie-portal-abstractions-2/\"\u003ecorecursive's episode about portal abstractions with Sam Ritchie\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWhile I already use a lot of these patterns when writing functional code, there is so much more to be gained from understanding monoids or functors as formulated in category theory language. I started recognizing them in schema migrations, database transactions, state transitions in embedded systems, wire protocols, etc.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhile I rarely call my classes or functions or modules mathematical names (in fact, due to the messy imperative languages I tend to use, I often can't, as their type system is rarely powerful enough), my thinking is heavily inspired by the underlying mathematical concept\u003c/strong\u003e. That doesn't really matter much to me since writing verbose code due to not having programming language support doesn't impact the abstraction and its validity as such.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThe soundness of the abstractions unearthed by thinking about a domain in terms of category theory means that elegant, concise, and, most importantly, composable domain-specific languages can be designed.\u003c/strong\u003e This might be the most important result I get from learning more about mathematics. To me, a domain-specific language doesn't need to be an actual language but also encompasses API and protocol design.\u003c/p\u003e\n\u003ch2 id=\"a-never-ending-journey\"\u003eA never-ending journey\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#a-never-ending-journey\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eI am still at the very surface of category theory and just hit the first wall by working on F-algebras and recursion schemes. Yet, the value I got from sitting down and understanding functors, monoids, and adjunctions at a rigorous mathematical level, as well as working with the \"actual\" definition of categories, has already brought me a lot of confidence in my current approach to software design.\u003c/p\u003e\n\u003cp\u003eI couldn't be more excited about what is coming next.\u003c/p\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"m3zpjkkh97bf1ao5rgm3k8l"},"buildId":"vOE8u-mg___OsOsz4tjEg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>