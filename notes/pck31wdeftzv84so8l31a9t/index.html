<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Building with Elixir for Three Years: A Production Retrospective</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Building with Elixir for Three Years: A Production Retrospective"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/pck31wdeftzv84so8l31a9t/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="10/19/2025"/><meta property="article:modified_time" content="10/19/2025"/><link rel="canonical" href="https://luke-snaw.github.io//notes/pck31wdeftzv84so8l31a9t/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_buildManifest.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="building-with-elixir-for-three-years-a-production-retrospective">Building with Elixir for Three Years: A Production Retrospective<a aria-hidden="true" class="anchor-heading icon-link" href="#building-with-elixir-for-three-years-a-production-retrospective"></a></h1>
<blockquote>
<p><a href="https://ryanrasti.com/blog/elixir-three-years-production/">https://ryanrasti.com/blog/elixir-three-years-production/</a> - Jul 10, 2025</p>
</blockquote>
<ul>
<li>The BEAM (Erlang VM) delivered on its promises of scalability, concurrency, and resilience, reducing the need for complex tooling and orchestration.</li>
<li>The Elixir ecosystem has exceptional depth in core areas but lacks breadth, with gaps in libraries for tasks outside the core ecosystem.</li>
<li>Phoenix and LiveView aimed to eliminate frontend/backend split pain but did not meet the complex UI/UX needs of the warehouse management system.</li>
<li>Developer experience in Elixir fell short compared to TypeScript, with issues in autocomplete, compile times, and static analysis.</li>
<li>Elixir attracted high-quality talent, with developers demonstrating deep technical knowledge and pragmatic problem-solving skills.</li>
<li>Oban proved to be a reliable tool for background jobs, and remote IEx was invaluable for debugging production issues during the MVP launch.</li>
<li>Deployment of Elixir applications presented unexpected challenges, leading to the use of NixOS for VM management.</li>
<li>Elixir is best suited for specific problems like distributed systems and real-time features, but may not be ideal for full-stack applications where developer velocity is crucial.</li>
<li>The future of Elixir may be influenced by AI, with potential for accelerated evolution or consolidation around TypeScript.</li>
<li>TypeScript's superior tooling, instant feedback loops, and static types give it an advantage in the AI-driven development landscape.</li>
</ul>
<hr>
<p>I recently responded to a <a href="https://news.ycombinator.com/item?id=44495879">Hacker News thread</a> about Elixir’s benefits. As CTO of a startup that built with Elixir for two years before deploying to production in our third, I wanted to share our actual experience versus the marketing promises.</p>
<p>We built a warehouse management system from scratch — complete with multi-warehouse inventory tracking, order routing, pick/pack workflows, and dozens of e-commerce integrations. We successfully went live with our MVP and first customers, and have since fulfilled over 100,000 orders. Here’s what worked, what didn’t, and what I’d do differently.</p>
<h2 id="the-beam-living-up-to-the-hype">The BEAM: Living Up to the Hype<a aria-hidden="true" class="anchor-heading icon-link" href="#the-beam-living-up-to-the-hype"></a></h2>
<p>The Erlang VM delivered on its core promise. Scalability, concurrency, and resilience “just worked.” No orchestration needed, no complex tooling, no surprises. You avoid the typical distributed systems mess — no gluing together Redis for queues, Kubernetes for orchestration, and a dozen other tools. Everything you need comes built-in. When you are running a lean team, this reduced surface area means you can iterate faster with fewer things that can break.</p>
<h2 id="the-ecosystem-depth-over-breadth">The Ecosystem: Depth Over Breadth<a aria-hidden="true" class="anchor-heading icon-link" href="#the-ecosystem-depth-over-breadth"></a></h2>
<p>The ecosystem is hit or miss. I would characterize it as having exceptional depth where it matters but frustrating gaps elsewhere.</p>
<p><a href="https://phoenixframework.org/">Phoenix</a> and <a href="https://hexdocs.pm/oban/Oban.html">Oban</a> were fantastic — world-class libraries that did exactly what we needed.</p>
<p><a href="https://hexdocs.pm/ecto/Ecto.html">Ecto</a> deserves special mention. This query builder opened my eyes to what is possible beyond raw SQL. It saved us countless times with its ability to dynamically compose queries — in that sense, it is even more powerful than raw SQL. The biggest drawback? Most extensions require writing macros, which are hard to grasp when you are picking up Elixir for the first time.</p>
<p>Step outside that golden path and you will hit walls fast. No good libraries for parsing shell commands. Shopify integration libraries were either missing or unmaintained. When you venture beyond the core ecosystem, be ready to build it yourself.</p>
<h2 id="phoenix-the-double-edged-sword">Phoenix: The Double-Edged Sword<a aria-hidden="true" class="anchor-heading icon-link" href="#phoenix-the-double-edged-sword"></a></h2>
<p>Phoenix and <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html">LiveView</a> promise to eliminate the split frontend/backend pain that plagues so many teams. No more maintaining separate frontends. No more coordinating across teams. No more API versioning headaches. For rapid iteration, this sounds transformative.</p>
<p>We started with React from day one. LiveView could handle simple interactions beautifully, but we knew it could not deliver the complex UI/UX flows our warehouse management system demanded. We ended up with the exact split-stack complexity Phoenix aims to solve. Looking back, a full-stack Node.js framework would have simplified our client/server interaction considerably.</p>
<h2 id="developer-experience-the-achilles-heel">Developer Experience: The Achilles’ Heel<a aria-hidden="true" class="anchor-heading icon-link" href="#developer-experience-the-achilles-heel"></a></h2>
<p>I love functional programming, and Elixir’s standard library is thoughtfully designed. The developer experience fell short compared to TypeScript in ways that compound over time.</p>
<p><strong>Autocomplete was a coin flip.</strong> Half the time <a href="https://github.com/elixir-lsp/elixir-ls">ElixirLS</a> simply did not work — either too slow or completely broken. When it did work, the static analysis was not sophisticated enough to provide genuinely useful suggestions. In a 300K line codebase, you need autocomplete just to remember function names and schema attributes. Without it, you are constantly grepping through files.</p>
<p><strong>Compile times broke my flow.</strong> Our 300K line codebase took 10 seconds to recompile after a one-line change, plus a few more seconds for tests. We used GraphQL to get typing between backend and frontend — crucial for type safety and developer experience, but it came at a steep cost. After several hundred thousand lines of code, the full cycle became painful: recompile Elixir, then regenerate types — easily 20 seconds on beefy hardware for a single-line change. VS Code often choked on the huge type definition changes, requiring a full restart to make IntelliSense happy again. Compare that to the instant feedback loop of <a href="https://vitejs.dev/">Vite</a>. Those 20-second turnarounds might sound trivial, but they shatter concentration and compound into hours of lost productivity.</p>
<h2 id="the-unexpected-wins">The Unexpected Wins<a aria-hidden="true" class="anchor-heading icon-link" href="#the-unexpected-wins"></a></h2>
<p>Despite the challenges, Elixir delivered some surprising victories.</p>
<p><strong>Talent quality was exceptional.</strong> Every Elixir developer we interviewed demonstrated deep technical knowledge and pragmatic problem-solving skills. The community self-selects for engineers who choose tools for sound technical reasons, not resume padding or trend chasing. Elixir also made our roles more appealing — talented engineers were excited to work with the language, giving us an edge in recruiting.</p>
<p><strong>Oban saved us repeatedly.</strong> We leaned on it heavily for background jobs, and I honestly cannot imagine building our system without it. Rock solid.</p>
<p><strong>Remote IEx got us through MVP.</strong> Being able to debug production issues in real-time via remote console access was absolutely clutch for our launch. Not something you would want to rely on forever, but invaluable when you need it.</p>
<h2 id="deployment-more-complex-than-expected">Deployment: More Complex Than Expected<a aria-hidden="true" class="anchor-heading icon-link" href="#deployment-more-complex-than-expected"></a></h2>
<p>Elixir’s distributed nature, while powerful, created unexpected deployment challenges. We started on Fly.io but their repeated instability and lack of managed Postgres forced us to look elsewhere. Cloud Run seemed perfect until we discovered it did not support the peer-to-peer ports Elixir needed for clustering.</p>
<p>We ended up running virtual machines with <a href="https://nixos.org/">NixOS</a> to manage the overhead. The alternative was Kubernetes, but even managed Kubernetes felt like overkill for our needs. NixOS made VM management tolerable, but it was still more operational complexity than we had budgeted for.</p>
<h2 id="the-verdict">The Verdict<a aria-hidden="true" class="anchor-heading icon-link" href="#the-verdict"></a></h2>
<p>Elixir shines as the right tool for specific problems. For us building a full-stack application, the experience was decidedly mixed.</p>
<p>Part of this challenge is structural — JavaScript owns the frontend, giving JavaScript frameworks an inherent full-stack advantage that is hard to overcome. There is also significant room for Elixir to improve its developer experience, particularly around tooling and compile times. I am not alone in this assessment — <a href="https://boredhacking.com/areas-of-improvement-for-elixir/">James Russo from Brex</a> documented similar pain points after running Elixir at scale there.</p>
<p>Would I choose Elixir again? It depends entirely on what you’re building. Need true concurrency and fault tolerance for a distributed system? Absolutely. Building a full-stack application where developer velocity is paramount? I would carefully evaluate other options first.</p>
<p>The key lesson after three years is actually an old lesson: use the right tool for the job. Elixir excels at certain challenges — distributed systems, real-time features, fault tolerance. Force it into the wrong context, and you will fight it the entire way.</p>
<p>Most of the pain points I encountered are technical problems with technical solutions. Better tooling, faster compilation, improved static analysis — these are solvable challenges. The Elixir community is talented and pragmatic. I hope they tackle these issues, because the core technology is genuinely impressive.</p>
<h2 id="the-future-the-ai-wild-card">The Future: The AI Wild Card<a aria-hidden="true" class="anchor-heading icon-link" href="#the-future-the-ai-wild-card"></a></h2>
<p>The biggest unknown is how AI will reshape the landscape. I see two competing possibilities — both entirely plausible yet leading to radically different outcomes:</p>
<ol>
<li><strong>AI accelerates Elixir’s evolution.</strong> LLMs could help the smaller Elixir community punch above its weight — addressing tooling gaps faster, improving documentation, and letting the language’s strengths shine through.</li>
<li><strong>AI drives consolidation around TypeScript.</strong> Every new project becomes full-stack Next.js. Old projects get rewritten. The AI hive mind converges on “best practices” and every LLM regurgitates the same stack recommendation. Alternative approaches get buried under the weight of generated sameness.</li>
</ol>
<p>My bet? The language with the best feedback loop to LLMs wins. TypeScript has a huge advantage here. Static types give LLMs clear signals about correctness. At our startup, we reached a point where TypeScript eliminated virtually all runtime type errors — no null pointer exceptions, no frontend crashes from type mismatches. I have only heard similar stories from niche functional languages like Elm.</p>
<p>Ironically, functional programming should be perfect for LLMs. When there is no global mutable state, you need much less context to understand what code does. Elixir has this advantage. TypeScript does not.</p>
<p>One last thought: the alternatives are not standing still. TypeScript already has the superior tooling and instant feedback loops. New tools like <a href="https://devblogs.microsoft.com/typescript/typescript-native-port/">tsgo</a> promise 10x faster performance (we’ve seen 5x improvements in our codebase). Meanwhile, TypeScript keeps adding features that chip away at functional programming’s advantages — better immutability support, stricter null checking, even pattern matching proposals.</p>
<p>Elixir’s window to catch up might be closing. The race is on.</p>
<hr>
<p>Elixir와 BEAM의 핵심 강점(동시성, 장애 내성)은 실제로 훌륭하게 작동했으나, 코드베이스(약 30만 줄)가 성장함에 따라 개발자 경험(DX)과 생태계의 단점이 두드러졌다. MVP 1년 + 전체 3년 운영 경험을 바탕으로 한 장단점 정리.</p>
<h2 id="장점-the-good-parts">장점 (The Good Parts)<a aria-hidden="true" class="anchor-heading icon-link" href="#장점-the-good-parts"></a></h2>
<ul>
<li><strong>BEAM의 기본 기능</strong>: 동시성, 장애 내성, "just works" 수준의 안정성. 생산 환경에서 신뢰할 수 있음.</li>
<li><strong>라이브러리와 도구</strong>: Ecto(데이터베이스), Oban(작업 큐) 같은 도구가 세계적 수준. 원격 <code>iex</code>는 프로덕션 디버깅의 생명줄.</li>
<li><strong>인재 풀</strong>: Elixir 엔지니어의 질이 뛰어나 채용에서 큰 이점.</li>
</ul>
<h2 id="단점-where-we-struggled">단점 (Where We Struggled)<a aria-hidden="true" class="anchor-heading icon-link" href="#단점-where-we-struggled"></a></h2>
<ul>
<li><strong>개발자 경험 (DX)</strong>: 가장 큰 병목. 대규모 코드베이스에서 한 줄 변경 시 컴파일 시간이 10~15초 이상 소요되어 흐름이 끊김. Vite/TypeScript 같은 즉각 피드백과 비교해 느림.</li>
<li><strong>도구링</strong>: ElixirLS의 자동 완성(autocomplete)이 불안정해 대형 코드베이스에서 함수명이나 스키마 필드를 grep으로 검색해야 함. 테스트/재컴파일 사이클이 모멘텀을 죽임.</li>
<li><strong>생태계 (Ecosystem)</strong>: 깊이는 있지만 폭이 좁음. Phoenix, Ecto, Oban은 훌륭하나, Shopify 라이브러리 같은 사소한 기능도 직접 구현해야 함. 다른 생태계에서 쉬운 일이 벽에 부딪힘.</li>
<li><strong>풀스택 문제 (Full-Stack)</strong>: 복잡한 UI(클라이언트 측 상호작용 많음)에서 LiveView가 적합하지 않아 React 프론트엔드를 도입. 결과적으로 GraphQL 오버헤드와 컨텍스트 스위칭으로 풀스택 JS 프레임워크보다 복잡해짐.</li>
<li><strong>배포 및 DevOps</strong>: 클러스터링으로 인해 단순 컨테이너(Cloud Run) 대신 복잡한 VM 관리(NixOS) 필요. fly.io에서 Postgres 불안정성으로 마이그레이션. (참고: 현대 Elixir 도구에서 핫 코드 업그레이드 지원이 실질적으로 약함.)</li>
<li><strong>개선 영역</strong>: <a href="https://boredhacking.com/areas-of-improvement-for-elixir/">이 포스트</a>에서 지적된 DX, 도구링, 생태계 문제와 유사한 고통 경험.</li>
</ul>
<h2 id="결론">결론<a aria-hidden="true" class="anchor-heading icon-link" href="#결론"></a></h2>
<p>Elixir는 특정 문제(예: 고동시성 백엔드)에 최적화된 킬러 도구지만, 풀스택 앱처럼 복잡한 경우 장점이 일방적이지 않음. 이 trade-off는 생태계 성숙도 문제로 보이는데, 다른 팀들은 어떻게 극복하나? 근본적 문제 vs. 우선순위 개선으로 보는가?</p>
<blockquote>
<ul>
<li><a href="https://news.ycombinator.com/item?id=44495879">https://news.ycombinator.com/item?id=44495879</a></li>
<li><a href="https://news.ycombinator.com/item?id=45613852">https://news.ycombinator.com/item?id=45613852</a></li>
</ul>
</blockquote></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-beam-living-up-to-the-hype" title="The BEAM: Living Up to the Hype">The BEAM: Living Up to the Hype</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-ecosystem-depth-over-breadth" title="The Ecosystem: Depth Over Breadth">The Ecosystem: Depth Over Breadth</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#phoenix-the-double-edged-sword" title="Phoenix: The Double-Edged Sword">Phoenix: The Double-Edged Sword</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#developer-experience-the-achilles-heel" title="Developer Experience: The Achilles’ Heel">Developer Experience: The Achilles’ Heel</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-unexpected-wins" title="The Unexpected Wins">The Unexpected Wins</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#deployment-more-complex-than-expected" title="Deployment: More Complex Than Expected">Deployment: More Complex Than Expected</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-verdict" title="The Verdict">The Verdict</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-future-the-ai-wild-card" title="The Future: The AI Wild Card">The Future: The AI Wild Card</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#장점-the-good-parts" title="장점 (The Good Parts)">장점 (The Good Parts)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#단점-where-we-struggled" title="단점 (Where We Struggled)">단점 (Where We Struggled)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#결론" title="결론">결론</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"pck31wdeftzv84so8l31a9t","title":"Building with Elixir for Three Years: A Production Retrospective","desc":"","updated":1760916761012,"created":1760916400012,"custom":{},"fname":"dev.program-languages.elixir-three-years-production","type":"note","vault":{"fsPath":"vault"},"contentHash":"0711a23bf68e340c7a7b3876f6cd08b8","links":[],"anchors":{"the-beam-living-up-to-the-hype":{"type":"header","text":"The BEAM: Living Up to the Hype","value":"the-beam-living-up-to-the-hype","line":27,"column":0,"depth":2},"the-ecosystem-depth-over-breadth":{"type":"header","text":"The Ecosystem: Depth Over Breadth","value":"the-ecosystem-depth-over-breadth","line":31,"column":0,"depth":2},"phoenix-the-double-edged-sword":{"type":"header","text":"Phoenix: The Double-Edged Sword","value":"phoenix-the-double-edged-sword","line":41,"column":0,"depth":2},"developer-experience-the-achilles-heel":{"type":"header","text":"Developer Experience: The Achilles’ Heel","value":"developer-experience-the-achilles-heel","line":47,"column":0,"depth":2},"the-unexpected-wins":{"type":"header","text":"The Unexpected Wins","value":"the-unexpected-wins","line":55,"column":0,"depth":2},"deployment-more-complex-than-expected":{"type":"header","text":"Deployment: More Complex Than Expected","value":"deployment-more-complex-than-expected","line":65,"column":0,"depth":2},"the-verdict":{"type":"header","text":"The Verdict","value":"the-verdict","line":71,"column":0,"depth":2},"the-future-the-ai-wild-card":{"type":"header","text":"The Future: The AI Wild Card","value":"the-future-the-ai-wild-card","line":83,"column":0,"depth":2},"장점-the-good-parts":{"type":"header","text":"장점 (The Good Parts)","value":"장점-the-good-parts","line":102,"column":0,"depth":2},"단점-where-we-struggled":{"type":"header","text":"단점 (Where We Struggled)","value":"단점-where-we-struggled","line":108,"column":0,"depth":2},"결론":{"type":"header","text":"결론","value":"결론","line":117,"column":0,"depth":2}},"children":[],"parent":"cnzc1i8ojequt9lhg3zpkgo","data":{}},"body":"\u003ch1 id=\"building-with-elixir-for-three-years-a-production-retrospective\"\u003eBuilding with Elixir for Three Years: A Production Retrospective\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#building-with-elixir-for-three-years-a-production-retrospective\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://ryanrasti.com/blog/elixir-three-years-production/\"\u003ehttps://ryanrasti.com/blog/elixir-three-years-production/\u003c/a\u003e - Jul 10, 2025\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eThe BEAM (Erlang VM) delivered on its promises of scalability, concurrency, and resilience, reducing the need for complex tooling and orchestration.\u003c/li\u003e\n\u003cli\u003eThe Elixir ecosystem has exceptional depth in core areas but lacks breadth, with gaps in libraries for tasks outside the core ecosystem.\u003c/li\u003e\n\u003cli\u003ePhoenix and LiveView aimed to eliminate frontend/backend split pain but did not meet the complex UI/UX needs of the warehouse management system.\u003c/li\u003e\n\u003cli\u003eDeveloper experience in Elixir fell short compared to TypeScript, with issues in autocomplete, compile times, and static analysis.\u003c/li\u003e\n\u003cli\u003eElixir attracted high-quality talent, with developers demonstrating deep technical knowledge and pragmatic problem-solving skills.\u003c/li\u003e\n\u003cli\u003eOban proved to be a reliable tool for background jobs, and remote IEx was invaluable for debugging production issues during the MVP launch.\u003c/li\u003e\n\u003cli\u003eDeployment of Elixir applications presented unexpected challenges, leading to the use of NixOS for VM management.\u003c/li\u003e\n\u003cli\u003eElixir is best suited for specific problems like distributed systems and real-time features, but may not be ideal for full-stack applications where developer velocity is crucial.\u003c/li\u003e\n\u003cli\u003eThe future of Elixir may be influenced by AI, with potential for accelerated evolution or consolidation around TypeScript.\u003c/li\u003e\n\u003cli\u003eTypeScript's superior tooling, instant feedback loops, and static types give it an advantage in the AI-driven development landscape.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003eI recently responded to a \u003ca href=\"https://news.ycombinator.com/item?id=44495879\"\u003eHacker News thread\u003c/a\u003e about Elixir’s benefits. As CTO of a startup that built with Elixir for two years before deploying to production in our third, I wanted to share our actual experience versus the marketing promises.\u003c/p\u003e\n\u003cp\u003eWe built a warehouse management system from scratch — complete with multi-warehouse inventory tracking, order routing, pick/pack workflows, and dozens of e-commerce integrations. We successfully went live with our MVP and first customers, and have since fulfilled over 100,000 orders. Here’s what worked, what didn’t, and what I’d do differently.\u003c/p\u003e\n\u003ch2 id=\"the-beam-living-up-to-the-hype\"\u003eThe BEAM: Living Up to the Hype\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-beam-living-up-to-the-hype\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe Erlang VM delivered on its core promise. Scalability, concurrency, and resilience “just worked.” No orchestration needed, no complex tooling, no surprises. You avoid the typical distributed systems mess — no gluing together Redis for queues, Kubernetes for orchestration, and a dozen other tools. Everything you need comes built-in. When you are running a lean team, this reduced surface area means you can iterate faster with fewer things that can break.\u003c/p\u003e\n\u003ch2 id=\"the-ecosystem-depth-over-breadth\"\u003eThe Ecosystem: Depth Over Breadth\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-ecosystem-depth-over-breadth\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe ecosystem is hit or miss. I would characterize it as having exceptional depth where it matters but frustrating gaps elsewhere.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://phoenixframework.org/\"\u003ePhoenix\u003c/a\u003e and \u003ca href=\"https://hexdocs.pm/oban/Oban.html\"\u003eOban\u003c/a\u003e were fantastic — world-class libraries that did exactly what we needed.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://hexdocs.pm/ecto/Ecto.html\"\u003eEcto\u003c/a\u003e deserves special mention. This query builder opened my eyes to what is possible beyond raw SQL. It saved us countless times with its ability to dynamically compose queries — in that sense, it is even more powerful than raw SQL. The biggest drawback? Most extensions require writing macros, which are hard to grasp when you are picking up Elixir for the first time.\u003c/p\u003e\n\u003cp\u003eStep outside that golden path and you will hit walls fast. No good libraries for parsing shell commands. Shopify integration libraries were either missing or unmaintained. When you venture beyond the core ecosystem, be ready to build it yourself.\u003c/p\u003e\n\u003ch2 id=\"phoenix-the-double-edged-sword\"\u003ePhoenix: The Double-Edged Sword\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#phoenix-the-double-edged-sword\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003ePhoenix and \u003ca href=\"https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html\"\u003eLiveView\u003c/a\u003e promise to eliminate the split frontend/backend pain that plagues so many teams. No more maintaining separate frontends. No more coordinating across teams. No more API versioning headaches. For rapid iteration, this sounds transformative.\u003c/p\u003e\n\u003cp\u003eWe started with React from day one. LiveView could handle simple interactions beautifully, but we knew it could not deliver the complex UI/UX flows our warehouse management system demanded. We ended up with the exact split-stack complexity Phoenix aims to solve. Looking back, a full-stack Node.js framework would have simplified our client/server interaction considerably.\u003c/p\u003e\n\u003ch2 id=\"developer-experience-the-achilles-heel\"\u003eDeveloper Experience: The Achilles’ Heel\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#developer-experience-the-achilles-heel\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eI love functional programming, and Elixir’s standard library is thoughtfully designed. The developer experience fell short compared to TypeScript in ways that compound over time.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAutocomplete was a coin flip.\u003c/strong\u003e Half the time \u003ca href=\"https://github.com/elixir-lsp/elixir-ls\"\u003eElixirLS\u003c/a\u003e simply did not work — either too slow or completely broken. When it did work, the static analysis was not sophisticated enough to provide genuinely useful suggestions. In a 300K line codebase, you need autocomplete just to remember function names and schema attributes. Without it, you are constantly grepping through files.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCompile times broke my flow.\u003c/strong\u003e Our 300K line codebase took 10 seconds to recompile after a one-line change, plus a few more seconds for tests. We used GraphQL to get typing between backend and frontend — crucial for type safety and developer experience, but it came at a steep cost. After several hundred thousand lines of code, the full cycle became painful: recompile Elixir, then regenerate types — easily 20 seconds on beefy hardware for a single-line change. VS Code often choked on the huge type definition changes, requiring a full restart to make IntelliSense happy again. Compare that to the instant feedback loop of \u003ca href=\"https://vitejs.dev/\"\u003eVite\u003c/a\u003e. Those 20-second turnarounds might sound trivial, but they shatter concentration and compound into hours of lost productivity.\u003c/p\u003e\n\u003ch2 id=\"the-unexpected-wins\"\u003eThe Unexpected Wins\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-unexpected-wins\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eDespite the challenges, Elixir delivered some surprising victories.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTalent quality was exceptional.\u003c/strong\u003e Every Elixir developer we interviewed demonstrated deep technical knowledge and pragmatic problem-solving skills. The community self-selects for engineers who choose tools for sound technical reasons, not resume padding or trend chasing. Elixir also made our roles more appealing — talented engineers were excited to work with the language, giving us an edge in recruiting.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eOban saved us repeatedly.\u003c/strong\u003e We leaned on it heavily for background jobs, and I honestly cannot imagine building our system without it. Rock solid.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRemote IEx got us through MVP.\u003c/strong\u003e Being able to debug production issues in real-time via remote console access was absolutely clutch for our launch. Not something you would want to rely on forever, but invaluable when you need it.\u003c/p\u003e\n\u003ch2 id=\"deployment-more-complex-than-expected\"\u003eDeployment: More Complex Than Expected\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#deployment-more-complex-than-expected\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eElixir’s distributed nature, while powerful, created unexpected deployment challenges. We started on Fly.io but their repeated instability and lack of managed Postgres forced us to look elsewhere. Cloud Run seemed perfect until we discovered it did not support the peer-to-peer ports Elixir needed for clustering.\u003c/p\u003e\n\u003cp\u003eWe ended up running virtual machines with \u003ca href=\"https://nixos.org/\"\u003eNixOS\u003c/a\u003e to manage the overhead. The alternative was Kubernetes, but even managed Kubernetes felt like overkill for our needs. NixOS made VM management tolerable, but it was still more operational complexity than we had budgeted for.\u003c/p\u003e\n\u003ch2 id=\"the-verdict\"\u003eThe Verdict\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-verdict\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eElixir shines as the right tool for specific problems. For us building a full-stack application, the experience was decidedly mixed.\u003c/p\u003e\n\u003cp\u003ePart of this challenge is structural — JavaScript owns the frontend, giving JavaScript frameworks an inherent full-stack advantage that is hard to overcome. There is also significant room for Elixir to improve its developer experience, particularly around tooling and compile times. I am not alone in this assessment — \u003ca href=\"https://boredhacking.com/areas-of-improvement-for-elixir/\"\u003eJames Russo from Brex\u003c/a\u003e documented similar pain points after running Elixir at scale there.\u003c/p\u003e\n\u003cp\u003eWould I choose Elixir again? It depends entirely on what you’re building. Need true concurrency and fault tolerance for a distributed system? Absolutely. Building a full-stack application where developer velocity is paramount? I would carefully evaluate other options first.\u003c/p\u003e\n\u003cp\u003eThe key lesson after three years is actually an old lesson: use the right tool for the job. Elixir excels at certain challenges — distributed systems, real-time features, fault tolerance. Force it into the wrong context, and you will fight it the entire way.\u003c/p\u003e\n\u003cp\u003eMost of the pain points I encountered are technical problems with technical solutions. Better tooling, faster compilation, improved static analysis — these are solvable challenges. The Elixir community is talented and pragmatic. I hope they tackle these issues, because the core technology is genuinely impressive.\u003c/p\u003e\n\u003ch2 id=\"the-future-the-ai-wild-card\"\u003eThe Future: The AI Wild Card\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-future-the-ai-wild-card\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe biggest unknown is how AI will reshape the landscape. I see two competing possibilities — both entirely plausible yet leading to radically different outcomes:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eAI accelerates Elixir’s evolution.\u003c/strong\u003e LLMs could help the smaller Elixir community punch above its weight — addressing tooling gaps faster, improving documentation, and letting the language’s strengths shine through.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAI drives consolidation around TypeScript.\u003c/strong\u003e Every new project becomes full-stack Next.js. Old projects get rewritten. The AI hive mind converges on “best practices” and every LLM regurgitates the same stack recommendation. Alternative approaches get buried under the weight of generated sameness.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eMy bet? The language with the best feedback loop to LLMs wins. TypeScript has a huge advantage here. Static types give LLMs clear signals about correctness. At our startup, we reached a point where TypeScript eliminated virtually all runtime type errors — no null pointer exceptions, no frontend crashes from type mismatches. I have only heard similar stories from niche functional languages like Elm.\u003c/p\u003e\n\u003cp\u003eIronically, functional programming should be perfect for LLMs. When there is no global mutable state, you need much less context to understand what code does. Elixir has this advantage. TypeScript does not.\u003c/p\u003e\n\u003cp\u003eOne last thought: the alternatives are not standing still. TypeScript already has the superior tooling and instant feedback loops. New tools like \u003ca href=\"https://devblogs.microsoft.com/typescript/typescript-native-port/\"\u003etsgo\u003c/a\u003e promise 10x faster performance (we’ve seen 5x improvements in our codebase). Meanwhile, TypeScript keeps adding features that chip away at functional programming’s advantages — better immutability support, stricter null checking, even pattern matching proposals.\u003c/p\u003e\n\u003cp\u003eElixir’s window to catch up might be closing. The race is on.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eElixir와 BEAM의 핵심 강점(동시성, 장애 내성)은 실제로 훌륭하게 작동했으나, 코드베이스(약 30만 줄)가 성장함에 따라 개발자 경험(DX)과 생태계의 단점이 두드러졌다. MVP 1년 + 전체 3년 운영 경험을 바탕으로 한 장단점 정리.\u003c/p\u003e\n\u003ch2 id=\"장점-the-good-parts\"\u003e장점 (The Good Parts)\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#장점-the-good-parts\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eBEAM의 기본 기능\u003c/strong\u003e: 동시성, 장애 내성, \"just works\" 수준의 안정성. 생산 환경에서 신뢰할 수 있음.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e라이브러리와 도구\u003c/strong\u003e: Ecto(데이터베이스), Oban(작업 큐) 같은 도구가 세계적 수준. 원격 \u003ccode\u003eiex\u003c/code\u003e는 프로덕션 디버깅의 생명줄.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e인재 풀\u003c/strong\u003e: Elixir 엔지니어의 질이 뛰어나 채용에서 큰 이점.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"단점-where-we-struggled\"\u003e단점 (Where We Struggled)\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#단점-where-we-struggled\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e개발자 경험 (DX)\u003c/strong\u003e: 가장 큰 병목. 대규모 코드베이스에서 한 줄 변경 시 컴파일 시간이 10~15초 이상 소요되어 흐름이 끊김. Vite/TypeScript 같은 즉각 피드백과 비교해 느림.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e도구링\u003c/strong\u003e: ElixirLS의 자동 완성(autocomplete)이 불안정해 대형 코드베이스에서 함수명이나 스키마 필드를 grep으로 검색해야 함. 테스트/재컴파일 사이클이 모멘텀을 죽임.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e생태계 (Ecosystem)\u003c/strong\u003e: 깊이는 있지만 폭이 좁음. Phoenix, Ecto, Oban은 훌륭하나, Shopify 라이브러리 같은 사소한 기능도 직접 구현해야 함. 다른 생태계에서 쉬운 일이 벽에 부딪힘.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e풀스택 문제 (Full-Stack)\u003c/strong\u003e: 복잡한 UI(클라이언트 측 상호작용 많음)에서 LiveView가 적합하지 않아 React 프론트엔드를 도입. 결과적으로 GraphQL 오버헤드와 컨텍스트 스위칭으로 풀스택 JS 프레임워크보다 복잡해짐.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e배포 및 DevOps\u003c/strong\u003e: 클러스터링으로 인해 단순 컨테이너(Cloud Run) 대신 복잡한 VM 관리(NixOS) 필요. fly.io에서 Postgres 불안정성으로 마이그레이션. (참고: 현대 Elixir 도구에서 핫 코드 업그레이드 지원이 실질적으로 약함.)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e개선 영역\u003c/strong\u003e: \u003ca href=\"https://boredhacking.com/areas-of-improvement-for-elixir/\"\u003e이 포스트\u003c/a\u003e에서 지적된 DX, 도구링, 생태계 문제와 유사한 고통 경험.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"결론\"\u003e결론\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#결론\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eElixir는 특정 문제(예: 고동시성 백엔드)에 최적화된 킬러 도구지만, 풀스택 앱처럼 복잡한 경우 장점이 일방적이지 않음. 이 trade-off는 생태계 성숙도 문제로 보이는데, 다른 팀들은 어떻게 극복하나? 근본적 문제 vs. 우선순위 개선으로 보는가?\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://news.ycombinator.com/item?id=44495879\"\u003ehttps://news.ycombinator.com/item?id=44495879\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://news.ycombinator.com/item?id=45613852\"\u003ehttps://news.ycombinator.com/item?id=45613852\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"pck31wdeftzv84so8l31a9t"},"buildId":"vOE8u-mg___OsOsz4tjEg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>