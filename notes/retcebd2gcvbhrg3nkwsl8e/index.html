<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>The Rise of Worse is Better</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="The Rise of Worse is Better"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/retcebd2gcvbhrg3nkwsl8e/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="10/8/2024"/><meta property="article:modified_time" content="10/8/2024"/><link rel="canonical" href="https://luke-snaw.github.io//notes/retcebd2gcvbhrg3nkwsl8e/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_buildManifest.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="the-rise-of-worse-is-better">The Rise of Worse is Better<a aria-hidden="true" class="anchor-heading icon-link" href="#the-rise-of-worse-is-better"></a></h1>
<blockquote>
<p>Richard P. Gabriel</p>
<p>Lucid, Inc</p>
<p><a href="https://www.dreamsongs.com/RiseOfWorseIsBetter.html">https://www.dreamsongs.com/RiseOfWorseIsBetter.html</a></p>
</blockquote>
<hr>
<p>This article discusses two contrasting design philosophies in programming: the MIT approach, which emphasizes achieving the "right thing" with complex, ideal solutions, and the New Jersey approach, characterized by simplicity and practicality. The author argues that while the MIT philosophy leads to well-designed systems like Common Lisp and Scheme, the New Jersey approach, exemplified by early Unix and C, offers better survival characteristics in software development. A key example illustrates a discussion between an MIT and a New Jersey programmer about handling system routine errors, highlighting the New Jersey approach's focus on simplicity over complexity.</p>
<p>The author posits that the worse-is-better philosophy prioritizes implementation simplicity, making systems easier to port and use on a variety of machines, thus allowing for widespread adoption. This philosophy conditions programmers to accept some trade-offs in safety and convenience for enhanced performance. The article suggests that while Lisp compilers were competitive with C compilers, the latter gained more traction due to their practicality.</p>
<p>The author concludes that the quest for the "right thing" often results in overly complex systems that take a long time to develop and may only run on advanced hardware. Instead, a more effective strategy is to release a simpler, albeit imperfect solution first, allowing it to gain popularity before iterating towards improvement. Ultimately, the article calls for a reevaluation of the Lisp community's design approach.</p>
<ul>
<li><strong>Design Philosophies</strong>: The document contrasts two design philosophies: the "MIT approach," which emphasizes achieving the ideal solution, and the "New Jersey approach," which prioritizes simplicity and practicality.</li>
<li><strong>Worse-is-Better</strong>: The "worse-is-better" philosophy asserts that simpler, less perfect designs can be more successful and widely adopted than more complex, ideal solutions.</li>
<li><strong>Survival of Designs</strong>: Despite its flaws, the worse-is-better philosophy tends to have better survival characteristics in software development compared to the idealistic MIT approach.</li>
<li><strong>Real-World Examples</strong>: Early Unix and C exemplify the New Jersey approach, demonstrating how simplicity in design can lead to widespread adoption and functionality across various hardware.</li>
<li><strong>Portability</strong>: The simplicity of Unix and C allows them to be easily ported to less powerful machines, making them more versatile and widely used.</li>
<li><strong>User Conditioning</strong>: Users of worse-is-better systems become accustomed to accepting less-than-ideal functionality, which can facilitate the spread of such systems.</li>
<li><strong>Incremental Improvement</strong>: Once a simpler system gains traction, there is potential for gradual improvement towards a more complete solution without overwhelming complexity.</li>
<li><strong>Complexity of Ideal Solutions</strong>: The document highlights that pursuing the ideal solution can lead to prolonged development times and complexity, often resulting in software that is difficult to implement and run.</li>
<li><strong>Integration Tradition</strong>: The New Jersey approach fosters a culture of component reuse, leading to better integration in software systems.</li>
<li><strong>Rethinking Lisp Design</strong>: The author suggests that the Lisp community should reconsider its design philosophy in light of the success of simpler, more pragmatic systems like C and Unix.</li>
</ul>
<hr>
<p>{an excerpt from "Lisp: Good News, Bad News, How to Win Big." <a href="https://www.dreamsongs.com/WIB.html">html</a>}</p>
<h2 id="21-the-rise-of-worse-is-better">2.1 The Rise of <em>Worse is Better</em><a aria-hidden="true" class="anchor-heading icon-link" href="#21-the-rise-of-worse-is-better"></a></h2>
<p>I and just about every designer of Common Lisp and CLOS has had extreme exposure to the MIT/Stanford style of design. The essence of this style can be captured by the phrase <em>the right thing</em>. To such a designer it is important to get all of the following characteristics right:</p>
<ul>
<li>Simplicity -- the design must be simple, both in implementation and interface. It is more important for the interface to be simple than the implementation.</li>
<li>Correctness -- the design must be correct in all observable aspects. Incorrectness is simply not allowed.</li>
<li>Consistency -- the design must not be inconsistent. A design is allowed to be slightly less simple and less complete to avoid inconsistency. Consistency is as important as correctness.</li>
<li>Completeness -- the design must cover as many important situations as is practical. All reasonably expected cases must be covered. Simplicity is not allowed to overly reduce completeness.</li>
</ul>
<p>I believe most people would agree that these are good characteristics. I will call the use of this philosophy of design the <em>MIT approach</em>. Common Lisp (with CLOS) and Scheme represent the MIT approach to design and implementation.</p>
<p>The worse-is-better philosophy is only slightly different:</p>
<ul>
<li>Simplicity -- the design must be simple, both in implementation and interface. It is more important for the implementation to be simple than the interface. Simplicity is the most important consideration in a design.</li>
<li>Correctness -- the design must be correct in all observable aspects. It is slightly better to be simple than correct.</li>
<li>Consistency -- the design must not be overly inconsistent. Consistency can be sacrificed for simplicity in some cases, but it is better to drop those parts of the design that deal with less common circumstances than to introduce either implementational complexity or inconsistency.</li>
<li>Completeness -- the design must cover as many important situations as is practical. All reasonably expected cases should be covered. Completeness can be sacrificed in favor of any other quality. In fact, completeness must be sacrificed whenever implementation simplicity is jeopardized. Consistency can be sacrificed to achieve completeness if simplicity is retained; especially worthless is consistency of interface.</li>
</ul>
<p>Early Unix and C are examples of the use of this school of design, and I will call the use of this design strategy the <em>New Jersey approach</em>. I have intentionally caricatured the worse-is-better philosophy to convince you that it is obviously a bad philosophy and that the New Jersey approach is a bad approach.</p>
<p>However, I believe that worse-is-better, even in its strawman form, has better survival characteristics than the-right-thing, and that the New Jersey approach when used for software is a better approach than the MIT approach.</p>
<p>Let me start out by retelling a story that shows that the MIT/New-Jersey distinction is valid and that proponents of each philosophy actually believe their philosophy is better.</p>
<p>Two famous people, one from MIT and another from Berkeley (but working on Unix) once met to discuss operating system issues. The person from MIT was knowledgeable about ITS (the MIT AI Lab operating system) and had been reading the Unix sources. He was interested in how Unix solved the PC loser-ing problem. The PC loser-ing problem occurs when a user program invokes a system routine to perform a lengthy operation that might have significant state, such as IO buffers. If an interrupt occurs during the operation, the state of the user program must be saved. Because the invocation of the system routine is usually a single instruction, the PC of the user program does not adequately capture the state of the process. The system routine must either back out or press forward. The right thing is to back out and restore the user program PC to the instruction that invoked the system routine so that resumption of the user program after the interrupt, for example, re-enters the system routine. It is called <em>PC loser-ing</em> because the PC is being coerced into <em>loser mode</em>, where <em>loser</em> is the affectionate name for <em>user</em> at MIT.</p>
<p>The MIT guy did not see any code that handled this case and asked the New Jersey guy how the problem was handled. The New Jersey guy said that the Unix folks were aware of the problem, but the solution was for the system routine to always finish, but sometimes an error code would be returned that signaled that the system routine had failed to complete its action. A correct user program, then, had to check the error code to determine whether to simply try the system routine again. The MIT guy did not like this solution because it was not the right thing.</p>
<p>The New Jersey guy said that the Unix solution was right because the design philosophy of Unix was simplicity and that the right thing was too complex. Besides, programmers could easily insert this extra test and loop. The MIT guy pointed out that the implementation was simple but the interface to the functionality was complex. The New Jersey guy said that the right tradeoff has been selected in Unix -- namely, implementation simplicity was more important than interface simplicity.</p>
<p>The MIT guy then muttered that sometimes it takes a tough man to make a tender chicken, but the New Jersey guy didn’t understand (I’m not sure I do either).</p>
<p>Now I want to argue that worse-is-better is better. C is a programming language designed for writing Unix, and it was designed using the New Jersey approach. C is therefore a language for which it is easy to write a decent compiler, and it requires the programmer to write text that is easy for the compiler to interpret. Some have called C a fancy assembly language. Both early Unix and C compilers had simple structures, are easy to port, require few machine resources to run, and provide about 50%-80% of what you want from an operating system and programming language.</p>
<p>Half the computers that exist at any point are worse than median (smaller or slower). Unix and C work fine on them. The worse-is-better philosophy means that implementation simplicity has highest priority, which means Unix and C are easy to port on such machines. Therefore, one expects that if the 50% functionality Unix and C support is satisfactory, they will start to appear everywhere. And they have, haven’t they?</p>
<p>Unix and C are the ultimate computer viruses.</p>
<p>A further benefit of the worse-is-better philosophy is that the programmer is conditioned to sacrifice some safety, convenience, and hassle to get good performance and modest resource use. Programs written using the New Jersey approach will work well both in small machines and large ones, and the code will be portable because it is written on top of a virus.</p>
<p>It is important to remember that the initial virus has to be basically good. If so, the viral spread is assured as long as it is portable. Once the virus has spread, there will be pressure to improve it, possibly by increasing its functionality closer to 90%, but users have already been conditioned to accept worse than the right thing. Therefore, the worse-is-better software first will gain acceptance, second will condition its users to expect less, and third will be improved to a point that is almost the right thing. In concrete terms, even though Lisp compilers in 1987 were about as good as C compilers, there are many more compiler experts who want to make C compilers better than want to make Lisp compilers better.</p>
<p>The good news is that in 1995 we will have a good operating system and programming language; the bad news is that they will be Unix and C++.</p>
<p>There is a final benefit to worse-is-better. Because a New Jersey language and system are not really powerful enough to build complex monolithic software, large systems must be designed to reuse components. Therefore, a tradition of integration springs up.</p>
<p>How does the right thing stack up? There are two basic scenarios: the <em>big complex system scenario</em> and the <em>diamond-like jewel</em> scenario.</p>
<p>The <em>big complex system</em> scenario goes like this:</p>
<p>First, the right thing needs to be designed. Then its implementation needs to be designed. Finally it is implemented. Because it is the right thing, it has nearly 100% of desired functionality, and implementation simplicity was never a concern so it takes a long time to implement. It is large and complex. It requires complex tools to use properly. The last 20% takes 80% of the effort, and so the right thing takes a long time to get out, and it only runs satisfactorily on the most sophisticated hardware.</p>
<p>The <em>diamond-like jewel</em> scenario goes like this:</p>
<p>The right thing takes forever to design, but it is quite small at every point along the way. To implement it to run fast is either impossible or beyond the capabilities of most implementors.</p>
<p>The two scenarios correspond to Common Lisp and Scheme.</p>
<p>The first scenario is also the scenario for classic artificial intelligence software.</p>
<p>The right thing is frequently a monolithic piece of software, but for no reason other than that the right thing is often designed monolithically. That is, this characteristic is a happenstance.</p>
<p>The lesson to be learned from this is that it is often undesirable to go for the right thing first. It is better to get half of the right thing available so that it spreads like a virus. Once people are hooked on it, take the time to improve it to 90% of the right thing.</p>
<p>A wrong lesson is to take the parable literally and to conclude that C is the right vehicle for AI software. The 50% solution has to be basically right, and in this case it isn’t.</p>
<p>But, one can conclude only that the Lisp community needs to seriously rethink its position on Lisp design. I will say more about this later.</p>
<hr>
<h2 id="hn">HN<a aria-hidden="true" class="anchor-heading icon-link" href="#hn"></a></h2>
<h3 id="d0mine"><a href="https://news.ycombinator.com/item?id=41770603">d0mine</a><a aria-hidden="true" class="anchor-heading icon-link" href="#d0mine"></a></h3>
<p>There is also "satisficing" (vs. maximizing).</p>
<p>Your model of the world is not perfect so instead of trying to find a globally optimal solution, you are satisfied with a local optimum that exceeds some threshold that has to suffices.</p>
<p><a href="https://en.wikipedia.org/wiki/Satisficing">https://en.wikipedia.org/wiki/Satisficing</a></p></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#21-the-rise-of-worse-is-better" title="2.1 The Rise of Worse is Better">2.1 The Rise of Worse is Better</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#hn" title="HN">HN</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#d0mine" title="d0mine">d0mine</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"retcebd2gcvbhrg3nkwsl8e","title":"The Rise of Worse is Better","desc":"","updated":1728370597958,"created":1728366350288,"custom":{},"fname":"dev.rise-of-worse-is-better","type":"note","vault":{"fsPath":"vault"},"contentHash":"33890db50538810a7e9a29d07f14bf8c","links":[],"anchors":{"21-the-rise-of-worse-is-better":{"type":"header","text":"2.1 The Rise of Worse is Better","value":"21-the-rise-of-worse-is-better","line":37,"column":0,"depth":2},"hn":{"type":"header","text":"HN","value":"hn","line":107,"column":0,"depth":2},"d0mine":{"type":"header","text":"d0mine","value":"d0mine","line":109,"column":0,"depth":3}},"children":[],"parent":"ZbdkdApFqLdks4Moq92R9","data":{}},"body":"\u003ch1 id=\"the-rise-of-worse-is-better\"\u003eThe Rise of Worse is Better\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-rise-of-worse-is-better\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRichard P. Gabriel\u003c/p\u003e\n\u003cp\u003eLucid, Inc\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.dreamsongs.com/RiseOfWorseIsBetter.html\"\u003ehttps://www.dreamsongs.com/RiseOfWorseIsBetter.html\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003eThis article discusses two contrasting design philosophies in programming: the MIT approach, which emphasizes achieving the \"right thing\" with complex, ideal solutions, and the New Jersey approach, characterized by simplicity and practicality. The author argues that while the MIT philosophy leads to well-designed systems like Common Lisp and Scheme, the New Jersey approach, exemplified by early Unix and C, offers better survival characteristics in software development. A key example illustrates a discussion between an MIT and a New Jersey programmer about handling system routine errors, highlighting the New Jersey approach's focus on simplicity over complexity.\u003c/p\u003e\n\u003cp\u003eThe author posits that the worse-is-better philosophy prioritizes implementation simplicity, making systems easier to port and use on a variety of machines, thus allowing for widespread adoption. This philosophy conditions programmers to accept some trade-offs in safety and convenience for enhanced performance. The article suggests that while Lisp compilers were competitive with C compilers, the latter gained more traction due to their practicality.\u003c/p\u003e\n\u003cp\u003eThe author concludes that the quest for the \"right thing\" often results in overly complex systems that take a long time to develop and may only run on advanced hardware. Instead, a more effective strategy is to release a simpler, albeit imperfect solution first, allowing it to gain popularity before iterating towards improvement. Ultimately, the article calls for a reevaluation of the Lisp community's design approach.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDesign Philosophies\u003c/strong\u003e: The document contrasts two design philosophies: the \"MIT approach,\" which emphasizes achieving the ideal solution, and the \"New Jersey approach,\" which prioritizes simplicity and practicality.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWorse-is-Better\u003c/strong\u003e: The \"worse-is-better\" philosophy asserts that simpler, less perfect designs can be more successful and widely adopted than more complex, ideal solutions.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSurvival of Designs\u003c/strong\u003e: Despite its flaws, the worse-is-better philosophy tends to have better survival characteristics in software development compared to the idealistic MIT approach.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eReal-World Examples\u003c/strong\u003e: Early Unix and C exemplify the New Jersey approach, demonstrating how simplicity in design can lead to widespread adoption and functionality across various hardware.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePortability\u003c/strong\u003e: The simplicity of Unix and C allows them to be easily ported to less powerful machines, making them more versatile and widely used.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUser Conditioning\u003c/strong\u003e: Users of worse-is-better systems become accustomed to accepting less-than-ideal functionality, which can facilitate the spread of such systems.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIncremental Improvement\u003c/strong\u003e: Once a simpler system gains traction, there is potential for gradual improvement towards a more complete solution without overwhelming complexity.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eComplexity of Ideal Solutions\u003c/strong\u003e: The document highlights that pursuing the ideal solution can lead to prolonged development times and complexity, often resulting in software that is difficult to implement and run.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIntegration Tradition\u003c/strong\u003e: The New Jersey approach fosters a culture of component reuse, leading to better integration in software systems.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRethinking Lisp Design\u003c/strong\u003e: The author suggests that the Lisp community should reconsider its design philosophy in light of the success of simpler, more pragmatic systems like C and Unix.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e{an excerpt from \"Lisp: Good News, Bad News, How to Win Big.\" \u003ca href=\"https://www.dreamsongs.com/WIB.html\"\u003ehtml\u003c/a\u003e}\u003c/p\u003e\n\u003ch2 id=\"21-the-rise-of-worse-is-better\"\u003e2.1 The Rise of \u003cem\u003eWorse is Better\u003c/em\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#21-the-rise-of-worse-is-better\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eI and just about every designer of Common Lisp and CLOS has had extreme exposure to the MIT/Stanford style of design. The essence of this style can be captured by the phrase \u003cem\u003ethe right thing\u003c/em\u003e. To such a designer it is important to get all of the following characteristics right:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSimplicity -- the design must be simple, both in implementation and interface. It is more important for the interface to be simple than the implementation.\u003c/li\u003e\n\u003cli\u003eCorrectness -- the design must be correct in all observable aspects. Incorrectness is simply not allowed.\u003c/li\u003e\n\u003cli\u003eConsistency -- the design must not be inconsistent. A design is allowed to be slightly less simple and less complete to avoid inconsistency. Consistency is as important as correctness.\u003c/li\u003e\n\u003cli\u003eCompleteness -- the design must cover as many important situations as is practical. All reasonably expected cases must be covered. Simplicity is not allowed to overly reduce completeness.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI believe most people would agree that these are good characteristics. I will call the use of this philosophy of design the \u003cem\u003eMIT approach\u003c/em\u003e. Common Lisp (with CLOS) and Scheme represent the MIT approach to design and implementation.\u003c/p\u003e\n\u003cp\u003eThe worse-is-better philosophy is only slightly different:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSimplicity -- the design must be simple, both in implementation and interface. It is more important for the implementation to be simple than the interface. Simplicity is the most important consideration in a design.\u003c/li\u003e\n\u003cli\u003eCorrectness -- the design must be correct in all observable aspects. It is slightly better to be simple than correct.\u003c/li\u003e\n\u003cli\u003eConsistency -- the design must not be overly inconsistent. Consistency can be sacrificed for simplicity in some cases, but it is better to drop those parts of the design that deal with less common circumstances than to introduce either implementational complexity or inconsistency.\u003c/li\u003e\n\u003cli\u003eCompleteness -- the design must cover as many important situations as is practical. All reasonably expected cases should be covered. Completeness can be sacrificed in favor of any other quality. In fact, completeness must be sacrificed whenever implementation simplicity is jeopardized. Consistency can be sacrificed to achieve completeness if simplicity is retained; especially worthless is consistency of interface.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEarly Unix and C are examples of the use of this school of design, and I will call the use of this design strategy the \u003cem\u003eNew Jersey approach\u003c/em\u003e. I have intentionally caricatured the worse-is-better philosophy to convince you that it is obviously a bad philosophy and that the New Jersey approach is a bad approach.\u003c/p\u003e\n\u003cp\u003eHowever, I believe that worse-is-better, even in its strawman form, has better survival characteristics than the-right-thing, and that the New Jersey approach when used for software is a better approach than the MIT approach.\u003c/p\u003e\n\u003cp\u003eLet me start out by retelling a story that shows that the MIT/New-Jersey distinction is valid and that proponents of each philosophy actually believe their philosophy is better.\u003c/p\u003e\n\u003cp\u003eTwo famous people, one from MIT and another from Berkeley (but working on Unix) once met to discuss operating system issues. The person from MIT was knowledgeable about ITS (the MIT AI Lab operating system) and had been reading the Unix sources. He was interested in how Unix solved the PC loser-ing problem. The PC loser-ing problem occurs when a user program invokes a system routine to perform a lengthy operation that might have significant state, such as IO buffers. If an interrupt occurs during the operation, the state of the user program must be saved. Because the invocation of the system routine is usually a single instruction, the PC of the user program does not adequately capture the state of the process. The system routine must either back out or press forward. The right thing is to back out and restore the user program PC to the instruction that invoked the system routine so that resumption of the user program after the interrupt, for example, re-enters the system routine. It is called \u003cem\u003ePC loser-ing\u003c/em\u003e because the PC is being coerced into \u003cem\u003eloser mode\u003c/em\u003e, where \u003cem\u003eloser\u003c/em\u003e is the affectionate name for \u003cem\u003euser\u003c/em\u003e at MIT.\u003c/p\u003e\n\u003cp\u003eThe MIT guy did not see any code that handled this case and asked the New Jersey guy how the problem was handled. The New Jersey guy said that the Unix folks were aware of the problem, but the solution was for the system routine to always finish, but sometimes an error code would be returned that signaled that the system routine had failed to complete its action. A correct user program, then, had to check the error code to determine whether to simply try the system routine again. The MIT guy did not like this solution because it was not the right thing.\u003c/p\u003e\n\u003cp\u003eThe New Jersey guy said that the Unix solution was right because the design philosophy of Unix was simplicity and that the right thing was too complex. Besides, programmers could easily insert this extra test and loop. The MIT guy pointed out that the implementation was simple but the interface to the functionality was complex. The New Jersey guy said that the right tradeoff has been selected in Unix -- namely, implementation simplicity was more important than interface simplicity.\u003c/p\u003e\n\u003cp\u003eThe MIT guy then muttered that sometimes it takes a tough man to make a tender chicken, but the New Jersey guy didn’t understand (I’m not sure I do either).\u003c/p\u003e\n\u003cp\u003eNow I want to argue that worse-is-better is better. C is a programming language designed for writing Unix, and it was designed using the New Jersey approach. C is therefore a language for which it is easy to write a decent compiler, and it requires the programmer to write text that is easy for the compiler to interpret. Some have called C a fancy assembly language. Both early Unix and C compilers had simple structures, are easy to port, require few machine resources to run, and provide about 50%-80% of what you want from an operating system and programming language.\u003c/p\u003e\n\u003cp\u003eHalf the computers that exist at any point are worse than median (smaller or slower). Unix and C work fine on them. The worse-is-better philosophy means that implementation simplicity has highest priority, which means Unix and C are easy to port on such machines. Therefore, one expects that if the 50% functionality Unix and C support is satisfactory, they will start to appear everywhere. And they have, haven’t they?\u003c/p\u003e\n\u003cp\u003eUnix and C are the ultimate computer viruses.\u003c/p\u003e\n\u003cp\u003eA further benefit of the worse-is-better philosophy is that the programmer is conditioned to sacrifice some safety, convenience, and hassle to get good performance and modest resource use. Programs written using the New Jersey approach will work well both in small machines and large ones, and the code will be portable because it is written on top of a virus.\u003c/p\u003e\n\u003cp\u003eIt is important to remember that the initial virus has to be basically good. If so, the viral spread is assured as long as it is portable. Once the virus has spread, there will be pressure to improve it, possibly by increasing its functionality closer to 90%, but users have already been conditioned to accept worse than the right thing. Therefore, the worse-is-better software first will gain acceptance, second will condition its users to expect less, and third will be improved to a point that is almost the right thing. In concrete terms, even though Lisp compilers in 1987 were about as good as C compilers, there are many more compiler experts who want to make C compilers better than want to make Lisp compilers better.\u003c/p\u003e\n\u003cp\u003eThe good news is that in 1995 we will have a good operating system and programming language; the bad news is that they will be Unix and C++.\u003c/p\u003e\n\u003cp\u003eThere is a final benefit to worse-is-better. Because a New Jersey language and system are not really powerful enough to build complex monolithic software, large systems must be designed to reuse components. Therefore, a tradition of integration springs up.\u003c/p\u003e\n\u003cp\u003eHow does the right thing stack up? There are two basic scenarios: the \u003cem\u003ebig complex system scenario\u003c/em\u003e and the \u003cem\u003ediamond-like jewel\u003c/em\u003e scenario.\u003c/p\u003e\n\u003cp\u003eThe \u003cem\u003ebig complex system\u003c/em\u003e scenario goes like this:\u003c/p\u003e\n\u003cp\u003eFirst, the right thing needs to be designed. Then its implementation needs to be designed. Finally it is implemented. Because it is the right thing, it has nearly 100% of desired functionality, and implementation simplicity was never a concern so it takes a long time to implement. It is large and complex. It requires complex tools to use properly. The last 20% takes 80% of the effort, and so the right thing takes a long time to get out, and it only runs satisfactorily on the most sophisticated hardware.\u003c/p\u003e\n\u003cp\u003eThe \u003cem\u003ediamond-like jewel\u003c/em\u003e scenario goes like this:\u003c/p\u003e\n\u003cp\u003eThe right thing takes forever to design, but it is quite small at every point along the way. To implement it to run fast is either impossible or beyond the capabilities of most implementors.\u003c/p\u003e\n\u003cp\u003eThe two scenarios correspond to Common Lisp and Scheme.\u003c/p\u003e\n\u003cp\u003eThe first scenario is also the scenario for classic artificial intelligence software.\u003c/p\u003e\n\u003cp\u003eThe right thing is frequently a monolithic piece of software, but for no reason other than that the right thing is often designed monolithically. That is, this characteristic is a happenstance.\u003c/p\u003e\n\u003cp\u003eThe lesson to be learned from this is that it is often undesirable to go for the right thing first. It is better to get half of the right thing available so that it spreads like a virus. Once people are hooked on it, take the time to improve it to 90% of the right thing.\u003c/p\u003e\n\u003cp\u003eA wrong lesson is to take the parable literally and to conclude that C is the right vehicle for AI software. The 50% solution has to be basically right, and in this case it isn’t.\u003c/p\u003e\n\u003cp\u003eBut, one can conclude only that the Lisp community needs to seriously rethink its position on Lisp design. I will say more about this later.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"hn\"\u003eHN\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#hn\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"d0mine\"\u003e\u003ca href=\"https://news.ycombinator.com/item?id=41770603\"\u003ed0mine\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#d0mine\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThere is also \"satisficing\" (vs. maximizing).\u003c/p\u003e\n\u003cp\u003eYour model of the world is not perfect so instead of trying to find a globally optimal solution, you are satisfied with a local optimum that exceeds some threshold that has to suffices.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Satisficing\"\u003ehttps://en.wikipedia.org/wiki/Satisficing\u003c/a\u003e\u003c/p\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"retcebd2gcvbhrg3nkwsl8e"},"buildId":"vOE8u-mg___OsOsz4tjEg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>