<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Fast-Paced Multiplayer (Part II): Client-Side Prediction and Server Reconciliation</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Fast-Paced Multiplayer (Part II): Client-Side Prediction and Server Reconciliation"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/7jdxj17k3fj5r6l4zuqdx57/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="10/19/2023"/><meta property="article:modified_time" content="10/19/2023"/><link rel="canonical" href="https://luke-snaw.github.io//notes/7jdxj17k3fj5r6l4zuqdx57/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_buildManifest.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="fast-paced-multiplayer-part-ii-client-side-prediction-and-server-reconciliation">Fast-Paced Multiplayer (Part II): Client-Side Prediction and Server Reconciliation<a aria-hidden="true" class="anchor-heading icon-link" href="#fast-paced-multiplayer-part-ii-client-side-prediction-and-server-reconciliation"></a></h1>
<blockquote>
<p><a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html">https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html</a></p>
</blockquote>
<h2 id="introduction"><a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#introduction">Introduction</a><a aria-hidden="true" class="anchor-heading icon-link" href="#introduction"></a></h2>
<p>In the <a href="https://www.gabrielgambetta.com/client-server-game-architecture.html">first article</a> of this series, we explored a client-server model with an authoritative server and dumb clients that just send inputs to the server, and then render the updated game state when the server sends it.</p>
<p>A naive implementation of this scheme leads to a delay between user commands and changes on the screen; for example, the player presses the right arrow key, and the character takes half a second before it starts moving. This is because the client input must first travel to the server, the server must process the input and calculate a new game state, and the updated game state must reach the client again.</p>
<p><a href="/img/fpm2-01.png">Effect of network delays.</a></p>
<p>Effect of network delays.</p>
<p>In a networked environment such as the internet, where delays can be ten or hundreds of milliseconds, a game may feel unresponsive at best, or in the worst case, be completely unplayable. In this article, we’ll find ways to minimize or even eliminate that problem.</p>
<h2 id="client-side-prediction"><a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#client-side-prediction">Client-side prediction</a><a aria-hidden="true" class="anchor-heading icon-link" href="#client-side-prediction"></a></h2>
<p>Even though there are some cheating players, most of the time the game server is processing valid requests (from non-cheating clients and from cheating clients who aren’t cheating at that particular time). This means most of the input received will be valid and will update the game state as expected; that is, if your character is at (10, 10) and the right arrow key is pressed, it will end up at (11, 10).</p>
<p>We can use this to our advantage. If the game world is <em>deterministic</em> enough (that is, given a game state and a set of inputs, the result is completely predictable), we can send the inputs to the server and <em>immediately</em> process them on the client - that is, we <em>predict</em> what the game state will be after the server has processed the inputs; this eliminates the delay between receiving an input and rendering its effect. Furthermore, most of the time this prediction will be accurate, so there will not be any visible mismatch once the server does send the updated game state.</p>
<p>Let’s suppose we have a 100 ms lag, and the animation of the character moving from one square to the next takes 100 ms. Using the naive implementation, the whole action would take 200 ms:</p>
<p><a href="/img/fpm2-02.png">Network delay + animation.</a></p>
<p>Network delay + animation.</p>
<p>Since the world is deterministic, we can assume the inputs we send to the server will be executed successfully. Under this assumption, the client can predict the state of the game world after the inputs are processed, and most of the time this will be correct.</p>
<p>Instead of sending the inputs and waiting for the new game state to start rendering it, we can send the input and start rendering the outcome of that inputs as if they had succeded, while we wait for the server to send the “true” game state – which more often than not, will match the state calculated locally :</p>
<p><a href="/img/fpm2-03.png">Animation plays while the server confirms the action.</a></p>
<p>Animation plays while the server confirms the action.</p>
<p>Now there’s absolutely no delay between the player’s actions and the results on the screen, while the server is still authoritative (if a hacked client would send invalid inputs, it could render whatever it wanted on the screen, but it wouldn’t affect the state of the server, which is what the other players see).</p>
<h2 id="synchronization-issues"><a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#synchronization-issues">Synchronization issues</a><a aria-hidden="true" class="anchor-heading icon-link" href="#synchronization-issues"></a></h2>
<p>In the example above, I chose the numbers carefully to make everything work fine. However, consider a slightly modified scenario: let’s say we have a 250 ms lag to the server, and moving from a square to the next takes 100 ms. Let’s also say the player presses the right key 2 times in a row, trying to move 2 squares to the right.</p>
<p>Using the techniques so far, this is what would happen:</p>
<p><a href="/img/fpm2-04.png">Predicted state and authoritative state mismatch.</a></p>
<p>Predicted state and authoritative state mismatch.</p>
<p>We run into an interesting problem at <strong>t = 250 ms</strong>, when the new game state arrives. The predicted state at the client is <strong>x = 12</strong>, but the server says the new game state is <strong>x = 11</strong>. Because the server is authoritative, the client must move the character back to <strong>x = 11</strong>. But then, a new server state arrives at <strong>t = 350</strong>, which says <strong>x = 12</strong>, so the character jumps again, forward this time.</p>
<p>From the point of view of the player, they pressed the right arrow key twice; the character moved two squares to the right, stood there for 50 ms, jumped one square to the left, stood there for 100 ms, and jumped one square to the right. This, of course, is unacceptable.</p>
<h2 id="server-reconciliation"><a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#server-reconciliation">Server reconciliation</a><a aria-hidden="true" class="anchor-heading icon-link" href="#server-reconciliation"></a></h2>
<p>The key to fix this problem is to realize that the client sees the game world <em>in present time</em>, but because of lag, the updates it gets from the server are actually the state of the game <em>in the past</em>. By the time the server sent the updated game state, it hadn’t processed all the commands sent by the client.</p>
<p>This isn’t terribly difficult to work around, though. First, the client adds a sequence number to each request; in our example, the first key press is request #1, and the second key press is request #2. Then, when the server replies, it includes the sequence number of the last input it processed:</p>
<p><a href="/img/fpm2-05.png">Client-side prediction + server reconciliation.</a></p>
<p>Client-side prediction + server reconciliation.</p>
<p>Now, at <strong>t = 250</strong>, the server says “<strong>based on what I’ve seen up to your request #1, your position is x = 11</strong>”. Because the server is authoritative, it sets the character position at <strong>x = 11</strong>. Now let’s assume the client keeps a copy of the requests it sends to the server. Based on the new game state, it knows the server has already processed request #1, so it can discard that copy. But it also knows the server still has to send back the result of processing request #2. So applying client-side prediction again, the client can calculate the “present” state of the game based on the last authoritative state sent by the server, plus the inputs the server hasn’t processed yet.</p>
<p>So, at <strong>t = 250</strong>, the client gets “<strong>x = 11, last processed request = #1</strong>”. It discards its copies of sent input up to #1 – but it retains a copy of #2, which hasn’t been acknowledged by the server. It updates its internal game state with what the server sent, <strong>x = 11</strong>, and then applies all the input still not seen by the server – in this case, input #2, “move to the right”. The end result is <strong>x = 12</strong>, which is correct.</p>
<p>Continuing with our example, at <strong>t = 350</strong> a new game state arrives from the server; this time it says “<strong>x = 12, last processed request = #2</strong>”. At this point, the client discards all input up to #2, and updates the state with <strong>x = 12</strong>. There’s no unprocessed input to replay, so processing ends there, with the correct result.</p>
<h2 id="odds-and-ends"><a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#odds-and-ends">Odds and ends</a><a aria-hidden="true" class="anchor-heading icon-link" href="#odds-and-ends"></a></h2>
<p>The example discussed above implies movement, but the same principle can be applied to almost anything else. For example, in a turn-based combat game, when the player attacks another character, you can show blood and a number representing the damage done, but you shouldn’t actually update the health of the character until the server says so.</p>
<p>Because of the complexities of game state, which isn’t always easily reversible, you may want to avoid killing a character until the server says so, even if its health dropped below zero in the client’s game state (what if the other character used a first-aid kit just before receiving your deadly attack, but the server hasn’t told you yet?)</p>
<p>This brings us to an interesting point – even if the world is completely deterministic and no clients cheat at all, it’s still possible that the state predicted by the client and the state sent by the server don’t match after a reconciliation. The scenario is impossible as described above with a single player, but it’s easy to run into when several players are connected to the server at once. This will be the topic of the next article.</p>
<h3 id="summary"><a href="https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#summary">Summary</a><a aria-hidden="true" class="anchor-heading icon-link" href="#summary"></a></h3>
<p>When using an authoritative server, you need to give the player the illusion of responsiveness, while you wait for the server to actually process your inputs. To do this, the client simulates the results of the inputs. When the updated server state arrives, the predicted client state is recomputed from the updated state and the inputs the client sent but the server hasn’t acknowledged yet.</p>
<p><a href="https://www.gabrielgambetta.com/client-server-game-architecture.html">&#x3C;&#x3C; Part I: Client-Server Game Architecture</a> · <a href="https://www.gabrielgambetta.com/entity-interpolation.html"><strong>Part III: Entity Interpolation >></strong></a></p></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#introduction" title="Introduction">Introduction</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#client-side-prediction" title="Client-side prediction">Client-side prediction</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#synchronization-issues" title="Synchronization issues">Synchronization issues</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#server-reconciliation" title="Server reconciliation">Server reconciliation</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#odds-and-ends" title="Odds and ends">Odds and ends</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#summary" title="Summary">Summary</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"7jdxj17k3fj5r6l4zuqdx57","title":"Fast-Paced Multiplayer (Part II): Client-Side Prediction and Server Reconciliation","desc":"","updated":1697686857500,"created":1697686817626,"custom":{},"fname":"dev.software-engineering.client-side-prediction-server-reconciliation","type":"note","vault":{"fsPath":"vault"},"contentHash":"341f24263a7d260aacd9bebb801cda77","links":[],"anchors":{"introduction":{"type":"header","text":"Introduction","value":"introduction","line":12,"column":0,"depth":2},"client-side-prediction":{"type":"header","text":"Client-side prediction","value":"client-side-prediction","line":24,"column":0,"depth":2},"synchronization-issues":{"type":"header","text":"Synchronization issues","value":"synchronization-issues","line":46,"column":0,"depth":2},"server-reconciliation":{"type":"header","text":"Server reconciliation","value":"server-reconciliation","line":60,"column":0,"depth":2},"odds-and-ends":{"type":"header","text":"Odds and ends","value":"odds-and-ends","line":76,"column":0,"depth":2},"summary":{"type":"header","text":"Summary","value":"summary","line":84,"column":0,"depth":3}},"children":[],"parent":"j0N1aVKxe96dktmyADG9U","data":{}},"body":"\u003ch1 id=\"fast-paced-multiplayer-part-ii-client-side-prediction-and-server-reconciliation\"\u003eFast-Paced Multiplayer (Part II): Client-Side Prediction and Server Reconciliation\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#fast-paced-multiplayer-part-ii-client-side-prediction-and-server-reconciliation\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html\"\u003ehttps://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"introduction\"\u003e\u003ca href=\"https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#introduction\"\u003eIntroduction\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#introduction\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIn the \u003ca href=\"https://www.gabrielgambetta.com/client-server-game-architecture.html\"\u003efirst article\u003c/a\u003e of this series, we explored a client-server model with an authoritative server and dumb clients that just send inputs to the server, and then render the updated game state when the server sends it.\u003c/p\u003e\n\u003cp\u003eA naive implementation of this scheme leads to a delay between user commands and changes on the screen; for example, the player presses the right arrow key, and the character takes half a second before it starts moving. This is because the client input must first travel to the server, the server must process the input and calculate a new game state, and the updated game state must reach the client again.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/img/fpm2-01.png\"\u003eEffect of network delays.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eEffect of network delays.\u003c/p\u003e\n\u003cp\u003eIn a networked environment such as the internet, where delays can be ten or hundreds of milliseconds, a game may feel unresponsive at best, or in the worst case, be completely unplayable. In this article, we’ll find ways to minimize or even eliminate that problem.\u003c/p\u003e\n\u003ch2 id=\"client-side-prediction\"\u003e\u003ca href=\"https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#client-side-prediction\"\u003eClient-side prediction\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#client-side-prediction\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eEven though there are some cheating players, most of the time the game server is processing valid requests (from non-cheating clients and from cheating clients who aren’t cheating at that particular time). This means most of the input received will be valid and will update the game state as expected; that is, if your character is at (10, 10) and the right arrow key is pressed, it will end up at (11, 10).\u003c/p\u003e\n\u003cp\u003eWe can use this to our advantage. If the game world is \u003cem\u003edeterministic\u003c/em\u003e enough (that is, given a game state and a set of inputs, the result is completely predictable), we can send the inputs to the server and \u003cem\u003eimmediately\u003c/em\u003e process them on the client - that is, we \u003cem\u003epredict\u003c/em\u003e what the game state will be after the server has processed the inputs; this eliminates the delay between receiving an input and rendering its effect. Furthermore, most of the time this prediction will be accurate, so there will not be any visible mismatch once the server does send the updated game state.\u003c/p\u003e\n\u003cp\u003eLet’s suppose we have a 100 ms lag, and the animation of the character moving from one square to the next takes 100 ms. Using the naive implementation, the whole action would take 200 ms:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/img/fpm2-02.png\"\u003eNetwork delay + animation.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eNetwork delay + animation.\u003c/p\u003e\n\u003cp\u003eSince the world is deterministic, we can assume the inputs we send to the server will be executed successfully. Under this assumption, the client can predict the state of the game world after the inputs are processed, and most of the time this will be correct.\u003c/p\u003e\n\u003cp\u003eInstead of sending the inputs and waiting for the new game state to start rendering it, we can send the input and start rendering the outcome of that inputs as if they had succeded, while we wait for the server to send the “true” game state – which more often than not, will match the state calculated locally :\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/img/fpm2-03.png\"\u003eAnimation plays while the server confirms the action.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eAnimation plays while the server confirms the action.\u003c/p\u003e\n\u003cp\u003eNow there’s absolutely no delay between the player’s actions and the results on the screen, while the server is still authoritative (if a hacked client would send invalid inputs, it could render whatever it wanted on the screen, but it wouldn’t affect the state of the server, which is what the other players see).\u003c/p\u003e\n\u003ch2 id=\"synchronization-issues\"\u003e\u003ca href=\"https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#synchronization-issues\"\u003eSynchronization issues\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#synchronization-issues\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIn the example above, I chose the numbers carefully to make everything work fine. However, consider a slightly modified scenario: let’s say we have a 250 ms lag to the server, and moving from a square to the next takes 100 ms. Let’s also say the player presses the right key 2 times in a row, trying to move 2 squares to the right.\u003c/p\u003e\n\u003cp\u003eUsing the techniques so far, this is what would happen:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/img/fpm2-04.png\"\u003ePredicted state and authoritative state mismatch.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003ePredicted state and authoritative state mismatch.\u003c/p\u003e\n\u003cp\u003eWe run into an interesting problem at \u003cstrong\u003et = 250 ms\u003c/strong\u003e, when the new game state arrives. The predicted state at the client is \u003cstrong\u003ex = 12\u003c/strong\u003e, but the server says the new game state is \u003cstrong\u003ex = 11\u003c/strong\u003e. Because the server is authoritative, the client must move the character back to \u003cstrong\u003ex = 11\u003c/strong\u003e. But then, a new server state arrives at \u003cstrong\u003et = 350\u003c/strong\u003e, which says \u003cstrong\u003ex = 12\u003c/strong\u003e, so the character jumps again, forward this time.\u003c/p\u003e\n\u003cp\u003eFrom the point of view of the player, they pressed the right arrow key twice; the character moved two squares to the right, stood there for 50 ms, jumped one square to the left, stood there for 100 ms, and jumped one square to the right. This, of course, is unacceptable.\u003c/p\u003e\n\u003ch2 id=\"server-reconciliation\"\u003e\u003ca href=\"https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#server-reconciliation\"\u003eServer reconciliation\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#server-reconciliation\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe key to fix this problem is to realize that the client sees the game world \u003cem\u003ein present time\u003c/em\u003e, but because of lag, the updates it gets from the server are actually the state of the game \u003cem\u003ein the past\u003c/em\u003e. By the time the server sent the updated game state, it hadn’t processed all the commands sent by the client.\u003c/p\u003e\n\u003cp\u003eThis isn’t terribly difficult to work around, though. First, the client adds a sequence number to each request; in our example, the first key press is request #1, and the second key press is request #2. Then, when the server replies, it includes the sequence number of the last input it processed:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/img/fpm2-05.png\"\u003eClient-side prediction + server reconciliation.\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eClient-side prediction + server reconciliation.\u003c/p\u003e\n\u003cp\u003eNow, at \u003cstrong\u003et = 250\u003c/strong\u003e, the server says “\u003cstrong\u003ebased on what I’ve seen up to your request #1, your position is x = 11\u003c/strong\u003e”. Because the server is authoritative, it sets the character position at \u003cstrong\u003ex = 11\u003c/strong\u003e. Now let’s assume the client keeps a copy of the requests it sends to the server. Based on the new game state, it knows the server has already processed request #1, so it can discard that copy. But it also knows the server still has to send back the result of processing request #2. So applying client-side prediction again, the client can calculate the “present” state of the game based on the last authoritative state sent by the server, plus the inputs the server hasn’t processed yet.\u003c/p\u003e\n\u003cp\u003eSo, at \u003cstrong\u003et = 250\u003c/strong\u003e, the client gets “\u003cstrong\u003ex = 11, last processed request = #1\u003c/strong\u003e”. It discards its copies of sent input up to #1 – but it retains a copy of #2, which hasn’t been acknowledged by the server. It updates its internal game state with what the server sent, \u003cstrong\u003ex = 11\u003c/strong\u003e, and then applies all the input still not seen by the server – in this case, input #2, “move to the right”. The end result is \u003cstrong\u003ex = 12\u003c/strong\u003e, which is correct.\u003c/p\u003e\n\u003cp\u003eContinuing with our example, at \u003cstrong\u003et = 350\u003c/strong\u003e a new game state arrives from the server; this time it says “\u003cstrong\u003ex = 12, last processed request = #2\u003c/strong\u003e”. At this point, the client discards all input up to #2, and updates the state with \u003cstrong\u003ex = 12\u003c/strong\u003e. There’s no unprocessed input to replay, so processing ends there, with the correct result.\u003c/p\u003e\n\u003ch2 id=\"odds-and-ends\"\u003e\u003ca href=\"https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#odds-and-ends\"\u003eOdds and ends\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#odds-and-ends\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe example discussed above implies movement, but the same principle can be applied to almost anything else. For example, in a turn-based combat game, when the player attacks another character, you can show blood and a number representing the damage done, but you shouldn’t actually update the health of the character until the server says so.\u003c/p\u003e\n\u003cp\u003eBecause of the complexities of game state, which isn’t always easily reversible, you may want to avoid killing a character until the server says so, even if its health dropped below zero in the client’s game state (what if the other character used a first-aid kit just before receiving your deadly attack, but the server hasn’t told you yet?)\u003c/p\u003e\n\u003cp\u003eThis brings us to an interesting point – even if the world is completely deterministic and no clients cheat at all, it’s still possible that the state predicted by the client and the state sent by the server don’t match after a reconciliation. The scenario is impossible as described above with a single player, but it’s easy to run into when several players are connected to the server at once. This will be the topic of the next article.\u003c/p\u003e\n\u003ch3 id=\"summary\"\u003e\u003ca href=\"https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html#summary\"\u003eSummary\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#summary\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWhen using an authoritative server, you need to give the player the illusion of responsiveness, while you wait for the server to actually process your inputs. To do this, the client simulates the results of the inputs. When the updated server state arrives, the predicted client state is recomputed from the updated state and the inputs the client sent but the server hasn’t acknowledged yet.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.gabrielgambetta.com/client-server-game-architecture.html\"\u003e\u0026#x3C;\u0026#x3C; Part I: Client-Server Game Architecture\u003c/a\u003e · \u003ca href=\"https://www.gabrielgambetta.com/entity-interpolation.html\"\u003e\u003cstrong\u003ePart III: Entity Interpolation \u003e\u003e\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"7jdxj17k3fj5r6l4zuqdx57"},"buildId":"vOE8u-mg___OsOsz4tjEg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>