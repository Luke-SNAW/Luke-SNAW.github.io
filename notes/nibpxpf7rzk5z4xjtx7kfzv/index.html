<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>When You Should Prefer Map Over Object In JavaScript</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="When You Should Prefer Map Over Object In JavaScript"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/nibpxpf7rzk5z4xjtx7kfzv/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="7/5/2022"/><meta property="article:modified_time" content="2/9/2023"/><link rel="canonical" href="https://luke-snaw.github.io//notes/nibpxpf7rzk5z4xjtx7kfzv/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_buildManifest.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="when-you-should-prefer-map-over-object-in-javascript">When You Should Prefer Map Over Object In JavaScript<a aria-hidden="true" class="anchor-heading icon-link" href="#when-you-should-prefer-map-over-object-in-javascript"></a></h1>
<blockquote>
<p><a href="https://www.zhenghao.io/posts/object-vs-map">https://www.zhenghao.io/posts/object-vs-map</a></p>
</blockquote>
<p>the missing guide to choosing between Object and Map in JavaScript</p>
<blockquote>
<p>See discussions on <a href="https://www.reddit.com/r/javascript/comments/vgs7y1/why_you_should_prefer_map_over_object_in/">reddit</a></p>
</blockquote>
<p>In JavaScript, objects are handy. They allow us to easily group multiple pieces of data together. After ES6, we got a new addition to the language - <code>Map</code> . In a lot of aspects, it seems like a more capable <code>Object</code> with a somewhat clumsy interface. However, most people still reach for objects when they need a <a href="https://en.wikipedia.org/wiki/Hash_table">hash map</a> and only switch to using <code>Map</code> when they realize the keys can't just be strings for their use cases. As a result, <code>Map</code> remains <strong>underused</strong> in today's JavaScript community.</p>
<p>In this post, I will break down all the reasons when you should consider using <code>Map</code> more and its performance characteristics with benchmarks.</p>
<blockquote>
<p>In JavaScript, Object is a pretty broad term. Almost everything can be an object, except for two bottom types - <code>null</code> and <code>undefined</code>. In this blog post, Object only refers to plain old objects, delimited by a left brace <code>{</code> and a right brace <code>}</code>.</p>
</blockquote>
<h2 id="tldr">TL;DR:<a aria-hidden="true" class="anchor-heading icon-link" href="#tldr"></a></h2>
<ul>
<li>Use <code>Object</code> for records where you have a fixed and finite number of properties/fields known at author time, such as a config object. And anything that is for one-time use in general.</li>
<li>Use <code>Map</code> for dictionaries or hash maps where you have a variable number of entries, with frequent updates, whose keys might not be known at author time, such as an <a href="https://github.com/developit/mitt/blob/main/src/index.ts#L45">event emitter</a>.</li>
<li>According to <a href="https://www.zhenghao.io/posts/object-vs-map#performance-extravaganza">my benchmarks</a>, <em>unless</em> the keys are strings of small integers, <code>Map</code> is indeed <strong>more performant</strong> than <code>Object</code> on insertion, deletion and iteration speed, and it consumes <strong>less memory</strong> than <code>Object</code> of the same size.</li>
</ul>
<h2 id="why-object-falls-short-of-a-hash-map-use-caseobject-vs-mapwhy-object-falls-short-of-a-hash-map-use-case">Why Object falls short of a hash-map use caseobject-vs-map#why-object-falls-short-of-a-hash-map-use-case)<a aria-hidden="true" class="anchor-heading icon-link" href="#why-object-falls-short-of-a-hash-map-use-caseobject-vs-mapwhy-object-falls-short-of-a-hash-map-use-case"></a></h2>
<p>Probably the most obvious downside of using objects for hash maps is that objects only allow keys that are strings and symbols. Any other types will be implicitly cast to string via the <code>toString</code> methods.</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>bar<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">"bar"</span> <span class="token punctuation">}</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// {"": 'foo', [object Object]: 'bar'}</span>
</code></pre>
<p>More importantly, using objects for hash maps can cause confusion and <em>security hazards</em>.</p>
<h3 id="unwanted-inheritanceobject-vs-mapunwanted-inheritance">unwanted inheritanceobject-vs-map#unwanted-inheritance)<a aria-hidden="true" class="anchor-heading icon-link" href="#unwanted-inheritanceobject-vs-mapunwanted-inheritance"></a></h3>
<p>Before ES6, the only way to get a hash map is by creating an empty object.</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> hashMap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
<p>However, upon creation, this object is no longer empty. Although <code>hashMap</code> is made with an empty object literal, it automatically inherits from <code>Object.prototype</code> . That's why we can invoke methods like <code>hasOwnProperty</code> , <code>toString</code> , <code>constructor</code> on <code>hashMap</code> even when we never explicitly define those methods on the object.</p>
<p>Because of prototypal inheritance, we now have two types of properties conflated: properties that live within the object itself, i.e. its <em>own</em> properties, and properties that live in the prototype chain, i.e. <em>inherited</em> properties. As a result, we need an additional check (e.g. <code>hasOwnProperty</code>) to make sure a given property is indeed user-provided, as opposed to inherited from the prototype.</p>
<p>On top of that, because of how the property resolution mechanism works in JavaScript, any change to <code>Object.prototype</code> at runtime will cause a <em>ripple</em> effect in all objects. This opens the door for <a href="https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf">prototype pollution attack</a>, which can be a serious security issue for large JavaScript applications.</p>
<p>Fortunately, we can work around this by using <code>Object.create(null)</code>, which makes an object that inherits nothing from <code>Object.prototype</code>.</p>
<h3 id="name-collisions">name collisions<a aria-hidden="true" class="anchor-heading icon-link" href="#name-collisions"></a></h3>
<p>When an object’s <em>own</em> properties have name collisions with ones on its prototype, it breaks expectations and thus crashes your program.</p>
<p>For example, we have a function <code>foo</code> which accepts an object:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token method function property-access">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>There is a reliability hazard in <code>obj.hasOwnProperty(key)</code>: given how property resolution mechanism works in JavaScript, if <code>obj</code> contains a user-provided property with the same name <code>hasOwnProperty</code> , that shadows <code>Object.prototype.hasOwnProperty</code>. As a result, we <em>don’t know</em> which method is going to get called exactly during runtime.</p>
<p>Some defensive programming can be done to prevent this. For example we can “borrow” the "real" <code>hasOwnProperty</code> from <code>Object.prototype</code> instead:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  <span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method function property-access">hasOwnProperty</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>A shorter way might be invoking the method on an object literal as in <code>{}.hasOwnProperty.call(key)</code> however it is still pretty cumbersome. That's why there is a newly-added static method <code>Object.hasOwn</code>.</p>
<h3 id="sub-optimal-ergonomicsobject-vs-mapsub-optimal-ergonomics">Sub-optimal ergonomicsobject-vs-map#sub-optimal-ergonomics)<a aria-hidden="true" class="anchor-heading icon-link" href="#sub-optimal-ergonomicsobject-vs-mapsub-optimal-ergonomics"></a></h3>
<p><code>Object</code> doesn't provide adequate ergonomics to be used as a hash map. Many common tasks can't be intuitively performed.</p>
<h4 id="size">size<a aria-hidden="true" class="anchor-heading icon-link" href="#size"></a></h4>
<p><code>Object</code> doesn't come with a handy API to get the size, i.e. the number of properties. And there are nuances to what constitutes the size of an object:</p>
<ul>
<li>if you only care about string, enumerable keys, then you can convert the keys to an array with <code>Object.keys()</code> and get its <code>length</code>.</li>
<li>if you want to account for <em>non-enumerable</em> string keys, then you have to use <code>Object.getOwnPropertyNames</code> to get a list of the keys and get its length.</li>
<li>if you are interested in symbol keys, you can use <code>getOwnPropertySymbols</code> to reveal the symbol keys. Or you can use <code>Reflect.ownKeys</code> to get both string keys and symbol keys all at once, regardless if it is enumerable or not.</li>
</ul>
<p>All the above options take a runtime complexity of <code>O(n)</code> since we have to construct an array of keys first before we can get its length.</p>
<h4 id="iterate">iterate<a aria-hidden="true" class="anchor-heading icon-link" href="#iterate"></a></h4>
<p>Looping through objects suffers from similar complexity.</p>
<p>We can use the good old <code>for...in</code> loop. But it reveals inherited enumerable properties:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token property-access">foo</span> <span class="token operator">=</span> <span class="token string">"bar"</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>

<span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// 'id', 'foo'</span>
<span class="token punctuation">}</span>
</code></pre>
<p>We couldn't use <code>for...of</code> with an object since by default it is not an iterable, unless we explicitly defines the <code>Symbol.iterator</code> method on it.</p>
<p>We can use <code>Object.keys</code> , <code>Object.values</code> and <code>Object.entries</code> to get a list of enumerable, string keys (or/and values) and iterate through that instead, which introduces an extra step with overhead.</p>
<p>Finally, the insertion order is infamously not <em>fully</em> respected. In most browsers, integer keys are sorted in ascending order and take precedence over string keys even if the string keys are inserted before the integer keys.</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

obj<span class="token punctuation">.</span><span class="token property-access">foo</span> <span class="token operator">=</span> <span class="token string">"first"</span>
obj<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"second"</span>
obj<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"last"</span>

<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// {1: 'last', 2: 'second', foo: 'first'}</span>
</code></pre>
<h4 id="clear">clear<a aria-hidden="true" class="anchor-heading icon-link" href="#clear"></a></h4>
<p>There is no easy way to remove all properties from an object, you have to delete each property one by one with the <code>delete</code> operator, which <a href="https://stackoverflow.com/questions/43594092/slow-delete-of-object-properties-in-js-in-v8">has been known</a> to be slow historically. However my benchmarks show that its performance is actually not an order-of-magnitude slower than <code>Map.prototype.delete</code>. More on that later.</p>
<h4 id="check-property-existenceobject-vs-mapcheck-property-existence">check property existenceobject-vs-map#check-property-existence)<a aria-hidden="true" class="anchor-heading icon-link" href="#check-property-existenceobject-vs-mapcheck-property-existence"></a></h4>
<p>Finally, we can't rely on the dot/bracket notation to check for existence of an property because the value itself could be set as <code>undefined</code>. Instead we have to use <code>Object.prototype.hasOwnProperty</code> or <code>Object.hasOwn</code>.</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token keyword nil">undefined</span> <span class="token punctuation">}</span>

<span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">hasOwn</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
</code></pre>
<h2 id="map-for-hash-map">Map for Hash Map<a aria-hidden="true" class="anchor-heading icon-link" href="#map-for-hash-map"></a></h2>
<p>ES6 brought Map. It is much more suited for a hash-map use case.</p>
<p>First of all, unlike <code>Object</code>, which only allows keys that are strings and symbols, <code>Map</code> supports keys of any data types.</p>
<blockquote>
<p>However if you are using <code>Map</code> to store meta-data for objects, then you should use <code>WeakMap</code> instead to avoid memory leak.</p>
</blockquote>
<p>But more importantly, <code>Map</code> provides a <em>clean separation</em> between user-defined and built-in program data, at the expense of an additional <code>Map.prototype.get</code> to retrieve entries.</p>
<p><code>Map</code> also provides better ergonomics: A <code>Map</code> is an iterable by default. That means you can iterate a map easily with <code>for...of</code>, and do things like using nested destructuring to pull out the first entry from a map.</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> map
</code></pre>
<p>In contrast to <code>Object</code>, <code>Map</code> provides dedicated APIs for various common tasks:</p>
<ul>
<li><code>Map.prototype.has</code> checks for the existence of a given entry, less awkward compared to having to <code>Object.prototype.hasOwnProperty</code> / <code>Object.hasOwn</code> on objects</li>
<li><code>Map.prototype.get</code> returns the value associated to the provided key. One might feel this is clunkier than the dot notation or the bracket notation on objects. Nevertheless it provides a clean separation between user data and built-in method.</li>
<li><code>Map.prototype.size</code> returns the number of entries in a <code>Map</code> and it is a clear winner over the maneuvers you have to perform to get an object's size. Besides, it is much faster.</li>
<li><code>Map.prototype.clear</code> removes all the entries in a <code>Map</code> and it much faster than the <code>delete</code> operator.</li>
</ul>
<h2 id="performance-extravaganzaobject-vs-mapperformance-extravaganza">Performance extravaganzaobject-vs-map#performance-extravaganza)<a aria-hidden="true" class="anchor-heading icon-link" href="#performance-extravaganzaobject-vs-mapperformance-extravaganza"></a></h2>
<p>There seems to be a common belief among JavaScript community that <code>Map</code> is faster than <code>Object</code>, for the most part. There are <a href="https://twitter.com/diegohaz/status/1534888291732013058">people</a> who claimed to see noticeable performance gains by switching from <code>Object</code> to <code>Map</code>.</p>
<p>My experience of grinding Leetcode seems to confirm this belief: Leetcode feeds a huge amount of data as the test cases to your solution and it times out if your solution is taking too long. Questions like <a href="https://leetcode.com/problems/random-pick-with-weight/discuss/671804/Javascript-with-explanation-and-very-interesting-find-regarding-vs-Map">this one</a> only times out if you use <code>Object</code>, but not on <code>Map</code>.</p>
<p>However, I believe just saying "<code>Map</code> is faster than Object" is reductive. There must be some nuance that I wanted to find out myself. Therefore. I built <a href="https://csb-yuu1dm.netlify.app/">a little app</a> to run some benchmarks.</p>
<p>Important Disclaimer</p>
<p>I would never claim that I fully understand how V8 works under the hood to optimize <code>Map</code> despite my many attempts to read blog posts and peek the C++ source code. Perfectly robust benchmarking is hard, and most of us never went through any form of training in either benchmarking or interpreting the results. The more benchmarking I do the more it felt like a story about <a href="https://en.wikipedia.org/wiki/Blind_men_and_an_elephant">blind men and an elephant</a>. So take everything I said here about performance a grain of salt. You'll need to test such changes with your application in a production environment to know for sure if there are actual performance gains from using <code>Map</code>s over objects.</p>
<h3 id="benchmarking-implementation-detailsobject-vs-mapbenchmarking-implementation-details">Benchmarking implementation detailsobject-vs-map#benchmarking-implementation-details)<a aria-hidden="true" class="anchor-heading icon-link" href="#benchmarking-implementation-detailsobject-vs-mapbenchmarking-implementation-details"></a></h3>
<p><a href="https://csb-yuu1dm.netlify.app/">The app</a> has a table that shows the insertion, iteration, and deletion speed measured on <code>Object</code> and <code>Map</code>.</p>
<p>The performances of insertion and iteration are measured in operations per second. I wrote an util function <code>measureFor</code> that runs the target function repeatedly until the specified minimal amount of time threshold (i.e. the <code>duration</code> input field on the UI) has been reached. It returns the average number of times such a function is executed per second.</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">measureFor</span><span class="token punctuation">(</span><span class="token parameter">f<span class="token punctuation">,</span> duration</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> iterations <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">const</span> now <span class="token operator">=</span> <span class="token dom variable">performance</span><span class="token punctuation">.</span><span class="token method function property-access">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> elapsed <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword control-flow">while</span> <span class="token punctuation">(</span>elapsed <span class="token operator">&#x3C;</span> duration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    elapsed <span class="token operator">=</span> <span class="token dom variable">performance</span><span class="token punctuation">.</span><span class="token method function property-access">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> now
    iterations<span class="token operator">++</span>
  <span class="token punctuation">}</span>

  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>iterations <span class="token operator">/</span> elapsed<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">toFixed</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>As to deletion, I am simply going to measure the time taken for using the <code>delete</code> operator to remove all properties from an objects and compare it with the time with <code>Map.prototype.delete</code> for a Map of the same size. I could use <code>Map.prototype.clear</code> but it defeats the purpose of the benchmarks as I know for sure it is going to be vastly faster.</p>
<p>In these three operations, I pay more attention to insertion since it tends to be the most common operation I perform in my day-to-day work. For iteration performance, it is hard to come up with an all-encompassing benchmarks as there are many different variants of iteration we can perform on a given object. Here I am only measuring the <code>for ... in</code> loop.</p>
<p>I used three types of keys here:</p>
<ol>
<li>strings, e.g. <code>yekwl7caqejth7aawelo4</code>.</li>
<li>integer strings, e.g. <code>123</code>.</li>
<li>numeric strings generated by <code>Math.random().toString()</code>, e.g. <code>0.4024025689756525</code>.</li>
</ol>
<p>All keys are randomly generated so we don’t hit the inline-cache implemented by V8. I also explicitly convert integer and numeric keys to strings using <code>toString</code> before adding them to objects to avoid the overhead of implicitly casting.</p>
<p>Lastly, before the benchmark begins, there is also a warmup phase for at least 100ms where we repeatedly create new objects and maps that are discarded right away.</p>
<p>I put the code on <a href="https://codesandbox.io/s/still-glitter-yuu1dm">Codesandbox</a> if you want to play with it.</p>
<p>I started with <code>Object</code> and <code>Map</code> with a size of 100 properties/entries, all the way to 5000000, and had each type of operations keep running for 10000ms to see how they performed against each other. Here are my findings...</p>
<p>Why do we stop when the number of entries reaches 5000000?</p>
<p>Because this is about as big as an object can get in JavaScript. According to <a href="https://stackoverflow.com/questions/54452896/maximum-number-of-entries-in-node-js-map#comment127492362_72149605">@jmrk</a>, a V8 engineer who is active on Stackoverflow, “if the keys are strings, a regular object becomes unusably slow after ~8.3M elements (for which there is a technical reason: a certain bit field being 23 bits wide and taking a very slow fallback path when exceeded).”.</p>
<h3 id="string-keys">string keys<a aria-hidden="true" class="anchor-heading icon-link" href="#string-keys"></a></h3>
<p>Generally speaking, when keys are (non-numeric) string, <code>Map</code> outperforms <code>Object</code> on all operations.</p>
<p><img src="/art/blog/object-vs-map/deletion-speed.png" alt="alt"></p>
<p>But the nuance is that when the number of entries is not really huge (under 100000), <code>Map</code> is twice as fast as <code>Object</code> on insertion speed, but as the size grows over 100000, the performance gap starts to shrink.</p>
<p>I made some graphs to better illustrate my findings.</p>
<p><img src="/art/blog/object-vs-map/string-key-line-1.png" alt="alt"></p>
<p>The above graph shows how insertion rate drops (y-axis) with the number of entries increasing (x-axis). However because the X-axis expands too wide (from 100 to 1000000), it is hard to tell the gap between these two lines.</p>
<p>I then used log scales to process the data and made the graph below.</p>
<p><img src="/art/blog/object-vs-map/string-key-line-2.png" alt="alt"></p>
<p>You can clearly tell the two lines are converging.</p>
<p>I made another graph plotting how much faster <code>Map</code> is in relation to <code>Object</code> on insertion speed. You can see <code>Map</code> starts out being about 2 times faster than <code>Object</code>. Then over time the performance gap starts to shrink. Eventually <code>Map</code> is only 30% faster as the size grows to 5000000.</p>
<p><img src="/art/blog/object-vs-map/string-key-line-3.png" alt="alt"></p>
<p>Most of us will never have more than 1 million entries in an object or map though. With a size of a few hundreds or thousands of entries, <code>Map</code> is at least twice as performant as <code>Object</code>. Therefore, should we leave it at that and head over to start refactoring our codebase by going all in on <code>Map</code>?</p>
<p>Absolutely not… or at least not with an expectation that our app becomes 2 times faster. Remember we haven't explored other types of keys. Let's take a look at integer keys.</p>
<h3 id="integer-keys">integer keys<a aria-hidden="true" class="anchor-heading icon-link" href="#integer-keys"></a></h3>
<p>The reason I specifically want to run benchmarks on objects with integer keys is that V8 internally optimizes <a href="https://v8.dev/blog/fast-properties#named-properties-vs.-elements">integer-indexed properties</a> and store them in a separate array that can be accessed linearly and consecutively. I can’t find any resources confirming it employs the same kind of optimization for <code>Map</code>s though.</p>
<p>Let’s first try integer keys in the range of [0, 1000].</p>
<p><img src="/art/blog/object-vs-map/integer-key-1.png" alt="Untitled"></p>
<p>As I expected, <code>Object</code> <strong>outperform</strong> <code>Map</code> this time. They are 65% faster than maps for insertion speed and 16% faster to iterate.</p>
<p>Let's widen the range so that the maximum integer in the keys is 1200.</p>
<p><img src="/art/blog/object-vs-map/integer-key-2.png" alt="Untitled"></p>
<p>It seems like now <code>Map</code> s start to get a little faster than objects for insertion and 5 times faster for iteration.</p>
<p>Now that we only increased the integer keys' range, not the actual size of <code>Object</code> and <code>Map</code>. Let's bump up the size to see how that affects the performances.</p>
<p><img src="/art/blog/object-vs-map/integer-key-3.png" alt="Untitled"></p>
<p>When a size of 1000 properties, <code>Object</code> ends up being 70% faster than <code>Map</code> for insertion and 2 times slower for iteration.</p>
<p>I played with a bunch of different combinations of <code>Object</code>/<code>Map</code> sizes and integer key ranges and failed to come up with a clear pattern. But the general trend I am seeing is that, for as the size grows, with some relative small integer being the keys, objects can be <em>more performant</em> than <code>Map</code>s in terms of insertion, always roughly the same as to deletion and 4 or 5 times slower to iterate. The threshold of max integer keys at which objects start to be slower for insertion grows with the size of the objects. For example, when the object only has 100 entries, the threshold is 1200; when it has 10000 entries, the threshold seems to be around 24000.</p>
<h3 id="numeric-keys">numeric keys<a aria-hidden="true" class="anchor-heading icon-link" href="#numeric-keys"></a></h3>
<p>Lastly, let's take a look at the last type of keys - numeric keys.</p>
<p>Technically, the previously integer keys are also numeric. Here numeric keys specifically refer to the numeric strings generated by <code>Math.random().toString()</code>.</p>
<p>The results are similar to those string-key cases: <code>Map</code>s start off as much faster than objects (2 times faster for insertion and deletion, 4-5 times faster for iteration), but the delta is getting smaller as we increase the size.</p>
<p>What about nested objects/maps?</p>
<p>You might have noticed that I have been only talking about flat objects and maps with only one depth. I did add some depth but I found the performance characteristics stay largely the same as long as the total number of entries are the same, no matter how many levels of nesting we have.</p>
<p>For example, with <code>width</code> being 100 and <code>depth</code> being 3, we have a total number of one million entries (100 * 100 * 100). The results are pretty much the same compared to just having <code>1000000</code> for width and 1 for <code>depth</code></p>
<h3 id="memory-usage">Memory usage<a aria-hidden="true" class="anchor-heading icon-link" href="#memory-usage"></a></h3>
<p>Another important facet of benchmarking is memory utilization.</p>
<p>Since I don’t have control over the garbage collector in a browser environment, I decided to run benchmarks in Node.</p>
<p>I created a <a href="https://gist.github.com/zhenghaohe/b496dcffe3a9a6217eba90776dc2cafe">little script</a> to measure their respective memory usage with manually triggered full garbage collection in each measurement. Run it with <code>node --expose-gc</code> and I got the following results:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token punctuation">{</span>
  object<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">'string-key'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'10000'</span><span class="token operator">:</span> <span class="token number">3.390625</span><span class="token punctuation">,</span>
      <span class="token string">'50000'</span><span class="token operator">:</span> <span class="token number">19.765625</span><span class="token punctuation">,</span>
      <span class="token string">'100000'</span><span class="token operator">:</span> <span class="token number">16.265625</span><span class="token punctuation">,</span>
      <span class="token string">'500000'</span><span class="token operator">:</span> <span class="token number">71.265625</span><span class="token punctuation">,</span>
      <span class="token string">'1000000'</span><span class="token operator">:</span> <span class="token number">142.015625</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">'numeric-key'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'10000'</span><span class="token operator">:</span> <span class="token number">1.65625</span><span class="token punctuation">,</span>
      <span class="token string">'50000'</span><span class="token operator">:</span> <span class="token number">8.265625</span><span class="token punctuation">,</span>
      <span class="token string">'100000'</span><span class="token operator">:</span> <span class="token number">16.765625</span><span class="token punctuation">,</span>
      <span class="token string">'500000'</span><span class="token operator">:</span> <span class="token number">72.265625</span><span class="token punctuation">,</span>
      <span class="token string">'1000000'</span><span class="token operator">:</span> <span class="token number">143.515625</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">'integer-key'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'10000'</span><span class="token operator">:</span> <span class="token number">0.25</span><span class="token punctuation">,</span>
      <span class="token string">'50000'</span><span class="token operator">:</span> <span class="token number">2.828125</span><span class="token punctuation">,</span>
      <span class="token string">'100000'</span><span class="token operator">:</span> <span class="token number">4.90625</span><span class="token punctuation">,</span>
      <span class="token string">'500000'</span><span class="token operator">:</span> <span class="token number">25.734375</span><span class="token punctuation">,</span>
      <span class="token string">'1000000'</span><span class="token operator">:</span> <span class="token number">59.203125</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  map<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string">'string-key'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'10000'</span><span class="token operator">:</span> <span class="token number">1.703125</span><span class="token punctuation">,</span>
      <span class="token string">'50000'</span><span class="token operator">:</span> <span class="token number">6.765625</span><span class="token punctuation">,</span>
      <span class="token string">'100000'</span><span class="token operator">:</span> <span class="token number">14.015625</span><span class="token punctuation">,</span>
      <span class="token string">'500000'</span><span class="token operator">:</span> <span class="token number">61.765625</span><span class="token punctuation">,</span>
      <span class="token string">'1000000'</span><span class="token operator">:</span> <span class="token number">122.015625</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">'numeric-key'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'10000'</span><span class="token operator">:</span> <span class="token number">0.703125</span><span class="token punctuation">,</span>
      <span class="token string">'50000'</span><span class="token operator">:</span> <span class="token number">3.765625</span><span class="token punctuation">,</span>
      <span class="token string">'100000'</span><span class="token operator">:</span> <span class="token number">7.265625</span><span class="token punctuation">,</span>
      <span class="token string">'500000'</span><span class="token operator">:</span> <span class="token number">33.265625</span><span class="token punctuation">,</span>
      <span class="token string">'1000000'</span><span class="token operator">:</span> <span class="token number">67.015625</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token string">'integer-key'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token string">'10000'</span><span class="token operator">:</span> <span class="token number">0.484375</span><span class="token punctuation">,</span>
      <span class="token string">'50000'</span><span class="token operator">:</span> <span class="token number">1.890625</span><span class="token punctuation">,</span>
      <span class="token string">'100000'</span><span class="token operator">:</span> <span class="token number">3.765625</span><span class="token punctuation">,</span>
      <span class="token string">'500000'</span><span class="token operator">:</span> <span class="token number">22.515625</span><span class="token punctuation">,</span>
      <span class="token string">'1000000'</span><span class="token operator">:</span> <span class="token number">43.515625</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>It is pretty clear that <code>Map</code> consumes less memory than <code>Object</code> by anywhere from 20% to 50%, which is no surprise since <code>Map</code> doesn't store <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">property descriptors</a> such as <code>writable</code>/<code>enumerable</code>/<code>configurable</code> like <code>Object</code> does.</p>
<h2 id="conclusion">Conclusion<a aria-hidden="true" class="anchor-heading icon-link" href="#conclusion"></a></h2>
<p>So what do we take away from all this?</p>
<ul>
<li><code>Map</code> is faster than <code>Object</code> <em>unless</em> you have small integer, array-indexed keys, and it is more memory-efficient.</li>
<li>Use <code>Map</code> if you need a hash map with frequent updates; use <code>Object</code> if you want to a fixed key-value collection (i.e. record), and watch out for pitfalls that come with prototypal inheritance.</li>
</ul>
<blockquote>
<p>If you know the details of exactly how V8 optimizes <code>Map</code> or simply want to call out the flaws in my benchmarks, ping me. I'll be happy to update this post based on your information!</p>
</blockquote>
<h2 id="notes-on-browser-compatibilityobject-vs-mapnotes-on-browser-compatibility">Notes on browser compatibilityobject-vs-map#notes-on-browser-compatibility)<a aria-hidden="true" class="anchor-heading icon-link" href="#notes-on-browser-compatibilityobject-vs-mapnotes-on-browser-compatibility"></a></h2>
<p><code>Map</code> is an ES6 feature. By now most of us shouldn't be worried about its compatibility unless you are targeting a user-base with some niche, old browser. By "old" I mean older than IE 11 because even IE 11 supports <a href="https://caniuse.com/mdn-javascript_builtins_map">Map</a> and at this point IE 11 is <a href="https://twitter.com/swyx/status/1536353949132853248">dead</a>. We shouldn't mindlessly transpiling and adding polyfill to target ES5 by default, because not only does it bloat your bundle size, but also it is slow to run compared to modern JavaScript. Most importantly, it penalizes 99.999% of your users who use a modern browser.</p>
<p>Plus, we don't have to drop supports for legacy browsers - serve legacy code via <code>nomodule</code> by serving fallback bundles so that we can avoid degrading the experience of visitors with modern browsers. Refer to <a href="https://www.youtube.com/watch?v=cLxNdLK--yI"><em>Transitioning to modern JavaScript</em></a> if you need more convincing.</p>
<p>The JavaScript language is evolving and the platforms keep getting better at optimizing modern JavaScript. We shouldn't use browser compatibility as an excuse to ignore all the improvements that have been made.</p></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#tldr" title="TL;DR:">TL;DR:</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#why-object-falls-short-of-a-hash-map-use-caseobject-vs-mapwhy-object-falls-short-of-a-hash-map-use-case" title="Why Object falls short of a hash-map use caseobject-vs-map#why-object-falls-short-of-a-hash-map-use-case)">Why Object falls short of a hash-map use caseobject-vs-map#why-object-falls-short-of-a-hash-map-use-case)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#unwanted-inheritanceobject-vs-mapunwanted-inheritance" title="unwanted inheritanceobject-vs-map#unwanted-inheritance)">unwanted inheritanceobject-vs-map#unwanted-inheritance)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#name-collisions" title="name collisions">name collisions</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#sub-optimal-ergonomicsobject-vs-mapsub-optimal-ergonomics" title="Sub-optimal ergonomicsobject-vs-map#sub-optimal-ergonomics)">Sub-optimal ergonomicsobject-vs-map#sub-optimal-ergonomics)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#size" title="size">size</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#iterate" title="iterate">iterate</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#clear" title="clear">clear</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#check-property-existenceobject-vs-mapcheck-property-existence" title="check property existenceobject-vs-map#check-property-existence)">check property existenceobject-vs-map#check-property-existence)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#map-for-hash-map" title="Map for Hash Map">Map for Hash Map</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#performance-extravaganzaobject-vs-mapperformance-extravaganza" title="Performance extravaganzaobject-vs-map#performance-extravaganza)">Performance extravaganzaobject-vs-map#performance-extravaganza)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#benchmarking-implementation-detailsobject-vs-mapbenchmarking-implementation-details" title="Benchmarking implementation detailsobject-vs-map#benchmarking-implementation-details)">Benchmarking implementation detailsobject-vs-map#benchmarking-implementation-details)</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#string-keys" title="string keys">string keys</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#integer-keys" title="integer keys">integer keys</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#numeric-keys" title="numeric keys">numeric keys</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#memory-usage" title="Memory usage">Memory usage</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#conclusion" title="Conclusion">Conclusion</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#notes-on-browser-compatibilityobject-vs-mapnotes-on-browser-compatibility" title="Notes on browser compatibilityobject-vs-map#notes-on-browser-compatibility)">Notes on browser compatibilityobject-vs-map#notes-on-browser-compatibility)</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"nibpxpf7rzk5z4xjtx7kfzv","title":"When You Should Prefer Map Over Object In JavaScript","desc":"","updated":1675926935497,"created":1656984898136,"custom":{},"fname":"dev.javascript.language.object-vs-map","type":"note","vault":{"fsPath":"vault"},"contentHash":"94309f57067fe48aadae940f996d165e","links":[],"anchors":{"tldr":{"type":"header","text":"TL;DR:","value":"tldr","line":20,"column":0,"depth":2},"why-object-falls-short-of-a-hash-map-use-caseobject-vs-mapwhy-object-falls-short-of-a-hash-map-use-case":{"type":"header","text":"Why Object falls short of a hash-map use caseobject-vs-map#why-object-falls-short-of-a-hash-map-use-case)","value":"why-object-falls-short-of-a-hash-map-use-caseobject-vs-mapwhy-object-falls-short-of-a-hash-map-use-case","line":26,"column":0,"depth":2},"unwanted-inheritanceobject-vs-mapunwanted-inheritance":{"type":"header","text":"unwanted inheritanceobject-vs-map#unwanted-inheritance)","value":"unwanted-inheritanceobject-vs-mapunwanted-inheritance","line":40,"column":0,"depth":3},"name-collisions":{"type":"header","text":"name collisions","value":"name-collisions","line":56,"column":0,"depth":3},"sub-optimal-ergonomicsobject-vs-mapsub-optimal-ergonomics":{"type":"header","text":"Sub-optimal ergonomicsobject-vs-map#sub-optimal-ergonomics)","value":"sub-optimal-ergonomicsobject-vs-mapsub-optimal-ergonomics","line":89,"column":0,"depth":3},"size":{"type":"header","text":"size","value":"size","line":93,"column":0,"depth":4},"iterate":{"type":"header","text":"iterate","value":"iterate","line":103,"column":0,"depth":4},"clear":{"type":"header","text":"clear","value":"clear","line":135,"column":0,"depth":4},"check-property-existenceobject-vs-mapcheck-property-existence":{"type":"header","text":"check property existenceobject-vs-map#check-property-existence)","value":"check-property-existenceobject-vs-mapcheck-property-existence","line":139,"column":0,"depth":4},"map-for-hash-map":{"type":"header","text":"Map for Hash Map","value":"map-for-hash-map","line":149,"column":0,"depth":2},"performance-extravaganzaobject-vs-mapperformance-extravaganza":{"type":"header","text":"Performance extravaganzaobject-vs-map#performance-extravaganza)","value":"performance-extravaganzaobject-vs-mapperformance-extravaganza","line":172,"column":0,"depth":2},"benchmarking-implementation-detailsobject-vs-mapbenchmarking-implementation-details":{"type":"header","text":"Benchmarking implementation detailsobject-vs-map#benchmarking-implementation-details)","value":"benchmarking-implementation-detailsobject-vs-mapbenchmarking-implementation-details","line":184,"column":0,"depth":3},"string-keys":{"type":"header","text":"string keys","value":"string-keys","line":227,"column":0,"depth":3},"integer-keys":{"type":"header","text":"integer keys","value":"integer-keys","line":255,"column":0,"depth":3},"numeric-keys":{"type":"header","text":"numeric keys","value":"numeric-keys","line":279,"column":0,"depth":3},"memory-usage":{"type":"header","text":"Memory usage","value":"memory-usage","line":293,"column":0,"depth":3},"conclusion":{"type":"header","text":"Conclusion","value":"conclusion","line":354,"column":0,"depth":2},"notes-on-browser-compatibilityobject-vs-mapnotes-on-browser-compatibility":{"type":"header","text":"Notes on browser compatibilityobject-vs-map#notes-on-browser-compatibility)","value":"notes-on-browser-compatibilityobject-vs-mapnotes-on-browser-compatibility","line":363,"column":0,"depth":2}},"children":[],"parent":"mraMGoestTO9V6pkpE8XE","data":{}},"body":"\u003ch1 id=\"when-you-should-prefer-map-over-object-in-javascript\"\u003eWhen You Should Prefer Map Over Object In JavaScript\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#when-you-should-prefer-map-over-object-in-javascript\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://www.zhenghao.io/posts/object-vs-map\"\u003ehttps://www.zhenghao.io/posts/object-vs-map\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ethe missing guide to choosing between Object and Map in JavaScript\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eSee discussions on \u003ca href=\"https://www.reddit.com/r/javascript/comments/vgs7y1/why_you_should_prefer_map_over_object_in/\"\u003ereddit\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn JavaScript, objects are handy. They allow us to easily group multiple pieces of data together. After ES6, we got a new addition to the language - \u003ccode\u003eMap\u003c/code\u003e . In a lot of aspects, it seems like a more capable \u003ccode\u003eObject\u003c/code\u003e with a somewhat clumsy interface. However, most people still reach for objects when they need a \u003ca href=\"https://en.wikipedia.org/wiki/Hash_table\"\u003ehash map\u003c/a\u003e and only switch to using \u003ccode\u003eMap\u003c/code\u003e when they realize the keys can't just be strings for their use cases. As a result, \u003ccode\u003eMap\u003c/code\u003e remains \u003cstrong\u003eunderused\u003c/strong\u003e in today's JavaScript community.\u003c/p\u003e\n\u003cp\u003eIn this post, I will break down all the reasons when you should consider using \u003ccode\u003eMap\u003c/code\u003e more and its performance characteristics with benchmarks.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn JavaScript, Object is a pretty broad term. Almost everything can be an object, except for two bottom types - \u003ccode\u003enull\u003c/code\u003e and \u003ccode\u003eundefined\u003c/code\u003e. In this blog post, Object only refers to plain old objects, delimited by a left brace \u003ccode\u003e{\u003c/code\u003e and a right brace \u003ccode\u003e}\u003c/code\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"tldr\"\u003eTL;DR:\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#tldr\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eUse \u003ccode\u003eObject\u003c/code\u003e for records where you have a fixed and finite number of properties/fields known at author time, such as a config object. And anything that is for one-time use in general.\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003eMap\u003c/code\u003e for dictionaries or hash maps where you have a variable number of entries, with frequent updates, whose keys might not be known at author time, such as an \u003ca href=\"https://github.com/developit/mitt/blob/main/src/index.ts#L45\"\u003eevent emitter\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eAccording to \u003ca href=\"https://www.zhenghao.io/posts/object-vs-map#performance-extravaganza\"\u003emy benchmarks\u003c/a\u003e, \u003cem\u003eunless\u003c/em\u003e the keys are strings of small integers, \u003ccode\u003eMap\u003c/code\u003e is indeed \u003cstrong\u003emore performant\u003c/strong\u003e than \u003ccode\u003eObject\u003c/code\u003e on insertion, deletion and iteration speed, and it consumes \u003cstrong\u003eless memory\u003c/strong\u003e than \u003ccode\u003eObject\u003c/code\u003e of the same size.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"why-object-falls-short-of-a-hash-map-use-caseobject-vs-mapwhy-object-falls-short-of-a-hash-map-use-case\"\u003eWhy Object falls short of a hash-map use caseobject-vs-map#why-object-falls-short-of-a-hash-map-use-case)\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#why-object-falls-short-of-a-hash-map-use-caseobject-vs-mapwhy-object-falls-short-of-a-hash-map-use-case\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eProbably the most obvious downside of using objects for hash maps is that objects only allow keys that are strings and symbols. Any other types will be implicitly cast to string via the \u003ccode\u003etoString\u003c/code\u003e methods.\u003c/p\u003e\n\u003cpre class=\"language-jsx\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e foo \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e bar \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e obj \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003efoo\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"foo\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ebar\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"bar\"\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token console class-name\"\u003econsole\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003elog\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eobj\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token comment\"\u003e// {\"\": 'foo', [object Object]: 'bar'}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMore importantly, using objects for hash maps can cause confusion and \u003cem\u003esecurity hazards\u003c/em\u003e.\u003c/p\u003e\n\u003ch3 id=\"unwanted-inheritanceobject-vs-mapunwanted-inheritance\"\u003eunwanted inheritanceobject-vs-map#unwanted-inheritance)\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#unwanted-inheritanceobject-vs-mapunwanted-inheritance\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eBefore ES6, the only way to get a hash map is by creating an empty object.\u003c/p\u003e\n\u003cpre class=\"language-jsx\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e hashMap \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever, upon creation, this object is no longer empty. Although \u003ccode\u003ehashMap\u003c/code\u003e is made with an empty object literal, it automatically inherits from \u003ccode\u003eObject.prototype\u003c/code\u003e . That's why we can invoke methods like \u003ccode\u003ehasOwnProperty\u003c/code\u003e , \u003ccode\u003etoString\u003c/code\u003e , \u003ccode\u003econstructor\u003c/code\u003e on \u003ccode\u003ehashMap\u003c/code\u003e even when we never explicitly define those methods on the object.\u003c/p\u003e\n\u003cp\u003eBecause of prototypal inheritance, we now have two types of properties conflated: properties that live within the object itself, i.e. its \u003cem\u003eown\u003c/em\u003e properties, and properties that live in the prototype chain, i.e. \u003cem\u003einherited\u003c/em\u003e properties. As a result, we need an additional check (e.g. \u003ccode\u003ehasOwnProperty\u003c/code\u003e) to make sure a given property is indeed user-provided, as opposed to inherited from the prototype.\u003c/p\u003e\n\u003cp\u003eOn top of that, because of how the property resolution mechanism works in JavaScript, any change to \u003ccode\u003eObject.prototype\u003c/code\u003e at runtime will cause a \u003cem\u003eripple\u003c/em\u003e effect in all objects. This opens the door for \u003ca href=\"https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf\"\u003eprototype pollution attack\u003c/a\u003e, which can be a serious security issue for large JavaScript applications.\u003c/p\u003e\n\u003cp\u003eFortunately, we can work around this by using \u003ccode\u003eObject.create(null)\u003c/code\u003e, which makes an object that inherits nothing from \u003ccode\u003eObject.prototype\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"name-collisions\"\u003ename collisions\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#name-collisions\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWhen an object’s \u003cem\u003eown\u003c/em\u003e properties have name collisions with ones on its prototype, it breaks expectations and thus crashes your program.\u003c/p\u003e\n\u003cp\u003eFor example, we have a function \u003ccode\u003efoo\u003c/code\u003e which accepts an object:\u003c/p\u003e\n\u003cpre class=\"language-jsx\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"token keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"token function\"\u003efoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token parameter\"\u003eobj\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e//...\u003c/span\u003e\n  \u003cspan class=\"token keyword control-flow\"\u003efor\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e key \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e obj\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword control-flow\"\u003eif\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eobj\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003ehasOwnProperty\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ekey\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere is a reliability hazard in \u003ccode\u003eobj.hasOwnProperty(key)\u003c/code\u003e: given how property resolution mechanism works in JavaScript, if \u003ccode\u003eobj\u003c/code\u003e contains a user-provided property with the same name \u003ccode\u003ehasOwnProperty\u003c/code\u003e , that shadows \u003ccode\u003eObject.prototype.hasOwnProperty\u003c/code\u003e. As a result, we \u003cem\u003edon’t know\u003c/em\u003e which method is going to get called exactly during runtime.\u003c/p\u003e\n\u003cp\u003eSome defensive programming can be done to prevent this. For example we can “borrow” the \"real\" \u003ccode\u003ehasOwnProperty\u003c/code\u003e from \u003ccode\u003eObject.prototype\u003c/code\u003e instead:\u003c/p\u003e\n\u003cpre class=\"language-jsx\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"token keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"token function\"\u003efoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token parameter\"\u003eobj\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e//...\u003c/span\u003e\n  \u003cspan class=\"token keyword control-flow\"\u003efor\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e key \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e obj\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword control-flow\"\u003eif\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eObject\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token property-access\"\u003eprototype\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003ehasOwnProperty\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003ecall\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eobj\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e key\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA shorter way might be invoking the method on an object literal as in \u003ccode\u003e{}.hasOwnProperty.call(key)\u003c/code\u003e however it is still pretty cumbersome. That's why there is a newly-added static method \u003ccode\u003eObject.hasOwn\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"sub-optimal-ergonomicsobject-vs-mapsub-optimal-ergonomics\"\u003eSub-optimal ergonomicsobject-vs-map#sub-optimal-ergonomics)\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#sub-optimal-ergonomicsobject-vs-mapsub-optimal-ergonomics\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eObject\u003c/code\u003e doesn't provide adequate ergonomics to be used as a hash map. Many common tasks can't be intuitively performed.\u003c/p\u003e\n\u003ch4 id=\"size\"\u003esize\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#size\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003eObject\u003c/code\u003e doesn't come with a handy API to get the size, i.e. the number of properties. And there are nuances to what constitutes the size of an object:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eif you only care about string, enumerable keys, then you can convert the keys to an array with \u003ccode\u003eObject.keys()\u003c/code\u003e and get its \u003ccode\u003elength\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eif you want to account for \u003cem\u003enon-enumerable\u003c/em\u003e string keys, then you have to use \u003ccode\u003eObject.getOwnPropertyNames\u003c/code\u003e to get a list of the keys and get its length.\u003c/li\u003e\n\u003cli\u003eif you are interested in symbol keys, you can use \u003ccode\u003egetOwnPropertySymbols\u003c/code\u003e to reveal the symbol keys. Or you can use \u003ccode\u003eReflect.ownKeys\u003c/code\u003e to get both string keys and symbol keys all at once, regardless if it is enumerable or not.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAll the above options take a runtime complexity of \u003ccode\u003eO(n)\u003c/code\u003e since we have to construct an array of keys first before we can get its length.\u003c/p\u003e\n\u003ch4 id=\"iterate\"\u003eiterate\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#iterate\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eLooping through objects suffers from similar complexity.\u003c/p\u003e\n\u003cp\u003eWe can use the good old \u003ccode\u003efor...in\u003c/code\u003e loop. But it reveals inherited enumerable properties:\u003c/p\u003e\n\u003cpre class=\"language-jsx\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"token class-name\"\u003eObject\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token property-access\"\u003eprototype\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token property-access\"\u003efoo\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"bar\"\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e obj \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e id\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token keyword control-flow\"\u003efor\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e key \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e obj\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token console class-name\"\u003econsole\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003elog\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ekey\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token comment\"\u003e// 'id', 'foo'\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe couldn't use \u003ccode\u003efor...of\u003c/code\u003e with an object since by default it is not an iterable, unless we explicitly defines the \u003ccode\u003eSymbol.iterator\u003c/code\u003e method on it.\u003c/p\u003e\n\u003cp\u003eWe can use \u003ccode\u003eObject.keys\u003c/code\u003e , \u003ccode\u003eObject.values\u003c/code\u003e and \u003ccode\u003eObject.entries\u003c/code\u003e to get a list of enumerable, string keys (or/and values) and iterate through that instead, which introduces an extra step with overhead.\u003c/p\u003e\n\u003cp\u003eFinally, the insertion order is infamously not \u003cem\u003efully\u003c/em\u003e respected. In most browsers, integer keys are sorted in ascending order and take precedence over string keys even if the string keys are inserted before the integer keys.\u003c/p\u003e\n\u003cpre class=\"language-jsx\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e obj \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\nobj\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token property-access\"\u003efoo\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"first\"\u003c/span\u003e\nobj\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token number\"\u003e2\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"second\"\u003c/span\u003e\nobj\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"last\"\u003c/span\u003e\n\n\u003cspan class=\"token console class-name\"\u003econsole\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003elog\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eobj\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token comment\"\u003e// {1: 'last', 2: 'second', foo: 'first'}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4 id=\"clear\"\u003eclear\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#clear\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eThere is no easy way to remove all properties from an object, you have to delete each property one by one with the \u003ccode\u003edelete\u003c/code\u003e operator, which \u003ca href=\"https://stackoverflow.com/questions/43594092/slow-delete-of-object-properties-in-js-in-v8\"\u003ehas been known\u003c/a\u003e to be slow historically. However my benchmarks show that its performance is actually not an order-of-magnitude slower than \u003ccode\u003eMap.prototype.delete\u003c/code\u003e. More on that later.\u003c/p\u003e\n\u003ch4 id=\"check-property-existenceobject-vs-mapcheck-property-existence\"\u003echeck property existenceobject-vs-map#check-property-existence)\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#check-property-existenceobject-vs-mapcheck-property-existence\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eFinally, we can't rely on the dot/bracket notation to check for existence of an property because the value itself could be set as \u003ccode\u003eundefined\u003c/code\u003e. Instead we have to use \u003ccode\u003eObject.prototype.hasOwnProperty\u003c/code\u003e or \u003ccode\u003eObject.hasOwn\u003c/code\u003e.\u003c/p\u003e\n\u003cpre class=\"language-jsx\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e obj \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e a\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token keyword nil\"\u003eundefined\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token known-class-name class-name\"\u003eObject\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003ehasOwn\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eobj\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"a\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"map-for-hash-map\"\u003eMap for Hash Map\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#map-for-hash-map\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eES6 brought Map. It is much more suited for a hash-map use case.\u003c/p\u003e\n\u003cp\u003eFirst of all, unlike \u003ccode\u003eObject\u003c/code\u003e, which only allows keys that are strings and symbols, \u003ccode\u003eMap\u003c/code\u003e supports keys of any data types.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHowever if you are using \u003ccode\u003eMap\u003c/code\u003e to store meta-data for objects, then you should use \u003ccode\u003eWeakMap\u003c/code\u003e instead to avoid memory leak.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eBut more importantly, \u003ccode\u003eMap\u003c/code\u003e provides a \u003cem\u003eclean separation\u003c/em\u003e between user-defined and built-in program data, at the expense of an additional \u003ccode\u003eMap.prototype.get\u003c/code\u003e to retrieve entries.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eMap\u003c/code\u003e also provides better ergonomics: A \u003ccode\u003eMap\u003c/code\u003e is an iterable by default. That means you can iterate a map easily with \u003ccode\u003efor...of\u003c/code\u003e, and do things like using nested destructuring to pull out the first entry from a map.\u003c/p\u003e\n\u003cpre class=\"language-jsx\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003efirstKey\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e firstValue\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e map\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn contrast to \u003ccode\u003eObject\u003c/code\u003e, \u003ccode\u003eMap\u003c/code\u003e provides dedicated APIs for various common tasks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eMap.prototype.has\u003c/code\u003e checks for the existence of a given entry, less awkward compared to having to \u003ccode\u003eObject.prototype.hasOwnProperty\u003c/code\u003e / \u003ccode\u003eObject.hasOwn\u003c/code\u003e on objects\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMap.prototype.get\u003c/code\u003e returns the value associated to the provided key. One might feel this is clunkier than the dot notation or the bracket notation on objects. Nevertheless it provides a clean separation between user data and built-in method.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMap.prototype.size\u003c/code\u003e returns the number of entries in a \u003ccode\u003eMap\u003c/code\u003e and it is a clear winner over the maneuvers you have to perform to get an object's size. Besides, it is much faster.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMap.prototype.clear\u003c/code\u003e removes all the entries in a \u003ccode\u003eMap\u003c/code\u003e and it much faster than the \u003ccode\u003edelete\u003c/code\u003e operator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"performance-extravaganzaobject-vs-mapperformance-extravaganza\"\u003ePerformance extravaganzaobject-vs-map#performance-extravaganza)\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#performance-extravaganzaobject-vs-mapperformance-extravaganza\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThere seems to be a common belief among JavaScript community that \u003ccode\u003eMap\u003c/code\u003e is faster than \u003ccode\u003eObject\u003c/code\u003e, for the most part. There are \u003ca href=\"https://twitter.com/diegohaz/status/1534888291732013058\"\u003epeople\u003c/a\u003e who claimed to see noticeable performance gains by switching from \u003ccode\u003eObject\u003c/code\u003e to \u003ccode\u003eMap\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eMy experience of grinding Leetcode seems to confirm this belief: Leetcode feeds a huge amount of data as the test cases to your solution and it times out if your solution is taking too long. Questions like \u003ca href=\"https://leetcode.com/problems/random-pick-with-weight/discuss/671804/Javascript-with-explanation-and-very-interesting-find-regarding-vs-Map\"\u003ethis one\u003c/a\u003e only times out if you use \u003ccode\u003eObject\u003c/code\u003e, but not on \u003ccode\u003eMap\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, I believe just saying \"\u003ccode\u003eMap\u003c/code\u003e is faster than Object\" is reductive. There must be some nuance that I wanted to find out myself. Therefore. I built \u003ca href=\"https://csb-yuu1dm.netlify.app/\"\u003ea little app\u003c/a\u003e to run some benchmarks.\u003c/p\u003e\n\u003cp\u003eImportant Disclaimer\u003c/p\u003e\n\u003cp\u003eI would never claim that I fully understand how V8 works under the hood to optimize \u003ccode\u003eMap\u003c/code\u003e despite my many attempts to read blog posts and peek the C++ source code. Perfectly robust benchmarking is hard, and most of us never went through any form of training in either benchmarking or interpreting the results. The more benchmarking I do the more it felt like a story about \u003ca href=\"https://en.wikipedia.org/wiki/Blind_men_and_an_elephant\"\u003eblind men and an elephant\u003c/a\u003e. So take everything I said here about performance a grain of salt. You'll need to test such changes with your application in a production environment to know for sure if there are actual performance gains from using \u003ccode\u003eMap\u003c/code\u003es over objects.\u003c/p\u003e\n\u003ch3 id=\"benchmarking-implementation-detailsobject-vs-mapbenchmarking-implementation-details\"\u003eBenchmarking implementation detailsobject-vs-map#benchmarking-implementation-details)\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#benchmarking-implementation-detailsobject-vs-mapbenchmarking-implementation-details\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://csb-yuu1dm.netlify.app/\"\u003eThe app\u003c/a\u003e has a table that shows the insertion, iteration, and deletion speed measured on \u003ccode\u003eObject\u003c/code\u003e and \u003ccode\u003eMap\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe performances of insertion and iteration are measured in operations per second. I wrote an util function \u003ccode\u003emeasureFor\u003c/code\u003e that runs the target function repeatedly until the specified minimal amount of time threshold (i.e. the \u003ccode\u003eduration\u003c/code\u003e input field on the UI) has been reached. It returns the average number of times such a function is executed per second.\u003c/p\u003e\n\u003cpre class=\"language-jsx\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"token keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"token function\"\u003emeasureFor\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token parameter\"\u003ef\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e duration\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e iterations \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e now \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token dom variable\"\u003eperformance\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003enow\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e elapsed \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\n  \u003cspan class=\"token keyword control-flow\"\u003ewhile\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eelapsed \u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003e duration\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token function\"\u003ef\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    elapsed \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token dom variable\"\u003eperformance\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003enow\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e now\n    iterations\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"token keyword control-flow\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eiterations \u003cspan class=\"token operator\"\u003e/\u003c/span\u003e elapsed\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e*\u003c/span\u003e \u003cspan class=\"token number\"\u003e1000\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003etoFixed\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e4\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs to deletion, I am simply going to measure the time taken for using the \u003ccode\u003edelete\u003c/code\u003e operator to remove all properties from an objects and compare it with the time with \u003ccode\u003eMap.prototype.delete\u003c/code\u003e for a Map of the same size. I could use \u003ccode\u003eMap.prototype.clear\u003c/code\u003e but it defeats the purpose of the benchmarks as I know for sure it is going to be vastly faster.\u003c/p\u003e\n\u003cp\u003eIn these three operations, I pay more attention to insertion since it tends to be the most common operation I perform in my day-to-day work. For iteration performance, it is hard to come up with an all-encompassing benchmarks as there are many different variants of iteration we can perform on a given object. Here I am only measuring the \u003ccode\u003efor ... in\u003c/code\u003e loop.\u003c/p\u003e\n\u003cp\u003eI used three types of keys here:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003estrings, e.g. \u003ccode\u003eyekwl7caqejth7aawelo4\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003einteger strings, e.g. \u003ccode\u003e123\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003enumeric strings generated by \u003ccode\u003eMath.random().toString()\u003c/code\u003e, e.g. \u003ccode\u003e0.4024025689756525\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eAll keys are randomly generated so we don’t hit the inline-cache implemented by V8. I also explicitly convert integer and numeric keys to strings using \u003ccode\u003etoString\u003c/code\u003e before adding them to objects to avoid the overhead of implicitly casting.\u003c/p\u003e\n\u003cp\u003eLastly, before the benchmark begins, there is also a warmup phase for at least 100ms where we repeatedly create new objects and maps that are discarded right away.\u003c/p\u003e\n\u003cp\u003eI put the code on \u003ca href=\"https://codesandbox.io/s/still-glitter-yuu1dm\"\u003eCodesandbox\u003c/a\u003e if you want to play with it.\u003c/p\u003e\n\u003cp\u003eI started with \u003ccode\u003eObject\u003c/code\u003e and \u003ccode\u003eMap\u003c/code\u003e with a size of 100 properties/entries, all the way to 5000000, and had each type of operations keep running for 10000ms to see how they performed against each other. Here are my findings...\u003c/p\u003e\n\u003cp\u003eWhy do we stop when the number of entries reaches 5000000?\u003c/p\u003e\n\u003cp\u003eBecause this is about as big as an object can get in JavaScript. According to \u003ca href=\"https://stackoverflow.com/questions/54452896/maximum-number-of-entries-in-node-js-map#comment127492362_72149605\"\u003e@jmrk\u003c/a\u003e, a V8 engineer who is active on Stackoverflow, “if the keys are strings, a regular object becomes unusably slow after ~8.3M elements (for which there is a technical reason: a certain bit field being 23 bits wide and taking a very slow fallback path when exceeded).”.\u003c/p\u003e\n\u003ch3 id=\"string-keys\"\u003estring keys\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#string-keys\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eGenerally speaking, when keys are (non-numeric) string, \u003ccode\u003eMap\u003c/code\u003e outperforms \u003ccode\u003eObject\u003c/code\u003e on all operations.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/art/blog/object-vs-map/deletion-speed.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003eBut the nuance is that when the number of entries is not really huge (under 100000), \u003ccode\u003eMap\u003c/code\u003e is twice as fast as \u003ccode\u003eObject\u003c/code\u003e on insertion speed, but as the size grows over 100000, the performance gap starts to shrink.\u003c/p\u003e\n\u003cp\u003eI made some graphs to better illustrate my findings.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/art/blog/object-vs-map/string-key-line-1.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003eThe above graph shows how insertion rate drops (y-axis) with the number of entries increasing (x-axis). However because the X-axis expands too wide (from 100 to 1000000), it is hard to tell the gap between these two lines.\u003c/p\u003e\n\u003cp\u003eI then used log scales to process the data and made the graph below.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/art/blog/object-vs-map/string-key-line-2.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003eYou can clearly tell the two lines are converging.\u003c/p\u003e\n\u003cp\u003eI made another graph plotting how much faster \u003ccode\u003eMap\u003c/code\u003e is in relation to \u003ccode\u003eObject\u003c/code\u003e on insertion speed. You can see \u003ccode\u003eMap\u003c/code\u003e starts out being about 2 times faster than \u003ccode\u003eObject\u003c/code\u003e. Then over time the performance gap starts to shrink. Eventually \u003ccode\u003eMap\u003c/code\u003e is only 30% faster as the size grows to 5000000.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/art/blog/object-vs-map/string-key-line-3.png\" alt=\"alt\"\u003e\u003c/p\u003e\n\u003cp\u003eMost of us will never have more than 1 million entries in an object or map though. With a size of a few hundreds or thousands of entries, \u003ccode\u003eMap\u003c/code\u003e is at least twice as performant as \u003ccode\u003eObject\u003c/code\u003e. Therefore, should we leave it at that and head over to start refactoring our codebase by going all in on \u003ccode\u003eMap\u003c/code\u003e?\u003c/p\u003e\n\u003cp\u003eAbsolutely not… or at least not with an expectation that our app becomes 2 times faster. Remember we haven't explored other types of keys. Let's take a look at integer keys.\u003c/p\u003e\n\u003ch3 id=\"integer-keys\"\u003einteger keys\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#integer-keys\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe reason I specifically want to run benchmarks on objects with integer keys is that V8 internally optimizes \u003ca href=\"https://v8.dev/blog/fast-properties#named-properties-vs.-elements\"\u003einteger-indexed properties\u003c/a\u003e and store them in a separate array that can be accessed linearly and consecutively. I can’t find any resources confirming it employs the same kind of optimization for \u003ccode\u003eMap\u003c/code\u003es though.\u003c/p\u003e\n\u003cp\u003eLet’s first try integer keys in the range of [0, 1000].\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/art/blog/object-vs-map/integer-key-1.png\" alt=\"Untitled\"\u003e\u003c/p\u003e\n\u003cp\u003eAs I expected, \u003ccode\u003eObject\u003c/code\u003e \u003cstrong\u003eoutperform\u003c/strong\u003e \u003ccode\u003eMap\u003c/code\u003e this time. They are 65% faster than maps for insertion speed and 16% faster to iterate.\u003c/p\u003e\n\u003cp\u003eLet's widen the range so that the maximum integer in the keys is 1200.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/art/blog/object-vs-map/integer-key-2.png\" alt=\"Untitled\"\u003e\u003c/p\u003e\n\u003cp\u003eIt seems like now \u003ccode\u003eMap\u003c/code\u003e s start to get a little faster than objects for insertion and 5 times faster for iteration.\u003c/p\u003e\n\u003cp\u003eNow that we only increased the integer keys' range, not the actual size of \u003ccode\u003eObject\u003c/code\u003e and \u003ccode\u003eMap\u003c/code\u003e. Let's bump up the size to see how that affects the performances.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/art/blog/object-vs-map/integer-key-3.png\" alt=\"Untitled\"\u003e\u003c/p\u003e\n\u003cp\u003eWhen a size of 1000 properties, \u003ccode\u003eObject\u003c/code\u003e ends up being 70% faster than \u003ccode\u003eMap\u003c/code\u003e for insertion and 2 times slower for iteration.\u003c/p\u003e\n\u003cp\u003eI played with a bunch of different combinations of \u003ccode\u003eObject\u003c/code\u003e/\u003ccode\u003eMap\u003c/code\u003e sizes and integer key ranges and failed to come up with a clear pattern. But the general trend I am seeing is that, for as the size grows, with some relative small integer being the keys, objects can be \u003cem\u003emore performant\u003c/em\u003e than \u003ccode\u003eMap\u003c/code\u003es in terms of insertion, always roughly the same as to deletion and 4 or 5 times slower to iterate. The threshold of max integer keys at which objects start to be slower for insertion grows with the size of the objects. For example, when the object only has 100 entries, the threshold is 1200; when it has 10000 entries, the threshold seems to be around 24000.\u003c/p\u003e\n\u003ch3 id=\"numeric-keys\"\u003enumeric keys\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#numeric-keys\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLastly, let's take a look at the last type of keys - numeric keys.\u003c/p\u003e\n\u003cp\u003eTechnically, the previously integer keys are also numeric. Here numeric keys specifically refer to the numeric strings generated by \u003ccode\u003eMath.random().toString()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe results are similar to those string-key cases: \u003ccode\u003eMap\u003c/code\u003es start off as much faster than objects (2 times faster for insertion and deletion, 4-5 times faster for iteration), but the delta is getting smaller as we increase the size.\u003c/p\u003e\n\u003cp\u003eWhat about nested objects/maps?\u003c/p\u003e\n\u003cp\u003eYou might have noticed that I have been only talking about flat objects and maps with only one depth. I did add some depth but I found the performance characteristics stay largely the same as long as the total number of entries are the same, no matter how many levels of nesting we have.\u003c/p\u003e\n\u003cp\u003eFor example, with \u003ccode\u003ewidth\u003c/code\u003e being 100 and \u003ccode\u003edepth\u003c/code\u003e being 3, we have a total number of one million entries (100 * 100 * 100). The results are pretty much the same compared to just having \u003ccode\u003e1000000\u003c/code\u003e for width and 1 for \u003ccode\u003edepth\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"memory-usage\"\u003eMemory usage\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#memory-usage\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAnother important facet of benchmarking is memory utilization.\u003c/p\u003e\n\u003cp\u003eSince I don’t have control over the garbage collector in a browser environment, I decided to run benchmarks in Node.\u003c/p\u003e\n\u003cp\u003eI created a \u003ca href=\"https://gist.github.com/zhenghaohe/b496dcffe3a9a6217eba90776dc2cafe\"\u003elittle script\u003c/a\u003e to measure their respective memory usage with manually triggered full garbage collection in each measurement. Run it with \u003ccode\u003enode --expose-gc\u003c/code\u003e and I got the following results:\u003c/p\u003e\n\u003cpre class=\"language-jsx\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  object\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token string\"\u003e'string-key'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'10000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e3.390625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'50000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e19.765625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'100000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e16.265625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'500000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e71.265625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'1000000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e142.015625\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"token string\"\u003e'numeric-key'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'10000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e1.65625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'50000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e8.265625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'100000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e16.765625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'500000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e72.265625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'1000000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e143.515625\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"token string\"\u003e'integer-key'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'10000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e0.25\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'50000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e2.828125\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'100000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e4.90625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'500000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e25.734375\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'1000000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e59.203125\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  map\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token string\"\u003e'string-key'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'10000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e1.703125\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'50000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e6.765625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'100000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e14.015625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'500000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e61.765625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'1000000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e122.015625\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"token string\"\u003e'numeric-key'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'10000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e0.703125\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'50000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e3.765625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'100000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e7.265625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'500000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e33.265625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'1000000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e67.015625\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"token string\"\u003e'integer-key'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'10000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e0.484375\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'50000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e1.890625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'100000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e3.765625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'500000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e22.515625\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e'1000000'\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e43.515625\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is pretty clear that \u003ccode\u003eMap\u003c/code\u003e consumes less memory than \u003ccode\u003eObject\u003c/code\u003e by anywhere from 20% to 50%, which is no surprise since \u003ccode\u003eMap\u003c/code\u003e doesn't store \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\"\u003eproperty descriptors\u003c/a\u003e such as \u003ccode\u003ewritable\u003c/code\u003e/\u003ccode\u003eenumerable\u003c/code\u003e/\u003ccode\u003econfigurable\u003c/code\u003e like \u003ccode\u003eObject\u003c/code\u003e does.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#conclusion\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSo what do we take away from all this?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eMap\u003c/code\u003e is faster than \u003ccode\u003eObject\u003c/code\u003e \u003cem\u003eunless\u003c/em\u003e you have small integer, array-indexed keys, and it is more memory-efficient.\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003eMap\u003c/code\u003e if you need a hash map with frequent updates; use \u003ccode\u003eObject\u003c/code\u003e if you want to a fixed key-value collection (i.e. record), and watch out for pitfalls that come with prototypal inheritance.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf you know the details of exactly how V8 optimizes \u003ccode\u003eMap\u003c/code\u003e or simply want to call out the flaws in my benchmarks, ping me. I'll be happy to update this post based on your information!\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"notes-on-browser-compatibilityobject-vs-mapnotes-on-browser-compatibility\"\u003eNotes on browser compatibilityobject-vs-map#notes-on-browser-compatibility)\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#notes-on-browser-compatibilityobject-vs-mapnotes-on-browser-compatibility\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eMap\u003c/code\u003e is an ES6 feature. By now most of us shouldn't be worried about its compatibility unless you are targeting a user-base with some niche, old browser. By \"old\" I mean older than IE 11 because even IE 11 supports \u003ca href=\"https://caniuse.com/mdn-javascript_builtins_map\"\u003eMap\u003c/a\u003e and at this point IE 11 is \u003ca href=\"https://twitter.com/swyx/status/1536353949132853248\"\u003edead\u003c/a\u003e. We shouldn't mindlessly transpiling and adding polyfill to target ES5 by default, because not only does it bloat your bundle size, but also it is slow to run compared to modern JavaScript. Most importantly, it penalizes 99.999% of your users who use a modern browser.\u003c/p\u003e\n\u003cp\u003ePlus, we don't have to drop supports for legacy browsers - serve legacy code via \u003ccode\u003enomodule\u003c/code\u003e by serving fallback bundles so that we can avoid degrading the experience of visitors with modern browsers. Refer to \u003ca href=\"https://www.youtube.com/watch?v=cLxNdLK--yI\"\u003e\u003cem\u003eTransitioning to modern JavaScript\u003c/em\u003e\u003c/a\u003e if you need more convincing.\u003c/p\u003e\n\u003cp\u003eThe JavaScript language is evolving and the platforms keep getting better at optimizing modern JavaScript. We shouldn't use browser compatibility as an excuse to ignore all the improvements that have been made.\u003c/p\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"nibpxpf7rzk5z4xjtx7kfzv"},"buildId":"vOE8u-mg___OsOsz4tjEg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>