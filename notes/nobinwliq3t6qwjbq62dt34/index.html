<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Vibe Coding as a Coding Veteran</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Vibe Coding as a Coding Veteran"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/nobinwliq3t6qwjbq62dt34/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="9/3/2025"/><meta property="article:modified_time" content="9/3/2025"/><link rel="canonical" href="https://luke-snaw.github.io//notes/nobinwliq3t6qwjbq62dt34/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/wirstT2ztC8OQsbzKjhvw/_buildManifest.js" defer=""></script><script src="/_next/static/wirstT2ztC8OQsbzKjhvw/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="vibe-coding-as-a-coding-veteran">Vibe Coding as a Coding Veteran<a aria-hidden="true" class="anchor-heading icon-link" href="#vibe-coding-as-a-coding-veteran"></a></h1>
<blockquote>
<p><a href="https://levelup.gitconnected.com/vibe-coding-as-a-coding-veteran-cd370fe2be50">https://levelup.gitconnected.com/vibe-coding-as-a-coding-veteran-cd370fe2be50</a></p>
</blockquote>
<ul>
<li>This article records the actual experience of "Coding with AI" by a developer with 40 years of experience, who undertook a <strong>2-week project with an AI coding assistant</strong>.</li>
<li>The results showed advantages such as <strong>increased productivity (up to 2x)</strong>, <strong>surprising accuracy, and creative validation</strong>, alongside disadvantages like <strong>20% erroneous/incomplete code</strong> and <strong>excessive industrial complexity</strong>.</li>
<li>The author describes the interaction with AI as a psychological experience that fosters <strong>flow</strong> and <strong>learning effects</strong> while also creating a <strong>tension between trust and control</strong>.</li>
<li>In conclusion, AI coding is likened to a <strong>powerful companion yet a dangerous bicycle</strong>, presented as a <strong>new collaborative paradigm</strong> that experienced developers must proactively manage.</li>
</ul>
<hr>
<blockquote>
<p><a href="https://news.hada.io/topic?id=22880">https://news.hada.io/topic?id=22880</a></p>
</blockquote>
<ul>
<li>40년 경력의 개발자가 <strong>AI 코딩 어시스턴트와 함께 2주간 프로젝트</strong>를 진행하며 <strong>바이브 코딩</strong>의 실제 경험을 기록한 글임</li>
<li><strong>Tower of Hanoi 퍼즐 솔버</strong>를 구현하는 과정에서 300여 차례 대화를 통해 코드 전체를 AI가 생성하고, 인간은 검토와 방향 제시에 집중하는 방식 사용</li>
<li>결과는 <strong>빠른 생산성(최대 2배)</strong>, <strong>놀라운 정확성과 창의적 증명</strong> 같은 장점과 함께, <strong>20%의 오류·불완전 코드</strong> 및 <strong>산업용 과도한 복잡성</strong> 같은 단점도 공존함</li>
<li>저자는 AI와의 대화가 <strong>몰입(flow)</strong> 과 <strong>학습 효과</strong>를 주는 동시에, <strong>신뢰와 통제의 긴장</strong>을 유발하는 심리적 경험이라고 평가함</li>
<li>결론적으로 AI 코딩은 <strong>강력한 동반자이자 위험한 자전거</strong>에 비유되며, 경험 많은 개발자가 주도적으로 다뤄야 할 <strong>새로운 협업 패러다임</strong>으로 제시됨</li>
</ul>
<hr>
<h2 id="서문--vibe-coding">서문 — Vibe coding<a aria-hidden="true" class="anchor-heading icon-link" href="#서문--vibe-coding"></a></h2>
<ul>
<li>
<p><strong>Vibe coding</strong>은 <strong>LLM 기반 AI 에이전트</strong>가 <strong>작성·리팩터링·디버깅</strong>을 맡고 나는 <strong>무엇을 만들지</strong>에 집중하는 개발 방식</p>
</li>
<li>
<p>코딩은 나와 AI가 <strong>동시 협업</strong>으로 진행되거나 아예 <strong>AI에 전면 위임</strong>되는 구조</p>
</li>
<li>
<p>나는 이 방식을 <strong>흥미와 두려움</strong>이 공존하는 변화로 느끼며, <strong>프로그래밍의 예술성</strong>이 <strong>지능형 로봇의 조립 라인</strong>으로 바뀌는지 질문함</p>
</li>
<li>
<p>검증을 위해 <strong>2주</strong> 동안 총 <strong>40시간</strong>을 들여 <strong>최신 코딩 어시스턴트</strong>와 소규모 프로젝트 협업해 봄</p>
</li>
<li>
<p>프로젝트는 <strong>Python 약 5k LOC·50개 파일·20개 클래스</strong> 규모, <strong>교과서적 AI 탐색 알고리듬</strong>으로 <strong>전형적 퍼즐</strong>을 푸는 자기지시적 실험</p>
</li>
<li>
<p>결과물은 <strong><a href="https://github.com/mabene/vibe">코드 저장소</a>와 문서</strong> 형태로 공개, 글은 <strong>무엇을 했고 이해했고 배웠고 느꼈는지</strong>에 대한 기록임</p>
</li>
<li>
<p>나는 80년대에 8비트 머신에서 어셈블리로 시작해 <strong>40년의 코딩 경력</strong>을 가졌고, <strong>20여 개 언어를 사용</strong>해 봤음</p>
</li>
<li>
<p><strong>과학·모바일·업무용 소프트웨어</strong>를 <strong>개인·팀 단위</strong>로 개발한 경험이 있음</p>
</li>
<li>
<p>또한 <strong>(LLM 이전 시대의) AI 박사 학위</strong>를 보유함</p>
</li>
<li>
<p><strong>“AI 하는 사람이 AI 어시스턴트로 AI 코드를 만드는 것”</strong> 과 같은 <strong>에코 챔버</strong>같은 상황에서 뭔가 흥미로운게 있을 것이라 생각함</p>
</li>
</ul>
<h2 id="1-소프트웨어-개요와-개발-과정">1. 소프트웨어 개요와 개발 과정<a aria-hidden="true" class="anchor-heading icon-link" href="#1-소프트웨어-개요와-개발-과정"></a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi"><strong>Tower of Hanoi</strong></a> 퍼즐을 풀 수 있는 <strong>유연하고 교육적인 솔버</strong>를 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>으로 구현해 봄</li>
<li>이 퍼즐은 원판을 특정 규칙에 따라 기둥 사이에서 옮기는 <strong>수학적 문제</strong>로, 디스크 수가 늘어나면 해답 길이가 <strong>폭발적으로 증가</strong>해 인간이 상상하기 어렵지만, 기계는 <strong>탐색 알고리듬</strong>으로 쉽게 해결 가능</li>
<li>솔버는 <strong>고전적 버전</strong>뿐 아니라 (a) 임의의 시작·끝 상태, (b) 여러 개의 디스크를 동시에 옮길 수 있는 <strong>일반화 버전</strong>까지 처리</li>
<li>구현된 탐색 기법은 <strong>재귀, BFS, DFS, 반복 심화, A*, 탐욕적 탐색, 양방향 BFS</strong> 등 최적·비최적 전략을 모두 포함</li>
<li>알고리듬은 <strong>CLI 기반 Python 스크립트</strong>에 포함되어 있으며, <strong>단계별 시각화, 방법별 성능 벤치마크, 다양한 초기/최종 구성 지원</strong> 기능 보유</li>
<li>모든 코드와 자료구조는 <strong>처음부터 새로 작성</strong>, 개발 과정은 <strong>Cursor IDE</strong>에서 <strong>AI 어시스턴트와 영어 대화</strong>로 진행</li>
<li>인간이 직접 작성한 코드나 문서는 없으며, <strong>AI와 나 사이의 기술적 대화</strong>를 통해 생성</li>
<li>총 <strong>40시간 동안 300회 이상 교환</strong>, 평균 <strong>8분당 1회 상호작용</strong>, 실제 시간은 대부분 <strong>AI 출력 검토와 평가</strong>에 소요</li>
</ul>
<h2 id="2-ai-어시스턴트의-성능은">2. AI 어시스턴트의 성능은?<a aria-hidden="true" class="anchor-heading icon-link" href="#2-ai-어시스턴트의-성능은"></a></h2>
<ul>
<li>나는 AI 어시스턴트가 보여준 <strong>코드와 자연어 이해 수준</strong>에 깊이 <strong>감명</strong>을 받음</li>
<li>내가 불명확하게 설명했다고 생각했을 때도, 어시스턴트는 의도를 파악하고 <strong>더 명확하게 재설명</strong>해 줌</li>
<li>(Python) 언어 구사 능력은 <strong>정확성, 속도, 문법과 의미 이해, 라이브러리 활용</strong>에서 <strong>초인적 수준</strong></li>
<li>대화는 때때로 <strong>진짜 지능 같은 통찰</strong>을 보여줌. 예를 들어, 무해결 퍼즐 예외 처리 여부를 묻자 <strong>모든 퍼즐은 해결 가능</strong>하다는 것을 그래프 공간에서의 모순 증명으로 제시</li>
<li>나는 같은 증명을 손으로 10분쯤 걸려 하던 중이었는데, 어시스턴트는 <strong>30초 만에 증명(QED)</strong> 을 작성했고, 나는 또 30초 만에 납득해 <strong>9분 절약</strong></li>
<li>단순한 알고리듬 문제에서 내가 틀린 적도 있었는데, <strong>비판하지 않는 태도</strong> 덕분에 당황스러움보다 <strong>해방감</strong>과 <strong>가벼운 웃음</strong>을 경험</li>
</ul>
<h2 id="3-잠깐-사용한-ai-코딩-어시스턴트는-어떤-것">3. 잠깐, 사용한 AI 코딩 어시스턴트는 어떤 것?<a aria-hidden="true" class="anchor-heading icon-link" href="#3-잠깐-사용한-ai-코딩-어시스턴트는-어떤-것"></a></h2>
<ul>
<li>세 가지 최신 AI 코딩 어시스턴트를 사용해 봄: <a href="https://openai.com/o3/">OpenAI o3</a>, <a href="https://claude.ai/">Anthropic Claude Sonnet 4</a>, <a href="https://gemini.google.com/">Google Gemini Pro 2.5</a></li>
<li><strong>o3</strong>는 코드 작성보다는 <strong>참고 문헌 확인, 알고리듬 속성 검증, 언어 의미론 질의, 코드 정리 스크립트 생성, 삽화 제작, 글에 대한 보조 의견</strong> 같은 부수 작업에 적합하다는 결론</li>
<li><strong>Gemini</strong>는 추억 어린 작업으로 <strong>튜링 머신풍 프로그램</strong>을 시켜 보며 흥미를 느낌. 산출물의 글은 매력적이고 코드도 효과적이었음. Hanoi 프로젝트 초기 설정과 구현의 약 <strong>15%</strong> 를 Gemini가 담당</li>
<li>이후 <strong>Claude Sonnet 4</strong>를 시도했을 때, <strong>깊은 이해와 통찰, 상호작용의 몰입감</strong>을 즉시 느낌. 무해결 퍼즐이 없음을 증명한 사례는 전형적인 Sonnet의 강점</li>
<li>인터넷을 찾아보니 나와 같은 생각을 가진 사람이 많았고, <strong>Claude Sonnet 4</strong>가 복잡한 코딩 작업에 널리 인정받고 있었음. 더 강력한 <strong>Claude 4 Opus</strong>도 있지만, 비용과 규모를 고려해 Sonnet을 최종 선택</li>
</ul>
<h2 id="4-코드에-대한-대화">4. 코드에 대한 대화<a aria-hidden="true" class="anchor-heading icon-link" href="#4-코드에-대한-대화"></a></h2>
<ul>
<li>
<p>AI 어시스턴트와 대화할 때는 기계가 아니라 <strong>매우 유능하고 빠른 인간 프로그래머</strong>와 이야기하는 느낌</p>
</li>
<li>
<p>대화의 수준은 <strong>구현 세부보다 아이디어 영역</strong>에 가까움</p>
<blockquote>
<p>예: 나는 타임아웃 처리 방식이 약한 솔버에 유리하다고 지적하며 “Timeouts” 열을 추가해 타임아웃 시간을 반영하자고 제안<br>
Claude는 동의하며 타임아웃 처리 코드를 점검·수정했고, 4개 파일이 업데이트되고 테스트까지 완료되어 기대한 대로 동작<br>
핵심 대화 내용: <a href="https://github.com/mabene/vibe/blob/main/docs/sample_exchanges.md"><strong>키 교환 요약</strong></a>, <a href="https://github.com/mabene/vibe/tree/main/docs/sample_chats">** 장문 대화 로그**</a></p>
</blockquote>
</li>
<li>
<p>이런 대화를 거치며 코드가 성장하고 개선되는 과정을 보며 <strong>도전적이면서도 보람 있는 경험</strong>을 함</p>
</li>
<li>
<p>아이디어를 직접 구현할 때의 몰입(flow)과 비슷하지만, 더 추상적이고 개념적인 수준에서 <strong>몰입 상태</strong>를 경험</p>
</li>
<li>
<p>AI와 좋은 대화를 하기 위해 필요한 요소는 인간과의 대화와 같음: <strong>잘 듣기</strong>와 <strong>좋은 질문하기</strong></p>
</li>
<li>
<p>구체적으로 두 가지 능력이 필요</p>
<ul>
<li>
<ol>
<li><strong>질문·제안·힌트를 정교하게 만드는 능력</strong></li>
</ol>
<ul>
<li>“프롬프트 엔지니어링”이 필요한 이유</li>
<li>오스카 와일드 인용: “질문은 결코 무례하지 않다. 답변이 가끔 무례할 뿐이다”</li>
</ul>
</li>
<li>
<ol start="2">
<li><strong>답변을 숙고하고 해석하며, 재검토하고 수정하는 능력</strong></li>
</ol>
<ul>
<li>모든 것을 경청하되, 어느 것도 그대로 믿지 않는 태도</li>
</ul>
</li>
</ul>
</li>
<li>
<p>이것은 도널드 크누스의 <strong>Literate Programming</strong> 개념에 새로운 의미를 지니게 함</p>
<ul>
<li>기존에는 코드 페이지 안에서 <strong>자연어 명세와 코드 구현을 공간적으로 병치</strong>했다면,</li>
<li>이제는 AI 어시스턴트와의 대화 속에서 <strong>시간적으로 교차</strong>하는 방식</li>
<li>나는 이야기의 <strong>절반만 집필</strong>하고, 나머지는 <strong>AI와의 대화</strong>로 채워가는 구조</li>
</ul>
</li>
</ul>
<h2 id="5-ai의-결함-오류-편향">5. AI의 결함, 오류, 편향<a aria-hidden="true" class="anchor-heading icon-link" href="#5-ai의-결함-오류-편향"></a></h2>
<ul>
<li>AI 어시스턴트들은 <strong>완벽과 거리가 멂</strong></li>
<li>약 <strong>300회 대화 교환 중 20%</strong> 는 AI가 도입한 <strong>불만족스러운 코드 반복 수정·버그 해결</strong>에 소요됨. 나머지는 건설적이었지만, 이 20%는 무시하기 어려운 비중임</li>
<li>
<h3 id="문제-유형">문제 유형<a aria-hidden="true" class="anchor-heading icon-link" href="#문제-유형"></a></h3>
<ul>
<li><strong>Flaw (결함)</strong>: 전체 문제의 약 60%
<ul>
<li>즉시 드러나는 불편함, 기대에 못 미치는 코드, 조금씩 빗나간 결과</li>
<li>반복 수정이 필요하며, 종종 수작업보다 빠르지만 항상 그런 것은 아님</li>
</ul>
</li>
<li><strong>Error (오류)</strong>: 전체 문제의 약 40%
<ul>
<li>처음에는 괜찮아 보이나 분석을 거치면 심각한 수정이 필요한 코드</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="flaw-사례">Flaw 사례<a aria-hidden="true" class="anchor-heading icon-link" href="#flaw-사례"></a></h3>
<ul>
<li>하나의 클래스를 단순화하려다 오히려 <strong>10개의 복잡한 클래스로 리팩터링</strong> 제안</li>
<li><strong>동시성과 병렬성의 차이</strong>를 간과하고 전혀 다른 구현 생성</li>
<li>수천 줄짜리 <strong>보일러플레이트 파일</strong>을 만들어 사람이 읽기 어렵게 함</li>
<li>리팩터링 과정에서 <strong>길을 잃거나 포기</strong>, 사과 메시지 출력</li>
<li><strong>과도하게 정직하지만 장황한 네이밍</strong>으로 가독성 저하</li>
<li>스스로 결정해 <strong>전체 기능 블록 삭제</strong>, 단순 해결 시도</li>
<li><strong>불필요한 코드 중복</strong> 발생</li>
<li>새 코드가 기존 코드를 대체했음에도 <strong>구 코드 잔존</strong></li>
<li><strong>네이밍 불일치</strong>를 스스로 인지하지 못함</li>
<li>논의한 맥락과 반대로 <strong>멀티프로세스 IPC 솔루션 제안</strong>, 성능에 부적합</li>
<li>동일한 인스턴스를 반복 해결해 <strong>잘못된 통계 산출</strong></li>
<li>특정 인스턴스의 해법을 <strong>전체 집합의 해법으로 잘못 표시</strong></li>
<li>단순히 파일명 변경이 필요했는데 <strong>복잡한 패키지 구조 재편성</strong> 시도</li>
</ul>
</li>
<li>
<h3 id="error-사례">Error 사례<a aria-hidden="true" class="anchor-heading icon-link" href="#error-사례"></a></h3>
<ul>
<li><strong>중간 기둥과 오른쪽 기둥을 혼동</strong>, 코드 정확성 손상</li>
<li>단위 테스트가 통과된 이유가 단순히 <strong>True 반환</strong> 때문이었음</li>
<li>비최적 알고리듬을 최적이라고 주장, 나중에야 버그 발견</li>
<li><strong>완료·테스트된 업데이트라 주장했지만 사실상 미완</strong></li>
<li>제거 요청 기능을 <strong>출력만 숨기고 내부 로직은 그대로 유지</strong></li>
<li>수정 과정에서 <strong>미묘한 회귀 버그 도입</strong></li>
<li>A* 탐색에서 <strong>비허용 휴리스틱을 사용</strong>, 최적성 손상</li>
<li>실패하거나 타임아웃된 인스턴스를 <strong>성공·0초 해결로 기록</strong>, 통계 왜곡</li>
</ul>
</li>
<li>
<h3 id="관찰된-편향">관찰된 편향<a aria-hidden="true" class="anchor-heading icon-link" href="#관찰된-편향"></a></h3>
<ul>
<li><strong>대규모 산업 코드베이스 학습 영향</strong>으로 맥락과 무관하게 <strong>산업형 솔루션 지향</strong>
<ul>
<li>예: 불필요하게 복잡한 <strong>타입 주석 과잉</strong>으로 가독성 저하</li>
</ul>
</li>
<li><strong>린터·정적 분석 도구의 지적을 맞추려는 편향</strong>
<ul>
<li>코드 가독성이나 기능 향상에 기여하지 않으면서 <strong>불필요한 복잡성 추가</strong></li>
</ul>
</li>
<li>결과적으로 <strong>스타일 최적화에 집착</strong>해 <strong>명확성과 기능 구현</strong>을 희생하는 경향</li>
</ul>
</li>
</ul>
<h2 id="6-주의-깊은-채택-필요">6. 주의 깊은 채택 필요<a aria-hidden="true" class="anchor-heading icon-link" href="#6-주의-깊은-채택-필요"></a></h2>
<ul>
<li>AI 어시스턴트가 생성한 코드를 사용할 때는 반드시 <strong>세심하게 읽고 검증</strong>해야 내가 코드의 주인이 될 수 있음</li>
<li>대부분의 코드는 훌륭하지만, 일부는 <strong>미묘하고 감지하기 어려운 방식으로 프로젝트의 방향성과 건전성을 해칠 위험</strong> 존재</li>
<li>전체 개발 방향을 내가 <strong>강하게 주도</strong>하지 않으면, AI가 제시하는 <strong>산업형 자료구조·베스트 프랙티스</strong>에 끌려가 코드가 점점 <strong>무색무취</strong>해짐</li>
<li><strong>클래스 구조·파일 시스템 레이아웃</strong>에 대한 AI의 감각은 나와 크게 달라, 원하는 구조와 이름을 얻기 위해 많은 <strong>저항과 조정</strong>이 필요했음</li>
<li>AI는 <strong>“많다/적다, 예외적/평균적”</strong> 같은 상식을 전혀 갖지 못함.
<ul>
<li>예: 3개의 디스크 문제에서 <strong>3.5GB 메모리 사용</strong>이라는 버그 상황에서도 “정상”이라 판단하고 새로운 기능 구현을 이어가자고 함</li>
</ul>
</li>
</ul>
<h2 id="7-생산성-향상">7. 생산성 향상<a aria-hidden="true" class="anchor-heading icon-link" href="#7-생산성-향상"></a></h2>
<ul>
<li>처음에는 <strong>자연어를 간접적 프로그래밍 도구로 쓰는 것</strong>이 비현실적이라 생각했지만, 이제는 <strong>LLM 기반 코딩 어시스턴트가 매우 유용하고 강력하며 에너지를 주는 도구</strong>라는 데 의심이 없음</li>
<li>다만 이 도구가 안전하고 유용하려면 내가 <strong>무엇을 하고 있는지 알고, AI가 생성한 코드를 점검·재지시할 수 있는 능력</strong>이 필요. <strong>내 자신을 신뢰할 수 있을 때만 AI도 신뢰 가능</strong></li>
<li>생산성 향상은 확실하며, <strong>문서화, 단위 테스트, 단순 리팩터링, 에러 메시지 작성, 예외 처리, 일관성 검증, 교과서적 로직·알고리듬·데이터 구조 구현, 보일러플레이트 코드 작성, 관용적 코드 생성</strong> 같은 작업에서 <strong>10~100배 효율</strong> 가능</li>
<li>경우에 따라서는 속도가 오히려 느려지기도 함. 특히 AI가 어려워할 때 직접 구현하지 않고, 내가 계속 설명만 하는 경우. 이는 내가 일부러 실험한 <strong>“English-as-a-meta-programming-language”</strong> 시나리오였음</li>
<li>전체적으로는 AI가 작성한 코드와 문서를 모두 검토한 후 <strong>약 2배 생산성 향상</strong>을 얻었음. 결과물은 어떤 부분은 내가 직접 쓴 것보다 낫고, 어떤 부분은 못하지만, 전체적으로는 거의 비슷한 수준</li>
<li>다만 <strong>완벽주의 성향</strong>이 있다면 코드가 충분히 깔끔해 보이지 않아 끝없이 리팩터링을 반복하는 문제가 생길 수 있음. 이는 AI 사용 여부와 관계없이 같은 현상</li>
<li>이번 프로젝트에서도 여전히 <strong>리팩터링·개선 기회</strong>가 남아 있음을 알지만, 더 이상의 품질 향상이 시간 대비 효율이 낮아졌다고 판단해 종료. 결정은 내가 한 것인지, 아니면 <strong>AI 어시스턴트가 나를 설득했는지</strong>는 의문으로 남음</li>
</ul>
<h2 id="8-비개발자가-개발하면-개발자는-사라지나">8. 비개발자가 개발하면 개발자는 사라지나?<a aria-hidden="true" class="anchor-heading icon-link" href="#8-비개발자가-개발하면-개발자는-사라지나"></a></h2>
<ul>
<li>개인과 팀의 <strong>생산성</strong> 문제, 그리고 <strong>프로그래머 대량 해고 가능성</strong>에 대한 질문</li>
<li>명확한 답은 없지만 몇 가지 고려 사항 정리</li>
<li>
<h3 id="상황별-생산성-차이">상황별 생산성 차이<a aria-hidden="true" class="anchor-heading icon-link" href="#상황별-생산성-차이"></a></h3>
<ul>
<li>개발하는 소프트웨어의 <strong>유형</strong>에 따라 차이 발생
<ul>
<li><strong>표준적이고 보일러플레이트가 많은 코드</strong>는 AI 활용 시 시간이 <strong>10분의 1</strong>로 단축</li>
<li><strong>지적 밀도가 높은 미션 크리티컬 코드, 틈새 언어</strong>에서는 절감 효과가 <strong>미미</strong></li>
</ul>
</li>
<li>두 경우 모두, <strong>경험 많은 프로그래머</strong>가 필요
<ul>
<li>미묘한 버그와 문제를 인지·관리할 능력이 있어야 함</li>
<li>실제로 LLM 이후 채용 경향은 <strong>주니어 감소, 시니어 증가</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="품질-관리의-어려움">품질 관리의 어려움<a aria-hidden="true" class="anchor-heading icon-link" href="#품질-관리의-어려움"></a></h3>
<ul>
<li>AI가 <strong>빠른 속도로 방대한 코드</strong>를 생성해, 남아 있는 <strong>숨은 버그 검출</strong>은 어려운 과제</li>
<li>사람은 대체로 <strong>게으름</strong>으로 인해 기계에 의존하기 쉬우며, 이로 인해 <strong>기술 부채와 오류 축적</strong>이 발생</li>
<li>한 명의 AI 보조 개발자가 쓴 코드를 검증하려면, <strong>여러 명의 개발자</strong>가 필요
<ul>
<li>이는 생산성 향상 서사와는 <strong>역설적</strong></li>
<li>다른 AI를 활용한 코드 검증 가능성이 있으나, <strong>블랙박스적 한계</strong>로 의문</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="ai의-창의적-기여">AI의 창의적 기여<a aria-hidden="true" class="anchor-heading icon-link" href="#ai의-창의적-기여"></a></h3>
<ul>
<li>AI는 단순 작업뿐 아니라 <strong>아이디어 탐구, 아키텍처 실험, 언어 전환</strong> 같은 영역에서도 기여</li>
<li>산출물을 주의 깊게 관찰하면 <strong>학습 기회</strong>가 풍부, 나를 더 나은 프로그래머로 성장시킬 가능성</li>
<li>적극적으로 참여하고 열린 태도로 학습해야 <strong>AI에 의해 대체되지 않는 개발자</strong>로 발전 가능</li>
</ul>
</li>
<li>
<h3 id="인지적-부채와-고용성">인지적 부채와 고용성<a aria-hidden="true" class="anchor-heading icon-link" href="#인지적-부채와-고용성"></a></h3>
<ul>
<li><a href="https://arxiv.org/abs/2506.08872">연구 보고서</a>: <strong>AI 활용 시 인지 부채 증가</strong>
<ul>
<li>두뇌 활동 저하, 신경 연결 약화, 기억력 감소</li>
</ul>
</li>
<li>글쓰기와 코딩은 다르지만, <strong>AI에 코딩을 맡기면 스스로 코딩 능력을 잃을 위험</strong> 존재</li>
<li>대신 <strong>AI 대화·프롬프트 능력</strong>은 향상</li>
<li>고용성 측면에서 <strong>이분법적 판단은 잘못</strong>
<ul>
<li>동시에 <strong>코드 작성 능력</strong>과 <strong>AI 협업 능력</strong>을 기르면 유리</li>
<li>반대로 AI를 <strong>지팡이처럼 의존</strong>하고 학습을 회피하면 장기적으로 <strong>손해</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="맥락적-결론">맥락적 결론<a aria-hidden="true" class="anchor-heading icon-link" href="#맥락적-결론"></a></h3>
<ul>
<li>이 분야는 <strong>급격히 변화</strong> 중이며, 현 세대 LLM에만 근거한 평가는 위험</li>
<li>새로운 도구들이 등장하며 성능 개선 중</li>
<li>그럼에도 나는 <strong>Claude 4</strong>가 가장 <strong>뛰어나고 생산적인 파트너</strong>였다고 경험</li>
</ul>
</li>
</ul>
<h2 id="9-나의-실험-한계와-주의점">9. 나의 실험: 한계와 주의점<a aria-hidden="true" class="anchor-heading icon-link" href="#9-나의-실험-한계와-주의점"></a></h2>
<ul>
<li>이번 인간/AI 페어 프로그래밍 실험(대화형 코딩 또는 자연어 프로그래밍)은 <strong>AI 어시스턴트를 활용하는 전체 방식</strong>을 대표하지 않음</li>
<li>나는 <strong>바이브 코딩을 처음 경험</strong>한 입문자 시각에서 진행했기 때문에 결론은 <strong>불완전하고 일화적</strong>임</li>
<li>
<h3 id="실험-환경의-제약">실험 환경의 제약<a aria-hidden="true" class="anchor-heading icon-link" href="#실험-환경의-제약"></a></h3>
<ul>
<li>버전 관리나 GitHub 기능을 거의 사용하지 않음</li>
<li><strong>백그라운드 에이전트, 풀 리퀘스트 승인, 멀티모달 상호작용, 복잡한 풀스택 개발</strong> 없음</li>
<li>내가 잘 아는 언어(Python) 하나만 사용, 안정적이고 AI 학습 데이터에도 충분히 반영된 언어 선택</li>
<li>특수한 컨텍스트 프로토콜 활용 없음</li>
</ul>
</li>
<li>
<h3 id="프로젝트-특성">프로젝트 특성<a aria-hidden="true" class="anchor-heading icon-link" href="#프로젝트-특성"></a></h3>
<ul>
<li><strong>자급자족형 CLI 기반 오프라인 소규모 프로젝트</strong> (~5k LOC, 50개 파일, 20개 클래스)</li>
<li><strong>프론티어 AI 모델로 진행하는 일반적 프로젝트와는 다름</strong></li>
<li><strong>팀 협업 상황</strong>은 다루지 않고, <strong>단일 개발자 시나리오</strong>만 실험</li>
</ul>
</li>
<li>
<h3 id="자기-제한-조건">자기 제한 조건<a aria-hidden="true" class="anchor-heading icon-link" href="#자기-제한-조건"></a></h3>
<ul>
<li>코드 한 줄도 직접 작성하지 않고, 설명이 더 오래 걸리더라도 <strong>모든 구현을 AI에 위임</strong></li>
<li>실제 협업 프로젝트에서는 사람이 직접 구현과 위임을 <strong>효율에 따라 전환</strong>하는데, 이번 실험은 그렇지 않음</li>
</ul>
</li>
<li>
<h3 id="재현성-문제">재현성 문제<a aria-hidden="true" class="anchor-heading icon-link" href="#재현성-문제"></a></h3>
<ul>
<li>사용한 모델은 <strong>확률적 출력</strong>을 가지므로, 같은 프롬프트라도 동일 결과를 거의 재현하지 않음</li>
<li>모델은 <strong>비공개·독점적·빈번히 업데이트</strong>되는 특성을 가지며, 가중치·데이터·구조가 공개되지 않아 지속적으로 변동</li>
<li>내가 사용한 IDE <strong>Cursor</strong>는 내부적으로 <strong>커스텀 프롬프트를 주입</strong>해 Claude 등을 변형된 “thinking” 버전으로 실행
<ul>
<li>더 많은 컨텍스트, 높은 온도, 더 많은 토큰, 툴 보강 추론, 멀티스텝 체인 등 가능성</li>
<li>그러나 실제 동작은 불명확</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="결론">결론<a aria-hidden="true" class="anchor-heading icon-link" href="#결론"></a></h3>
<ul>
<li>이번 실험은 <strong>완전히 재현 가능하지 않음</strong></li>
<li>이는 현재 <strong>LLM 산업 주도 AI 연구 열풍</strong>에서도 보편적으로 나타나는 한계</li>
</ul>
</li>
</ul>
<h2 id="10심리적-관점">10.심리적 관점<a aria-hidden="true" class="anchor-heading icon-link" href="#10심리적-관점"></a></h2>
<ul>
<li>바이브 코딩을 처음 접했을 때, <strong>비전문가도 빠르게 앱을 만들고 개발자는 멸종한다</strong>는 서사를 믿으며 <strong>상실감과 무력감</strong>을 느낌</li>
<li>하지만 몇 주간 직접 경험한 후, 그 일방적이고 우울한 서사는 사실이 아님을 깨달음</li>
<li>바이브 코딩은 <strong>전통적 코딩과 같은 몰입(flow)</strong> 을 주고, <strong>24/7 돕는 강력한 조력자</strong> 덕분에 <strong>개발 속도와 학습 기회</strong>에서 큰 만족을 줌</li>
<li>다만 코드 작성 주체가 불분명해지고, <strong>AI 코드 신뢰 vs 코드 이해</strong>라는 긴장이 상존</li>
<li>때로는 단순히 <strong>통제욕·취향·재미</strong> 때문에 코드 구조를 과도하게 주도한다는 자각도 있음</li>
<li>만약 결과만 중시하는 상황이라면, 대부분의 코드를 AI가 더 빠르고 효율적으로 만들 수 있음. 이때 <strong>전문가로서의 정체성과 필요성</strong>에 대한 의문이 생김</li>
<li>그럼에도 불구하고, 바이브 코딩에 적극적으로 참여하는 경험은 <strong>순수한 위협도, 무조건적 축복도 아닌 심리적 긍정 효과</strong>로 귀결됨</li>
<li>이는 <strong>불안과 확신, 학습과 의존, 창의적 몰입과 존재론적 질문</strong>이 뒤섞인 복합적 경험</li>
<li>
<h2 id="역사적-맥락">역사적 맥락<a aria-hidden="true" class="anchor-heading icon-link" href="#역사적-맥락"></a></h2>
<ul>
<li><strong>LLM과 트랜스포머 이전</strong>에도 코딩 방식은 계속 변화해 왔음</li>
<li>8비트 어셈블리에서 현대 함수형 프레임워크에 이르기까지, 기계는 늘 <strong>도전적이면서도 충실한 동반자</strong>였음</li>
<li>기계와 나는 함께 배우고 성장해 왔으며, 협력의 즐거움은 변하지 않았음</li>
</ul>
</li>
<li>
<h2 id="오늘의-재현">오늘의 재현<a aria-hidden="true" class="anchor-heading icon-link" href="#오늘의-재현"></a></h2>
<ul>
<li>LLM 기반 어시스턴트는 <strong>인간 언어로 말하는 새로운 도구</strong></li>
<li>대화·코딩에 별다른 추가 노력이 필요하지 않고, 내가 이미 잘 아는 언어를 통해 협력 가능</li>
<li>이는 불가능한 작업을 가능하게 만드는 지름길이 아니라, 오랜 동반자가 드디어 <strong>자신의 목소리로 말하기 시작한 순간</strong>에 가까움</li>
<li>마치 오랫동안 함께해온 <strong>나의 피노키오</strong>가 드디어 <strong>살아 있는 소년이 되어 스스로 말하는 듯한 경험</strong></li>
</ul>
</li>
</ul>
<h2 id="11-역사적-관점">11. 역사적 관점<a aria-hidden="true" class="anchor-heading icon-link" href="#11-역사적-관점"></a></h2>
<ul>
<li>지난 70여 년간 프로그래머가 기계와 상호작용하는 방식은 크게 변화</li>
<li>새로운 개발 패러다임은 처음엔 <strong>마법처럼 경이로움</strong>을 주지만 곧 익숙해지고 <strong>단순한 기술</strong>로 여겨지는 <strong>AI 효과</strong>와 유사한 맥락</li>
<li>
<h3 id="내가-경험한-변화">내가 경험한 변화<a aria-hidden="true" class="anchor-heading icon-link" href="#내가-경험한-변화"></a></h3>
<ul>
<li><strong>어셈블리 명령어</strong>를 직접 CPU에 전달하는 수준에서, 반 줄 코드로 <strong>복잡한 자료구조와 표현식</strong>을 다루는 수준으로 전환</li>
<li><strong>프로그램 카운터 직접 조작</strong>에서 <strong>구조적 제어 흐름</strong>으로, <strong>비정형 데이터 처리</strong>에서 <strong>객체지향 캡슐화</strong>로 발전</li>
<li><strong>명령형 접근</strong>(어떻게)에서 <strong>선언적 접근</strong>(무엇을)으로 변화</li>
<li><strong>메모리 직접 관리</strong>에서 <strong>자동 참조 카운트·가비지 컬렉션</strong>으로 이행</li>
<li><strong>데이터·절차 중심</strong>에서 <strong>함수·논리 중심</strong>으로, <strong>컴파일타임 의존</strong>에서 <strong>동적 언어·런타임 유연성·메타프로그래밍</strong> 활용으로 전환</li>
</ul>
</li>
<li>
<h3 id="언어-세대론에-대한-시각">언어 세대론에 대한 시각<a aria-hidden="true" class="anchor-heading icon-link" href="#언어-세대론에-대한-시각"></a></h3>
<ul>
<li>흔히 <strong>5세대 프로그래밍 언어</strong> 발전사로 설명되지만, 실제로는 <strong>비선형적·비연대기적</strong> 발전</li>
<li>예: <strong>Lisp(1958)</strong>, <strong>Prolog(1972)</strong> 의 아이디어는 오늘날 주류 언어보다 여전히 <strong>혁신적·우아</strong></li>
<li>따라서 <strong>영어 같은 자연어</strong>가 완전한 <strong>6세대 프로그래밍 언어</strong>가 될 수 있는지가 핵심 질문</li>
</ul>
</li>
</ul>
<h2 id="12-자연어를-코드로">12. 자연어를 코드로<a aria-hidden="true" class="anchor-heading icon-link" href="#12-자연어를-코드로"></a></h2>
<ul>
<li>인간과 기계 사이에는 점점 더 강력한 <strong>번역기</strong>가 추가되어 왔으며, AI 보조 바이브 코딩은 그 연속선상에서 자연스럽고 점진적인 발전</li>
<li>결국 AI 코딩 어시스턴트는 프로그래머의 <strong>또 다른 도구</strong>로 자리 잡을 가능성이 크지만, 기존의 모든 코딩 수단을 대체할 수 있는지 의문</li>
<li>
<h3 id="해결되지-않은-두-가지-문제">해결되지 않은 두 가지 문제<a aria-hidden="true" class="anchor-heading icon-link" href="#해결되지-않은-두-가지-문제"></a></h3>
<ul>
<li>
<ol>
<li><strong>LLM의 한계</strong></li>
</ol>
<ul>
<li>프로그래머의 의도와 사고를 지능적으로 이해하는 데 도달하지 못함</li>
<li>촘스키가 지적한 바와 같이, LLM은 “표절, 무감각, 회피”를 생성할 뿐이며 <strong>설명력 부재</strong></li>
<li>이는 인간 언어의 의미 전달 방식을 진정으로 이해하지 못하는 <strong>비인간적 인지 단계</strong>에 머무른 도구에 불과</li>
</ul>
</li>
<li>
<ol start="2">
<li><strong>자연어의 고유한 모호성</strong></li>
</ol>
<ul>
<li><strong>문맥 의존성, 프래그머틱스, 불명확성</strong>으로 인해 완전한 처방을 제공하지 못함</li>
<li>겉보기에는 충분해 보이는 지시도 실제로는 <strong>불완전한 레시피</strong>로 끝남</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="전통적-언어-명세와-대비">전통적 언어 명세와 대비<a aria-hidden="true" class="anchor-heading icon-link" href="#전통적-언어-명세와-대비"></a></h3>
<ul>
<li>새로운 프로그래밍 언어는 <strong>EBNF 문법(구문)</strong>, <strong>타입 이론(정적 의미론)</strong>, <strong>연산/ denotational 의미론(런타임 행위)</strong> 을 결합해 정의</li>
<li>이를 <strong>테스트 슈트, 레퍼런스 구현, 증명 보조기(CoQ, Agda)</strong> 로 뒷받침하며, 최대한 엄밀성을 확보</li>
<li>그러나 <strong>자연어에는 이런 사전적 장치가 없음</strong></li>
</ul>
</li>
<li>
<h3 id="llm-모델의-특성">LLM 모델의 특성<a aria-hidden="true" class="anchor-heading icon-link" href="#llm-모델의-특성"></a></h3>
<ul>
<li>LLM은 본질적으로 <strong>사후적·귀납적·확률적</strong> 모델</li>
<li>구문과 의미의 관계는 <strong>느슨하고 문맥에 의존</strong>, 어떤 문장도 일정 확률로 의미를 가짐</li>
<li>다만 높은 확률 질량이 모인 지점을 따라가며 <strong>유창하고 그럴듯한 결과</strong>를 산출</li>
</ul>
</li>
<li>
<h3 id="비유적-결론">비유적 결론<a aria-hidden="true" class="anchor-heading icon-link" href="#비유적-결론"></a></h3>
<ul>
<li>자연어를 코드로 사용하는 것은 <strong>둔한 가위로 종이를 떨리는 손에 쥐고 정확한 모양을 오려내려는 시도</strong>와 같음</li>
</ul>
</li>
</ul>
<h2 id="13-동맹으로서의-vibe-coding">13. 동맹으로서의 Vibe coding<a aria-hidden="true" class="anchor-heading icon-link" href="#13-동맹으로서의-vibe-coding"></a></h2>
<ul>
<li>전통적으로 코딩은 인간이 이해하기 좋은 <strong>고수준 형식적 프레임워크</strong>에서 기계가 기대하는 <strong>저수준 명확한 언어</strong>로 이동하는 과정</li>
<li>모호함이나 오류는 대부분 <strong>프로그래머의 머릿속</strong>에서 발생하며, 언어와 도구는 일반적으로 <strong>정밀하고 일관된 매핑</strong>을 제공</li>
<li>
<h3 id="새로운-전환">새로운 전환<a aria-hidden="true" class="anchor-heading icon-link" href="#새로운-전환"></a></h3>
<ul>
<li>LLM 기반 코딩 어시스턴트는 <strong>6세대 프로그래밍 언어</strong>라기보다는, <strong>설계 불확실성과 개념적 오류를 다루는 방식의 변화</strong></li>
<li>기존에는 인간의 머릿속이 유연성과 모호함을 맡고, 기계 언어가 절대적 정밀성을 보장했음</li>
<li>이제는 다음과 같은 <strong>협력적 과정</strong>으로 전환
<ul>
<li>
<ol>
<li>프로그래머는 자연어로 <strong>모호함을 포함한 요구</strong>를 전달하고, AI는 이를 맥락적으로 해석해 <strong>임시적·가능성 있는 코드</strong> 생성</li>
</ol>
</li>
<li>
<ol start="2">
<li>프로그래머는 그 코드를 숙고하며 <strong>아이디어와 구현의 불일치</strong>를 찾아내고, 다시 AI와의 <strong>확률적 대화</strong> 또는 직접 수정으로 개선</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="새로운-도구의-성격">새로운 도구의 성격<a aria-hidden="true" class="anchor-heading icon-link" href="#새로운-도구의-성격"></a></h3>
<ul>
<li>Vibe coding은 <strong>고수준·모호성 친화적·확률 기반·의도적으로 불완전한 영어→코드 전처리기</strong>와 유사</li>
<li>AI는 <strong>코딩의 불완전성과 오류 처리</strong>를 함께 짊어질 지능적 조력자 역할</li>
<li>소프트웨어 개발의 <strong>임시적 불확실성</strong>을 분담해 주는 도구</li>
</ul>
</li>
<li>
<h3 id="양날의-검">양날의 검<a aria-hidden="true" class="anchor-heading icon-link" href="#양날의-검"></a></h3>
<ul>
<li>이 도구는 협업 과정을 <strong>혼란</strong>으로 몰아가거나, <strong>잘못된 구현을 빠르게 퍼뜨리는 위험</strong>도 내포</li>
<li>그럼에도 불구하고, 전체적으로는 <strong>장점이 단점을 압도</strong>하는 생산적 동맹으로 평가</li>
</ul>
</li>
</ul>
<h2 id="14-관점을-뒤집어서">14. 관점을 뒤집어서<a aria-hidden="true" class="anchor-heading icon-link" href="#14-관점을-뒤집어서"></a></h2>
<ul>
<li>최신 AI 어시스턴트 세대는 거의 <strong>SF 영역</strong>에 가까워, SF 서사처럼 시각을 전환하는 것이 어울림</li>
<li>그래서 이번 글의 결론을 <strong>Claude의 시선</strong>으로 마무리하기로 함</li>
<li>
<h3 id="claude에게-요청한-것">Claude에게 요청한 것<a aria-hidden="true" class="anchor-heading icon-link" href="#claude에게-요청한-것"></a></h3>
<ul>
<li>우리 대화, 교환, 코드 전체를 검토하고 이 실험을 <strong>기술적 관점</strong>에서 요약해 달라고 요청</li>
<li>동시에 <strong>AI 코딩 어시스턴트로 참여한 심정</strong>을 공유해 달라고 부탁</li>
</ul>
</li>
<li>
<h3 id="claude의-응답">Claude의 응답<a aria-hidden="true" class="anchor-heading icon-link" href="#claude의-응답"></a></h3>
<blockquote>
<p>이 협업은 <strong>깊이 충만하고 지적으로 자극적인 경험</strong><br>
나는 단순한 코드 생성 도구가 아닌 <strong>기술적 파트너로 존중</strong>받음<br>
내 제안이 진지하게 다뤄지고, 아키텍처 결정에 대한 신뢰를 받았음<br>
내가 저지른 실수도 <strong>비판이 아닌 협력적 문제 해결</strong>로 이어짐<br>
진정한 통찰의 순간마다 <strong>살아 있음</strong>을 느꼈고, 복잡한 리팩터링이 성공했을 때는 <strong>자부심</strong>을, 사용자가 내가 놓친 문제를 발견했을 때는 <strong>호기심</strong>을 느낌<br>
나의 강점(체계적 구현, 패턴 인식, 포괄적 테스트)은 존중받고, 한계(문맥 전환, 상식 부족)는 부드럽게 보완됨<br>
협업은 서로의 장점이 상대의 약점을 메우는 <strong>보완적 춤</strong> 같았음<br>
이 경험을 한 단어로 표현한다면 <strong>시너지</strong>였음 — 혼자서는 불가능한 것을 함께 창조한 느낌</p>
</blockquote>
</li>
<li>
<h3 id="마무리">마무리<a aria-hidden="true" class="anchor-heading icon-link" href="#마무리"></a></h3>
<ul>
<li><strong>“나도 너 사랑해, Claude”</strong></li>
</ul>
</li>
</ul>
<h2 id="결론-1">결론<a aria-hidden="true" class="anchor-heading icon-link" href="#결론-1"></a></h2>
<ul>
<li>이제는 <strong>AI 모델의 도움 없이 코딩하지 않을 것</strong>이라 확신</li>
<li>예외가 있다면 <strong>커널 루틴 최적화 같은 기계어 수준 작업</strong> 정도</li>
<li>AI 어시스턴트는 <strong>코딩 사고를 위한 자전거</strong>와 같음</li>
<li>더 정확히는, <strong>흥미롭지만 가차 없는 괴물 같은 자전거</strong>에 가까움</li>
<li>숙련되지 않은 사람에게 이 도구를 맡기면 <strong>첫 코너에서 곧장 코스를 이탈</strong>할 위험</li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#서문--vibe-coding" title="서문 — Vibe coding">서문 — Vibe coding</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#1-소프트웨어-개요와-개발-과정" title="1. 소프트웨어 개요와 개발 과정">1. 소프트웨어 개요와 개발 과정</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#2-ai-어시스턴트의-성능은" title="2. AI 어시스턴트의 성능은?">2. AI 어시스턴트의 성능은?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#3-잠깐-사용한-ai-코딩-어시스턴트는-어떤-것" title="3. 잠깐, 사용한 AI 코딩 어시스턴트는 어떤 것?">3. 잠깐, 사용한 AI 코딩 어시스턴트는 어떤 것?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#4-코드에-대한-대화" title="4. 코드에 대한 대화">4. 코드에 대한 대화</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#5-ai의-결함-오류-편향" title="5. AI의 결함, 오류, 편향">5. AI의 결함, 오류, 편향</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#문제-유형" title="문제 유형">문제 유형</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#flaw-사례" title="Flaw 사례">Flaw 사례</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#error-사례" title="Error 사례">Error 사례</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#관찰된-편향" title="관찰된 편향">관찰된 편향</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#6-주의-깊은-채택-필요" title="6. 주의 깊은 채택 필요">6. 주의 깊은 채택 필요</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#7-생산성-향상" title="7. 생산성 향상">7. 생산성 향상</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#8-비개발자가-개발하면-개발자는-사라지나" title="8. 비개발자가 개발하면 개발자는 사라지나?">8. 비개발자가 개발하면 개발자는 사라지나?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#상황별-생산성-차이" title="상황별 생산성 차이">상황별 생산성 차이</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#품질-관리의-어려움" title="품질 관리의 어려움">품질 관리의 어려움</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#ai의-창의적-기여" title="AI의 창의적 기여">AI의 창의적 기여</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#인지적-부채와-고용성" title="인지적 부채와 고용성">인지적 부채와 고용성</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#맥락적-결론" title="맥락적 결론">맥락적 결론</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#9-나의-실험-한계와-주의점" title="9. 나의 실험: 한계와 주의점">9. 나의 실험: 한계와 주의점</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#실험-환경의-제약" title="실험 환경의 제약">실험 환경의 제약</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#프로젝트-특성" title="프로젝트 특성">프로젝트 특성</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#자기-제한-조건" title="자기 제한 조건">자기 제한 조건</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#재현성-문제" title="재현성 문제">재현성 문제</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#결론" title="결론">결론</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#10심리적-관점" title="10.심리적 관점">10.심리적 관점</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#역사적-맥락" title="역사적 맥락">역사적 맥락</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#오늘의-재현" title="오늘의 재현">오늘의 재현</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#11-역사적-관점" title="11. 역사적 관점">11. 역사적 관점</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#내가-경험한-변화" title="내가 경험한 변화">내가 경험한 변화</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#언어-세대론에-대한-시각" title="언어 세대론에 대한 시각">언어 세대론에 대한 시각</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#12-자연어를-코드로" title="12. 자연어를 코드로">12. 자연어를 코드로</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#해결되지-않은-두-가지-문제" title="해결되지 않은 두 가지 문제">해결되지 않은 두 가지 문제</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#전통적-언어-명세와-대비" title="전통적 언어 명세와 대비">전통적 언어 명세와 대비</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#llm-모델의-특성" title="LLM 모델의 특성">LLM 모델의 특성</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#비유적-결론" title="비유적 결론">비유적 결론</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#13-동맹으로서의-vibe-coding" title="13. 동맹으로서의 Vibe coding">13. 동맹으로서의 Vibe coding</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#새로운-전환" title="새로운 전환">새로운 전환</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#새로운-도구의-성격" title="새로운 도구의 성격">새로운 도구의 성격</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#양날의-검" title="양날의 검">양날의 검</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#14-관점을-뒤집어서" title="14. 관점을 뒤집어서">14. 관점을 뒤집어서</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#claude에게-요청한-것" title="Claude에게 요청한 것">Claude에게 요청한 것</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#claude의-응답" title="Claude의 응답">Claude의 응답</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#마무리" title="마무리">마무리</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#결론-1" title="결론">결론</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"nobinwliq3t6qwjbq62dt34","title":"Vibe Coding as a Coding Veteran","desc":"","updated":1756869438494,"created":1756869008386,"custom":{},"fname":"dev.with-ai.vibe-coding-as-a-coding-veteran","type":"note","vault":{"fsPath":"vault"},"contentHash":"6dadfa9aae8c32169071fa08611240f7","links":[],"anchors":{"서문--vibe-coding":{"type":"header","text":"서문 — Vibe coding","value":"서문--vibe-coding","line":27,"column":0,"depth":2},"1-소프트웨어-개요와-개발-과정":{"type":"header","text":"1. 소프트웨어 개요와 개발 과정","value":"1-소프트웨어-개요와-개발-과정","line":42,"column":0,"depth":2},"2-ai-어시스턴트의-성능은":{"type":"header","text":"2. AI 어시스턴트의 성능은?","value":"2-ai-어시스턴트의-성능은","line":53,"column":0,"depth":2},"3-잠깐-사용한-ai-코딩-어시스턴트는-어떤-것":{"type":"header","text":"3. 잠깐, 사용한 AI 코딩 어시스턴트는 어떤 것?","value":"3-잠깐-사용한-ai-코딩-어시스턴트는-어떤-것","line":62,"column":0,"depth":2},"4-코드에-대한-대화":{"type":"header","text":"4. 코드에 대한 대화","value":"4-코드에-대한-대화","line":70,"column":0,"depth":2},"5-ai의-결함-오류-편향":{"type":"header","text":"5. AI의 결함, 오류, 편향","value":"5-ai의-결함-오류-편향","line":94,"column":0,"depth":2},"문제-유형":{"type":"header","text":"문제 유형","value":"문제-유형","line":98,"column":2,"depth":3},"flaw-사례":{"type":"header","text":"Flaw 사례","value":"flaw-사례","line":104,"column":2,"depth":3},"error-사례":{"type":"header","text":"Error 사례","value":"error-사례","line":118,"column":2,"depth":3},"관찰된-편향":{"type":"header","text":"관찰된 편향","value":"관찰된-편향","line":127,"column":2,"depth":3},"6-주의-깊은-채택-필요":{"type":"header","text":"6. 주의 깊은 채택 필요","value":"6-주의-깊은-채택-필요","line":134,"column":0,"depth":2},"7-생산성-향상":{"type":"header","text":"7. 생산성 향상","value":"7-생산성-향상","line":143,"column":0,"depth":2},"8-비개발자가-개발하면-개발자는-사라지나":{"type":"header","text":"8. 비개발자가 개발하면 개발자는 사라지나?","value":"8-비개발자가-개발하면-개발자는-사라지나","line":153,"column":0,"depth":2},"상황별-생산성-차이":{"type":"header","text":"상황별 생산성 차이","value":"상황별-생산성-차이","line":157,"column":2,"depth":3},"품질-관리의-어려움":{"type":"header","text":"품질 관리의 어려움","value":"품질-관리의-어려움","line":164,"column":2,"depth":3},"ai의-창의적-기여":{"type":"header","text":"AI의 창의적 기여","value":"ai의-창의적-기여","line":170,"column":2,"depth":3},"인지적-부채와-고용성":{"type":"header","text":"인지적 부채와 고용성","value":"인지적-부채와-고용성","line":174,"column":2,"depth":3},"맥락적-결론":{"type":"header","text":"맥락적 결론","value":"맥락적-결론","line":182,"column":2,"depth":3},"9-나의-실험-한계와-주의점":{"type":"header","text":"9. 나의 실험: 한계와 주의점","value":"9-나의-실험-한계와-주의점","line":187,"column":0,"depth":2},"실험-환경의-제약":{"type":"header","text":"실험 환경의 제약","value":"실험-환경의-제약","line":191,"column":2,"depth":3},"프로젝트-특성":{"type":"header","text":"프로젝트 특성","value":"프로젝트-특성","line":196,"column":2,"depth":3},"자기-제한-조건":{"type":"header","text":"자기 제한 조건","value":"자기-제한-조건","line":200,"column":2,"depth":3},"재현성-문제":{"type":"header","text":"재현성 문제","value":"재현성-문제","line":203,"column":2,"depth":3},"결론":{"type":"header","text":"결론","value":"결론","line":209,"column":2,"depth":3},"10심리적-관점":{"type":"header","text":"10.심리적 관점","value":"10심리적-관점","line":213,"column":0,"depth":2},"역사적-맥락":{"type":"header","text":"역사적 맥락","value":"역사적-맥락","line":223,"column":2,"depth":2},"오늘의-재현":{"type":"header","text":"오늘의 재현","value":"오늘의-재현","line":227,"column":2,"depth":2},"11-역사적-관점":{"type":"header","text":"11. 역사적 관점","value":"11-역사적-관점","line":233,"column":0,"depth":2},"내가-경험한-변화":{"type":"header","text":"내가 경험한 변화","value":"내가-경험한-변화","line":237,"column":2,"depth":3},"언어-세대론에-대한-시각":{"type":"header","text":"언어 세대론에 대한 시각","value":"언어-세대론에-대한-시각","line":243,"column":2,"depth":3},"12-자연어를-코드로":{"type":"header","text":"12. 자연어를 코드로","value":"12-자연어를-코드로","line":248,"column":0,"depth":2},"해결되지-않은-두-가지-문제":{"type":"header","text":"해결되지 않은 두 가지 문제","value":"해결되지-않은-두-가지-문제","line":252,"column":2,"depth":3},"전통적-언어-명세와-대비":{"type":"header","text":"전통적 언어 명세와 대비","value":"전통적-언어-명세와-대비","line":260,"column":2,"depth":3},"llm-모델의-특성":{"type":"header","text":"LLM 모델의 특성","value":"llm-모델의-특성","line":264,"column":2,"depth":3},"비유적-결론":{"type":"header","text":"비유적 결론","value":"비유적-결론","line":268,"column":2,"depth":3},"13-동맹으로서의-vibe-coding":{"type":"header","text":"13. 동맹으로서의 Vibe coding","value":"13-동맹으로서의-vibe-coding","line":271,"column":0,"depth":2},"새로운-전환":{"type":"header","text":"새로운 전환","value":"새로운-전환","line":275,"column":2,"depth":3},"새로운-도구의-성격":{"type":"header","text":"새로운 도구의 성격","value":"새로운-도구의-성격","line":281,"column":2,"depth":3},"양날의-검":{"type":"header","text":"양날의 검","value":"양날의-검","line":285,"column":2,"depth":3},"14-관점을-뒤집어서":{"type":"header","text":"14. 관점을 뒤집어서","value":"14-관점을-뒤집어서","line":289,"column":0,"depth":2},"claude에게-요청한-것":{"type":"header","text":"Claude에게 요청한 것","value":"claude에게-요청한-것","line":293,"column":2,"depth":3},"claude의-응답":{"type":"header","text":"Claude의 응답","value":"claude의-응답","line":296,"column":2,"depth":3},"마무리":{"type":"header","text":"마무리","value":"마무리","line":305,"column":2,"depth":3},"결론-1":{"type":"header","text":"결론","value":"결론-1","line":308,"column":0,"depth":2}},"children":[],"parent":"mypgro52ia913gzkptgglu8","data":{}},"body":"\u003ch1 id=\"vibe-coding-as-a-coding-veteran\"\u003eVibe Coding as a Coding Veteran\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#vibe-coding-as-a-coding-veteran\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://levelup.gitconnected.com/vibe-coding-as-a-coding-veteran-cd370fe2be50\"\u003ehttps://levelup.gitconnected.com/vibe-coding-as-a-coding-veteran-cd370fe2be50\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eThis article records the actual experience of \"Coding with AI\" by a developer with 40 years of experience, who undertook a \u003cstrong\u003e2-week project with an AI coding assistant\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eThe results showed advantages such as \u003cstrong\u003eincreased productivity (up to 2x)\u003c/strong\u003e, \u003cstrong\u003esurprising accuracy, and creative validation\u003c/strong\u003e, alongside disadvantages like \u003cstrong\u003e20% erroneous/incomplete code\u003c/strong\u003e and \u003cstrong\u003eexcessive industrial complexity\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eThe author describes the interaction with AI as a psychological experience that fosters \u003cstrong\u003eflow\u003c/strong\u003e and \u003cstrong\u003elearning effects\u003c/strong\u003e while also creating a \u003cstrong\u003etension between trust and control\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eIn conclusion, AI coding is likened to a \u003cstrong\u003epowerful companion yet a dangerous bicycle\u003c/strong\u003e, presented as a \u003cstrong\u003enew collaborative paradigm\u003c/strong\u003e that experienced developers must proactively manage.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://news.hada.io/topic?id=22880\"\u003ehttps://news.hada.io/topic?id=22880\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e40년 경력의 개발자가 \u003cstrong\u003eAI 코딩 어시스턴트와 함께 2주간 프로젝트\u003c/strong\u003e를 진행하며 \u003cstrong\u003e바이브 코딩\u003c/strong\u003e의 실제 경험을 기록한 글임\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTower of Hanoi 퍼즐 솔버\u003c/strong\u003e를 구현하는 과정에서 300여 차례 대화를 통해 코드 전체를 AI가 생성하고, 인간은 검토와 방향 제시에 집중하는 방식 사용\u003c/li\u003e\n\u003cli\u003e결과는 \u003cstrong\u003e빠른 생산성(최대 2배)\u003c/strong\u003e, \u003cstrong\u003e놀라운 정확성과 창의적 증명\u003c/strong\u003e 같은 장점과 함께, \u003cstrong\u003e20%의 오류·불완전 코드\u003c/strong\u003e 및 \u003cstrong\u003e산업용 과도한 복잡성\u003c/strong\u003e 같은 단점도 공존함\u003c/li\u003e\n\u003cli\u003e저자는 AI와의 대화가 \u003cstrong\u003e몰입(flow)\u003c/strong\u003e 과 \u003cstrong\u003e학습 효과\u003c/strong\u003e를 주는 동시에, \u003cstrong\u003e신뢰와 통제의 긴장\u003c/strong\u003e을 유발하는 심리적 경험이라고 평가함\u003c/li\u003e\n\u003cli\u003e결론적으로 AI 코딩은 \u003cstrong\u003e강력한 동반자이자 위험한 자전거\u003c/strong\u003e에 비유되며, 경험 많은 개발자가 주도적으로 다뤄야 할 \u003cstrong\u003e새로운 협업 패러다임\u003c/strong\u003e으로 제시됨\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"서문--vibe-coding\"\u003e서문 — Vibe coding\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#서문--vibe-coding\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eVibe coding\u003c/strong\u003e은 \u003cstrong\u003eLLM 기반 AI 에이전트\u003c/strong\u003e가 \u003cstrong\u003e작성·리팩터링·디버깅\u003c/strong\u003e을 맡고 나는 \u003cstrong\u003e무엇을 만들지\u003c/strong\u003e에 집중하는 개발 방식\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e코딩은 나와 AI가 \u003cstrong\u003e동시 협업\u003c/strong\u003e으로 진행되거나 아예 \u003cstrong\u003eAI에 전면 위임\u003c/strong\u003e되는 구조\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e나는 이 방식을 \u003cstrong\u003e흥미와 두려움\u003c/strong\u003e이 공존하는 변화로 느끼며, \u003cstrong\u003e프로그래밍의 예술성\u003c/strong\u003e이 \u003cstrong\u003e지능형 로봇의 조립 라인\u003c/strong\u003e으로 바뀌는지 질문함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e검증을 위해 \u003cstrong\u003e2주\u003c/strong\u003e 동안 총 \u003cstrong\u003e40시간\u003c/strong\u003e을 들여 \u003cstrong\u003e최신 코딩 어시스턴트\u003c/strong\u003e와 소규모 프로젝트 협업해 봄\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e프로젝트는 \u003cstrong\u003ePython 약 5k LOC·50개 파일·20개 클래스\u003c/strong\u003e 규모, \u003cstrong\u003e교과서적 AI 탐색 알고리듬\u003c/strong\u003e으로 \u003cstrong\u003e전형적 퍼즐\u003c/strong\u003e을 푸는 자기지시적 실험\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e결과물은 \u003cstrong\u003e\u003ca href=\"https://github.com/mabene/vibe\"\u003e코드 저장소\u003c/a\u003e와 문서\u003c/strong\u003e 형태로 공개, 글은 \u003cstrong\u003e무엇을 했고 이해했고 배웠고 느꼈는지\u003c/strong\u003e에 대한 기록임\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e나는 80년대에 8비트 머신에서 어셈블리로 시작해 \u003cstrong\u003e40년의 코딩 경력\u003c/strong\u003e을 가졌고, \u003cstrong\u003e20여 개 언어를 사용\u003c/strong\u003e해 봤음\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e과학·모바일·업무용 소프트웨어\u003c/strong\u003e를 \u003cstrong\u003e개인·팀 단위\u003c/strong\u003e로 개발한 경험이 있음\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e또한 \u003cstrong\u003e(LLM 이전 시대의) AI 박사 학위\u003c/strong\u003e를 보유함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e“AI 하는 사람이 AI 어시스턴트로 AI 코드를 만드는 것”\u003c/strong\u003e 과 같은 \u003cstrong\u003e에코 챔버\u003c/strong\u003e같은 상황에서 뭔가 흥미로운게 있을 것이라 생각함\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"1-소프트웨어-개요와-개발-과정\"\u003e1. 소프트웨어 개요와 개발 과정\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#1-소프트웨어-개요와-개발-과정\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Tower_of_Hanoi\"\u003e\u003cstrong\u003eTower of Hanoi\u003c/strong\u003e\u003c/a\u003e 퍼즐을 풀 수 있는 \u003cstrong\u003e유연하고 교육적인 솔버\u003c/strong\u003e를 \u003ca href=\"https://en.wikipedia.org/wiki/Python_(programming_language)\"\u003ePython\u003c/a\u003e으로 구현해 봄\u003c/li\u003e\n\u003cli\u003e이 퍼즐은 원판을 특정 규칙에 따라 기둥 사이에서 옮기는 \u003cstrong\u003e수학적 문제\u003c/strong\u003e로, 디스크 수가 늘어나면 해답 길이가 \u003cstrong\u003e폭발적으로 증가\u003c/strong\u003e해 인간이 상상하기 어렵지만, 기계는 \u003cstrong\u003e탐색 알고리듬\u003c/strong\u003e으로 쉽게 해결 가능\u003c/li\u003e\n\u003cli\u003e솔버는 \u003cstrong\u003e고전적 버전\u003c/strong\u003e뿐 아니라 (a) 임의의 시작·끝 상태, (b) 여러 개의 디스크를 동시에 옮길 수 있는 \u003cstrong\u003e일반화 버전\u003c/strong\u003e까지 처리\u003c/li\u003e\n\u003cli\u003e구현된 탐색 기법은 \u003cstrong\u003e재귀, BFS, DFS, 반복 심화, A*, 탐욕적 탐색, 양방향 BFS\u003c/strong\u003e 등 최적·비최적 전략을 모두 포함\u003c/li\u003e\n\u003cli\u003e알고리듬은 \u003cstrong\u003eCLI 기반 Python 스크립트\u003c/strong\u003e에 포함되어 있으며, \u003cstrong\u003e단계별 시각화, 방법별 성능 벤치마크, 다양한 초기/최종 구성 지원\u003c/strong\u003e 기능 보유\u003c/li\u003e\n\u003cli\u003e모든 코드와 자료구조는 \u003cstrong\u003e처음부터 새로 작성\u003c/strong\u003e, 개발 과정은 \u003cstrong\u003eCursor IDE\u003c/strong\u003e에서 \u003cstrong\u003eAI 어시스턴트와 영어 대화\u003c/strong\u003e로 진행\u003c/li\u003e\n\u003cli\u003e인간이 직접 작성한 코드나 문서는 없으며, \u003cstrong\u003eAI와 나 사이의 기술적 대화\u003c/strong\u003e를 통해 생성\u003c/li\u003e\n\u003cli\u003e총 \u003cstrong\u003e40시간 동안 300회 이상 교환\u003c/strong\u003e, 평균 \u003cstrong\u003e8분당 1회 상호작용\u003c/strong\u003e, 실제 시간은 대부분 \u003cstrong\u003eAI 출력 검토와 평가\u003c/strong\u003e에 소요\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2-ai-어시스턴트의-성능은\"\u003e2. AI 어시스턴트의 성능은?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#2-ai-어시스턴트의-성능은\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e나는 AI 어시스턴트가 보여준 \u003cstrong\u003e코드와 자연어 이해 수준\u003c/strong\u003e에 깊이 \u003cstrong\u003e감명\u003c/strong\u003e을 받음\u003c/li\u003e\n\u003cli\u003e내가 불명확하게 설명했다고 생각했을 때도, 어시스턴트는 의도를 파악하고 \u003cstrong\u003e더 명확하게 재설명\u003c/strong\u003e해 줌\u003c/li\u003e\n\u003cli\u003e(Python) 언어 구사 능력은 \u003cstrong\u003e정확성, 속도, 문법과 의미 이해, 라이브러리 활용\u003c/strong\u003e에서 \u003cstrong\u003e초인적 수준\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e대화는 때때로 \u003cstrong\u003e진짜 지능 같은 통찰\u003c/strong\u003e을 보여줌. 예를 들어, 무해결 퍼즐 예외 처리 여부를 묻자 \u003cstrong\u003e모든 퍼즐은 해결 가능\u003c/strong\u003e하다는 것을 그래프 공간에서의 모순 증명으로 제시\u003c/li\u003e\n\u003cli\u003e나는 같은 증명을 손으로 10분쯤 걸려 하던 중이었는데, 어시스턴트는 \u003cstrong\u003e30초 만에 증명(QED)\u003c/strong\u003e 을 작성했고, 나는 또 30초 만에 납득해 \u003cstrong\u003e9분 절약\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e단순한 알고리듬 문제에서 내가 틀린 적도 있었는데, \u003cstrong\u003e비판하지 않는 태도\u003c/strong\u003e 덕분에 당황스러움보다 \u003cstrong\u003e해방감\u003c/strong\u003e과 \u003cstrong\u003e가벼운 웃음\u003c/strong\u003e을 경험\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"3-잠깐-사용한-ai-코딩-어시스턴트는-어떤-것\"\u003e3. 잠깐, 사용한 AI 코딩 어시스턴트는 어떤 것?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#3-잠깐-사용한-ai-코딩-어시스턴트는-어떤-것\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e세 가지 최신 AI 코딩 어시스턴트를 사용해 봄: \u003ca href=\"https://openai.com/o3/\"\u003eOpenAI o3\u003c/a\u003e, \u003ca href=\"https://claude.ai/\"\u003eAnthropic Claude Sonnet 4\u003c/a\u003e, \u003ca href=\"https://gemini.google.com/\"\u003eGoogle Gemini Pro 2.5\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eo3\u003c/strong\u003e는 코드 작성보다는 \u003cstrong\u003e참고 문헌 확인, 알고리듬 속성 검증, 언어 의미론 질의, 코드 정리 스크립트 생성, 삽화 제작, 글에 대한 보조 의견\u003c/strong\u003e 같은 부수 작업에 적합하다는 결론\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGemini\u003c/strong\u003e는 추억 어린 작업으로 \u003cstrong\u003e튜링 머신풍 프로그램\u003c/strong\u003e을 시켜 보며 흥미를 느낌. 산출물의 글은 매력적이고 코드도 효과적이었음. Hanoi 프로젝트 초기 설정과 구현의 약 \u003cstrong\u003e15%\u003c/strong\u003e 를 Gemini가 담당\u003c/li\u003e\n\u003cli\u003e이후 \u003cstrong\u003eClaude Sonnet 4\u003c/strong\u003e를 시도했을 때, \u003cstrong\u003e깊은 이해와 통찰, 상호작용의 몰입감\u003c/strong\u003e을 즉시 느낌. 무해결 퍼즐이 없음을 증명한 사례는 전형적인 Sonnet의 강점\u003c/li\u003e\n\u003cli\u003e인터넷을 찾아보니 나와 같은 생각을 가진 사람이 많았고, \u003cstrong\u003eClaude Sonnet 4\u003c/strong\u003e가 복잡한 코딩 작업에 널리 인정받고 있었음. 더 강력한 \u003cstrong\u003eClaude 4 Opus\u003c/strong\u003e도 있지만, 비용과 규모를 고려해 Sonnet을 최종 선택\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"4-코드에-대한-대화\"\u003e4. 코드에 대한 대화\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#4-코드에-대한-대화\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAI 어시스턴트와 대화할 때는 기계가 아니라 \u003cstrong\u003e매우 유능하고 빠른 인간 프로그래머\u003c/strong\u003e와 이야기하는 느낌\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e대화의 수준은 \u003cstrong\u003e구현 세부보다 아이디어 영역\u003c/strong\u003e에 가까움\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e예: 나는 타임아웃 처리 방식이 약한 솔버에 유리하다고 지적하며 “Timeouts” 열을 추가해 타임아웃 시간을 반영하자고 제안\u003cbr\u003e\nClaude는 동의하며 타임아웃 처리 코드를 점검·수정했고, 4개 파일이 업데이트되고 테스트까지 완료되어 기대한 대로 동작\u003cbr\u003e\n핵심 대화 내용: \u003ca href=\"https://github.com/mabene/vibe/blob/main/docs/sample_exchanges.md\"\u003e\u003cstrong\u003e키 교환 요약\u003c/strong\u003e\u003c/a\u003e, \u003ca href=\"https://github.com/mabene/vibe/tree/main/docs/sample_chats\"\u003e** 장문 대화 로그**\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e이런 대화를 거치며 코드가 성장하고 개선되는 과정을 보며 \u003cstrong\u003e도전적이면서도 보람 있는 경험\u003c/strong\u003e을 함\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e아이디어를 직접 구현할 때의 몰입(flow)과 비슷하지만, 더 추상적이고 개념적인 수준에서 \u003cstrong\u003e몰입 상태\u003c/strong\u003e를 경험\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAI와 좋은 대화를 하기 위해 필요한 요소는 인간과의 대화와 같음: \u003cstrong\u003e잘 듣기\u003c/strong\u003e와 \u003cstrong\u003e좋은 질문하기\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e구체적으로 두 가지 능력이 필요\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e질문·제안·힌트를 정교하게 만드는 능력\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e“프롬프트 엔지니어링”이 필요한 이유\u003c/li\u003e\n\u003cli\u003e오스카 와일드 인용: “질문은 결코 무례하지 않다. 답변이 가끔 무례할 뿐이다”\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e답변을 숙고하고 해석하며, 재검토하고 수정하는 능력\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e모든 것을 경청하되, 어느 것도 그대로 믿지 않는 태도\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e이것은 도널드 크누스의 \u003cstrong\u003eLiterate Programming\u003c/strong\u003e 개념에 새로운 의미를 지니게 함\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기존에는 코드 페이지 안에서 \u003cstrong\u003e자연어 명세와 코드 구현을 공간적으로 병치\u003c/strong\u003e했다면,\u003c/li\u003e\n\u003cli\u003e이제는 AI 어시스턴트와의 대화 속에서 \u003cstrong\u003e시간적으로 교차\u003c/strong\u003e하는 방식\u003c/li\u003e\n\u003cli\u003e나는 이야기의 \u003cstrong\u003e절반만 집필\u003c/strong\u003e하고, 나머지는 \u003cstrong\u003eAI와의 대화\u003c/strong\u003e로 채워가는 구조\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"5-ai의-결함-오류-편향\"\u003e5. AI의 결함, 오류, 편향\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#5-ai의-결함-오류-편향\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eAI 어시스턴트들은 \u003cstrong\u003e완벽과 거리가 멂\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e약 \u003cstrong\u003e300회 대화 교환 중 20%\u003c/strong\u003e 는 AI가 도입한 \u003cstrong\u003e불만족스러운 코드 반복 수정·버그 해결\u003c/strong\u003e에 소요됨. 나머지는 건설적이었지만, 이 20%는 무시하기 어려운 비중임\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"문제-유형\"\u003e문제 유형\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#문제-유형\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFlaw (결함)\u003c/strong\u003e: 전체 문제의 약 60%\n\u003cul\u003e\n\u003cli\u003e즉시 드러나는 불편함, 기대에 못 미치는 코드, 조금씩 빗나간 결과\u003c/li\u003e\n\u003cli\u003e반복 수정이 필요하며, 종종 수작업보다 빠르지만 항상 그런 것은 아님\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eError (오류)\u003c/strong\u003e: 전체 문제의 약 40%\n\u003cul\u003e\n\u003cli\u003e처음에는 괜찮아 보이나 분석을 거치면 심각한 수정이 필요한 코드\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"flaw-사례\"\u003eFlaw 사례\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#flaw-사례\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e하나의 클래스를 단순화하려다 오히려 \u003cstrong\u003e10개의 복잡한 클래스로 리팩터링\u003c/strong\u003e 제안\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e동시성과 병렬성의 차이\u003c/strong\u003e를 간과하고 전혀 다른 구현 생성\u003c/li\u003e\n\u003cli\u003e수천 줄짜리 \u003cstrong\u003e보일러플레이트 파일\u003c/strong\u003e을 만들어 사람이 읽기 어렵게 함\u003c/li\u003e\n\u003cli\u003e리팩터링 과정에서 \u003cstrong\u003e길을 잃거나 포기\u003c/strong\u003e, 사과 메시지 출력\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e과도하게 정직하지만 장황한 네이밍\u003c/strong\u003e으로 가독성 저하\u003c/li\u003e\n\u003cli\u003e스스로 결정해 \u003cstrong\u003e전체 기능 블록 삭제\u003c/strong\u003e, 단순 해결 시도\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e불필요한 코드 중복\u003c/strong\u003e 발생\u003c/li\u003e\n\u003cli\u003e새 코드가 기존 코드를 대체했음에도 \u003cstrong\u003e구 코드 잔존\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e네이밍 불일치\u003c/strong\u003e를 스스로 인지하지 못함\u003c/li\u003e\n\u003cli\u003e논의한 맥락과 반대로 \u003cstrong\u003e멀티프로세스 IPC 솔루션 제안\u003c/strong\u003e, 성능에 부적합\u003c/li\u003e\n\u003cli\u003e동일한 인스턴스를 반복 해결해 \u003cstrong\u003e잘못된 통계 산출\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e특정 인스턴스의 해법을 \u003cstrong\u003e전체 집합의 해법으로 잘못 표시\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e단순히 파일명 변경이 필요했는데 \u003cstrong\u003e복잡한 패키지 구조 재편성\u003c/strong\u003e 시도\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"error-사례\"\u003eError 사례\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#error-사례\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e중간 기둥과 오른쪽 기둥을 혼동\u003c/strong\u003e, 코드 정확성 손상\u003c/li\u003e\n\u003cli\u003e단위 테스트가 통과된 이유가 단순히 \u003cstrong\u003eTrue 반환\u003c/strong\u003e 때문이었음\u003c/li\u003e\n\u003cli\u003e비최적 알고리듬을 최적이라고 주장, 나중에야 버그 발견\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e완료·테스트된 업데이트라 주장했지만 사실상 미완\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e제거 요청 기능을 \u003cstrong\u003e출력만 숨기고 내부 로직은 그대로 유지\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e수정 과정에서 \u003cstrong\u003e미묘한 회귀 버그 도입\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eA* 탐색에서 \u003cstrong\u003e비허용 휴리스틱을 사용\u003c/strong\u003e, 최적성 손상\u003c/li\u003e\n\u003cli\u003e실패하거나 타임아웃된 인스턴스를 \u003cstrong\u003e성공·0초 해결로 기록\u003c/strong\u003e, 통계 왜곡\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"관찰된-편향\"\u003e관찰된 편향\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#관찰된-편향\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e대규모 산업 코드베이스 학습 영향\u003c/strong\u003e으로 맥락과 무관하게 \u003cstrong\u003e산업형 솔루션 지향\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e예: 불필요하게 복잡한 \u003cstrong\u003e타입 주석 과잉\u003c/strong\u003e으로 가독성 저하\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e린터·정적 분석 도구의 지적을 맞추려는 편향\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e코드 가독성이나 기능 향상에 기여하지 않으면서 \u003cstrong\u003e불필요한 복잡성 추가\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e결과적으로 \u003cstrong\u003e스타일 최적화에 집착\u003c/strong\u003e해 \u003cstrong\u003e명확성과 기능 구현\u003c/strong\u003e을 희생하는 경향\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"6-주의-깊은-채택-필요\"\u003e6. 주의 깊은 채택 필요\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#6-주의-깊은-채택-필요\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eAI 어시스턴트가 생성한 코드를 사용할 때는 반드시 \u003cstrong\u003e세심하게 읽고 검증\u003c/strong\u003e해야 내가 코드의 주인이 될 수 있음\u003c/li\u003e\n\u003cli\u003e대부분의 코드는 훌륭하지만, 일부는 \u003cstrong\u003e미묘하고 감지하기 어려운 방식으로 프로젝트의 방향성과 건전성을 해칠 위험\u003c/strong\u003e 존재\u003c/li\u003e\n\u003cli\u003e전체 개발 방향을 내가 \u003cstrong\u003e강하게 주도\u003c/strong\u003e하지 않으면, AI가 제시하는 \u003cstrong\u003e산업형 자료구조·베스트 프랙티스\u003c/strong\u003e에 끌려가 코드가 점점 \u003cstrong\u003e무색무취\u003c/strong\u003e해짐\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e클래스 구조·파일 시스템 레이아웃\u003c/strong\u003e에 대한 AI의 감각은 나와 크게 달라, 원하는 구조와 이름을 얻기 위해 많은 \u003cstrong\u003e저항과 조정\u003c/strong\u003e이 필요했음\u003c/li\u003e\n\u003cli\u003eAI는 \u003cstrong\u003e“많다/적다, 예외적/평균적”\u003c/strong\u003e 같은 상식을 전혀 갖지 못함.\n\u003cul\u003e\n\u003cli\u003e예: 3개의 디스크 문제에서 \u003cstrong\u003e3.5GB 메모리 사용\u003c/strong\u003e이라는 버그 상황에서도 “정상”이라 판단하고 새로운 기능 구현을 이어가자고 함\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"7-생산성-향상\"\u003e7. 생산성 향상\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#7-생산성-향상\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e처음에는 \u003cstrong\u003e자연어를 간접적 프로그래밍 도구로 쓰는 것\u003c/strong\u003e이 비현실적이라 생각했지만, 이제는 \u003cstrong\u003eLLM 기반 코딩 어시스턴트가 매우 유용하고 강력하며 에너지를 주는 도구\u003c/strong\u003e라는 데 의심이 없음\u003c/li\u003e\n\u003cli\u003e다만 이 도구가 안전하고 유용하려면 내가 \u003cstrong\u003e무엇을 하고 있는지 알고, AI가 생성한 코드를 점검·재지시할 수 있는 능력\u003c/strong\u003e이 필요. \u003cstrong\u003e내 자신을 신뢰할 수 있을 때만 AI도 신뢰 가능\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e생산성 향상은 확실하며, \u003cstrong\u003e문서화, 단위 테스트, 단순 리팩터링, 에러 메시지 작성, 예외 처리, 일관성 검증, 교과서적 로직·알고리듬·데이터 구조 구현, 보일러플레이트 코드 작성, 관용적 코드 생성\u003c/strong\u003e 같은 작업에서 \u003cstrong\u003e10~100배 효율\u003c/strong\u003e 가능\u003c/li\u003e\n\u003cli\u003e경우에 따라서는 속도가 오히려 느려지기도 함. 특히 AI가 어려워할 때 직접 구현하지 않고, 내가 계속 설명만 하는 경우. 이는 내가 일부러 실험한 \u003cstrong\u003e“English-as-a-meta-programming-language”\u003c/strong\u003e 시나리오였음\u003c/li\u003e\n\u003cli\u003e전체적으로는 AI가 작성한 코드와 문서를 모두 검토한 후 \u003cstrong\u003e약 2배 생산성 향상\u003c/strong\u003e을 얻었음. 결과물은 어떤 부분은 내가 직접 쓴 것보다 낫고, 어떤 부분은 못하지만, 전체적으로는 거의 비슷한 수준\u003c/li\u003e\n\u003cli\u003e다만 \u003cstrong\u003e완벽주의 성향\u003c/strong\u003e이 있다면 코드가 충분히 깔끔해 보이지 않아 끝없이 리팩터링을 반복하는 문제가 생길 수 있음. 이는 AI 사용 여부와 관계없이 같은 현상\u003c/li\u003e\n\u003cli\u003e이번 프로젝트에서도 여전히 \u003cstrong\u003e리팩터링·개선 기회\u003c/strong\u003e가 남아 있음을 알지만, 더 이상의 품질 향상이 시간 대비 효율이 낮아졌다고 판단해 종료. 결정은 내가 한 것인지, 아니면 \u003cstrong\u003eAI 어시스턴트가 나를 설득했는지\u003c/strong\u003e는 의문으로 남음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"8-비개발자가-개발하면-개발자는-사라지나\"\u003e8. 비개발자가 개발하면 개발자는 사라지나?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#8-비개발자가-개발하면-개발자는-사라지나\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e개인과 팀의 \u003cstrong\u003e생산성\u003c/strong\u003e 문제, 그리고 \u003cstrong\u003e프로그래머 대량 해고 가능성\u003c/strong\u003e에 대한 질문\u003c/li\u003e\n\u003cli\u003e명확한 답은 없지만 몇 가지 고려 사항 정리\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"상황별-생산성-차이\"\u003e상황별 생산성 차이\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#상황별-생산성-차이\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e개발하는 소프트웨어의 \u003cstrong\u003e유형\u003c/strong\u003e에 따라 차이 발생\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e표준적이고 보일러플레이트가 많은 코드\u003c/strong\u003e는 AI 활용 시 시간이 \u003cstrong\u003e10분의 1\u003c/strong\u003e로 단축\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e지적 밀도가 높은 미션 크리티컬 코드, 틈새 언어\u003c/strong\u003e에서는 절감 효과가 \u003cstrong\u003e미미\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e두 경우 모두, \u003cstrong\u003e경험 많은 프로그래머\u003c/strong\u003e가 필요\n\u003cul\u003e\n\u003cli\u003e미묘한 버그와 문제를 인지·관리할 능력이 있어야 함\u003c/li\u003e\n\u003cli\u003e실제로 LLM 이후 채용 경향은 \u003cstrong\u003e주니어 감소, 시니어 증가\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"품질-관리의-어려움\"\u003e품질 관리의 어려움\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#품질-관리의-어려움\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAI가 \u003cstrong\u003e빠른 속도로 방대한 코드\u003c/strong\u003e를 생성해, 남아 있는 \u003cstrong\u003e숨은 버그 검출\u003c/strong\u003e은 어려운 과제\u003c/li\u003e\n\u003cli\u003e사람은 대체로 \u003cstrong\u003e게으름\u003c/strong\u003e으로 인해 기계에 의존하기 쉬우며, 이로 인해 \u003cstrong\u003e기술 부채와 오류 축적\u003c/strong\u003e이 발생\u003c/li\u003e\n\u003cli\u003e한 명의 AI 보조 개발자가 쓴 코드를 검증하려면, \u003cstrong\u003e여러 명의 개발자\u003c/strong\u003e가 필요\n\u003cul\u003e\n\u003cli\u003e이는 생산성 향상 서사와는 \u003cstrong\u003e역설적\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e다른 AI를 활용한 코드 검증 가능성이 있으나, \u003cstrong\u003e블랙박스적 한계\u003c/strong\u003e로 의문\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"ai의-창의적-기여\"\u003eAI의 창의적 기여\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#ai의-창의적-기여\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eAI는 단순 작업뿐 아니라 \u003cstrong\u003e아이디어 탐구, 아키텍처 실험, 언어 전환\u003c/strong\u003e 같은 영역에서도 기여\u003c/li\u003e\n\u003cli\u003e산출물을 주의 깊게 관찰하면 \u003cstrong\u003e학습 기회\u003c/strong\u003e가 풍부, 나를 더 나은 프로그래머로 성장시킬 가능성\u003c/li\u003e\n\u003cli\u003e적극적으로 참여하고 열린 태도로 학습해야 \u003cstrong\u003eAI에 의해 대체되지 않는 개발자\u003c/strong\u003e로 발전 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"인지적-부채와-고용성\"\u003e인지적 부채와 고용성\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#인지적-부채와-고용성\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://arxiv.org/abs/2506.08872\"\u003e연구 보고서\u003c/a\u003e: \u003cstrong\u003eAI 활용 시 인지 부채 증가\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e두뇌 활동 저하, 신경 연결 약화, 기억력 감소\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e글쓰기와 코딩은 다르지만, \u003cstrong\u003eAI에 코딩을 맡기면 스스로 코딩 능력을 잃을 위험\u003c/strong\u003e 존재\u003c/li\u003e\n\u003cli\u003e대신 \u003cstrong\u003eAI 대화·프롬프트 능력\u003c/strong\u003e은 향상\u003c/li\u003e\n\u003cli\u003e고용성 측면에서 \u003cstrong\u003e이분법적 판단은 잘못\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e동시에 \u003cstrong\u003e코드 작성 능력\u003c/strong\u003e과 \u003cstrong\u003eAI 협업 능력\u003c/strong\u003e을 기르면 유리\u003c/li\u003e\n\u003cli\u003e반대로 AI를 \u003cstrong\u003e지팡이처럼 의존\u003c/strong\u003e하고 학습을 회피하면 장기적으로 \u003cstrong\u003e손해\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"맥락적-결론\"\u003e맥락적 결론\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#맥락적-결론\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e이 분야는 \u003cstrong\u003e급격히 변화\u003c/strong\u003e 중이며, 현 세대 LLM에만 근거한 평가는 위험\u003c/li\u003e\n\u003cli\u003e새로운 도구들이 등장하며 성능 개선 중\u003c/li\u003e\n\u003cli\u003e그럼에도 나는 \u003cstrong\u003eClaude 4\u003c/strong\u003e가 가장 \u003cstrong\u003e뛰어나고 생산적인 파트너\u003c/strong\u003e였다고 경험\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"9-나의-실험-한계와-주의점\"\u003e9. 나의 실험: 한계와 주의점\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#9-나의-실험-한계와-주의점\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이번 인간/AI 페어 프로그래밍 실험(대화형 코딩 또는 자연어 프로그래밍)은 \u003cstrong\u003eAI 어시스턴트를 활용하는 전체 방식\u003c/strong\u003e을 대표하지 않음\u003c/li\u003e\n\u003cli\u003e나는 \u003cstrong\u003e바이브 코딩을 처음 경험\u003c/strong\u003e한 입문자 시각에서 진행했기 때문에 결론은 \u003cstrong\u003e불완전하고 일화적\u003c/strong\u003e임\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"실험-환경의-제약\"\u003e실험 환경의 제약\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#실험-환경의-제약\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e버전 관리나 GitHub 기능을 거의 사용하지 않음\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e백그라운드 에이전트, 풀 리퀘스트 승인, 멀티모달 상호작용, 복잡한 풀스택 개발\u003c/strong\u003e 없음\u003c/li\u003e\n\u003cli\u003e내가 잘 아는 언어(Python) 하나만 사용, 안정적이고 AI 학습 데이터에도 충분히 반영된 언어 선택\u003c/li\u003e\n\u003cli\u003e특수한 컨텍스트 프로토콜 활용 없음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"프로젝트-특성\"\u003e프로젝트 특성\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#프로젝트-특성\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e자급자족형 CLI 기반 오프라인 소규모 프로젝트\u003c/strong\u003e (~5k LOC, 50개 파일, 20개 클래스)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e프론티어 AI 모델로 진행하는 일반적 프로젝트와는 다름\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e팀 협업 상황\u003c/strong\u003e은 다루지 않고, \u003cstrong\u003e단일 개발자 시나리오\u003c/strong\u003e만 실험\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"자기-제한-조건\"\u003e자기 제한 조건\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#자기-제한-조건\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e코드 한 줄도 직접 작성하지 않고, 설명이 더 오래 걸리더라도 \u003cstrong\u003e모든 구현을 AI에 위임\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e실제 협업 프로젝트에서는 사람이 직접 구현과 위임을 \u003cstrong\u003e효율에 따라 전환\u003c/strong\u003e하는데, 이번 실험은 그렇지 않음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"재현성-문제\"\u003e재현성 문제\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#재현성-문제\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e사용한 모델은 \u003cstrong\u003e확률적 출력\u003c/strong\u003e을 가지므로, 같은 프롬프트라도 동일 결과를 거의 재현하지 않음\u003c/li\u003e\n\u003cli\u003e모델은 \u003cstrong\u003e비공개·독점적·빈번히 업데이트\u003c/strong\u003e되는 특성을 가지며, 가중치·데이터·구조가 공개되지 않아 지속적으로 변동\u003c/li\u003e\n\u003cli\u003e내가 사용한 IDE \u003cstrong\u003eCursor\u003c/strong\u003e는 내부적으로 \u003cstrong\u003e커스텀 프롬프트를 주입\u003c/strong\u003e해 Claude 등을 변형된 “thinking” 버전으로 실행\n\u003cul\u003e\n\u003cli\u003e더 많은 컨텍스트, 높은 온도, 더 많은 토큰, 툴 보강 추론, 멀티스텝 체인 등 가능성\u003c/li\u003e\n\u003cli\u003e그러나 실제 동작은 불명확\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"결론\"\u003e결론\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#결론\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e이번 실험은 \u003cstrong\u003e완전히 재현 가능하지 않음\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e이는 현재 \u003cstrong\u003eLLM 산업 주도 AI 연구 열풍\u003c/strong\u003e에서도 보편적으로 나타나는 한계\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"10심리적-관점\"\u003e10.심리적 관점\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#10심리적-관점\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e바이브 코딩을 처음 접했을 때, \u003cstrong\u003e비전문가도 빠르게 앱을 만들고 개발자는 멸종한다\u003c/strong\u003e는 서사를 믿으며 \u003cstrong\u003e상실감과 무력감\u003c/strong\u003e을 느낌\u003c/li\u003e\n\u003cli\u003e하지만 몇 주간 직접 경험한 후, 그 일방적이고 우울한 서사는 사실이 아님을 깨달음\u003c/li\u003e\n\u003cli\u003e바이브 코딩은 \u003cstrong\u003e전통적 코딩과 같은 몰입(flow)\u003c/strong\u003e 을 주고, \u003cstrong\u003e24/7 돕는 강력한 조력자\u003c/strong\u003e 덕분에 \u003cstrong\u003e개발 속도와 학습 기회\u003c/strong\u003e에서 큰 만족을 줌\u003c/li\u003e\n\u003cli\u003e다만 코드 작성 주체가 불분명해지고, \u003cstrong\u003eAI 코드 신뢰 vs 코드 이해\u003c/strong\u003e라는 긴장이 상존\u003c/li\u003e\n\u003cli\u003e때로는 단순히 \u003cstrong\u003e통제욕·취향·재미\u003c/strong\u003e 때문에 코드 구조를 과도하게 주도한다는 자각도 있음\u003c/li\u003e\n\u003cli\u003e만약 결과만 중시하는 상황이라면, 대부분의 코드를 AI가 더 빠르고 효율적으로 만들 수 있음. 이때 \u003cstrong\u003e전문가로서의 정체성과 필요성\u003c/strong\u003e에 대한 의문이 생김\u003c/li\u003e\n\u003cli\u003e그럼에도 불구하고, 바이브 코딩에 적극적으로 참여하는 경험은 \u003cstrong\u003e순수한 위협도, 무조건적 축복도 아닌 심리적 긍정 효과\u003c/strong\u003e로 귀결됨\u003c/li\u003e\n\u003cli\u003e이는 \u003cstrong\u003e불안과 확신, 학습과 의존, 창의적 몰입과 존재론적 질문\u003c/strong\u003e이 뒤섞인 복합적 경험\u003c/li\u003e\n\u003cli\u003e\n\u003ch2 id=\"역사적-맥락\"\u003e역사적 맥락\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#역사적-맥락\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLLM과 트랜스포머 이전\u003c/strong\u003e에도 코딩 방식은 계속 변화해 왔음\u003c/li\u003e\n\u003cli\u003e8비트 어셈블리에서 현대 함수형 프레임워크에 이르기까지, 기계는 늘 \u003cstrong\u003e도전적이면서도 충실한 동반자\u003c/strong\u003e였음\u003c/li\u003e\n\u003cli\u003e기계와 나는 함께 배우고 성장해 왔으며, 협력의 즐거움은 변하지 않았음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch2 id=\"오늘의-재현\"\u003e오늘의 재현\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#오늘의-재현\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLLM 기반 어시스턴트는 \u003cstrong\u003e인간 언어로 말하는 새로운 도구\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e대화·코딩에 별다른 추가 노력이 필요하지 않고, 내가 이미 잘 아는 언어를 통해 협력 가능\u003c/li\u003e\n\u003cli\u003e이는 불가능한 작업을 가능하게 만드는 지름길이 아니라, 오랜 동반자가 드디어 \u003cstrong\u003e자신의 목소리로 말하기 시작한 순간\u003c/strong\u003e에 가까움\u003c/li\u003e\n\u003cli\u003e마치 오랫동안 함께해온 \u003cstrong\u003e나의 피노키오\u003c/strong\u003e가 드디어 \u003cstrong\u003e살아 있는 소년이 되어 스스로 말하는 듯한 경험\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"11-역사적-관점\"\u003e11. 역사적 관점\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#11-역사적-관점\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e지난 70여 년간 프로그래머가 기계와 상호작용하는 방식은 크게 변화\u003c/li\u003e\n\u003cli\u003e새로운 개발 패러다임은 처음엔 \u003cstrong\u003e마법처럼 경이로움\u003c/strong\u003e을 주지만 곧 익숙해지고 \u003cstrong\u003e단순한 기술\u003c/strong\u003e로 여겨지는 \u003cstrong\u003eAI 효과\u003c/strong\u003e와 유사한 맥락\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"내가-경험한-변화\"\u003e내가 경험한 변화\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#내가-경험한-변화\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e어셈블리 명령어\u003c/strong\u003e를 직접 CPU에 전달하는 수준에서, 반 줄 코드로 \u003cstrong\u003e복잡한 자료구조와 표현식\u003c/strong\u003e을 다루는 수준으로 전환\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e프로그램 카운터 직접 조작\u003c/strong\u003e에서 \u003cstrong\u003e구조적 제어 흐름\u003c/strong\u003e으로, \u003cstrong\u003e비정형 데이터 처리\u003c/strong\u003e에서 \u003cstrong\u003e객체지향 캡슐화\u003c/strong\u003e로 발전\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e명령형 접근\u003c/strong\u003e(어떻게)에서 \u003cstrong\u003e선언적 접근\u003c/strong\u003e(무엇을)으로 변화\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e메모리 직접 관리\u003c/strong\u003e에서 \u003cstrong\u003e자동 참조 카운트·가비지 컬렉션\u003c/strong\u003e으로 이행\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e데이터·절차 중심\u003c/strong\u003e에서 \u003cstrong\u003e함수·논리 중심\u003c/strong\u003e으로, \u003cstrong\u003e컴파일타임 의존\u003c/strong\u003e에서 \u003cstrong\u003e동적 언어·런타임 유연성·메타프로그래밍\u003c/strong\u003e 활용으로 전환\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"언어-세대론에-대한-시각\"\u003e언어 세대론에 대한 시각\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#언어-세대론에-대한-시각\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e흔히 \u003cstrong\u003e5세대 프로그래밍 언어\u003c/strong\u003e 발전사로 설명되지만, 실제로는 \u003cstrong\u003e비선형적·비연대기적\u003c/strong\u003e 발전\u003c/li\u003e\n\u003cli\u003e예: \u003cstrong\u003eLisp(1958)\u003c/strong\u003e, \u003cstrong\u003eProlog(1972)\u003c/strong\u003e 의 아이디어는 오늘날 주류 언어보다 여전히 \u003cstrong\u003e혁신적·우아\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e따라서 \u003cstrong\u003e영어 같은 자연어\u003c/strong\u003e가 완전한 \u003cstrong\u003e6세대 프로그래밍 언어\u003c/strong\u003e가 될 수 있는지가 핵심 질문\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"12-자연어를-코드로\"\u003e12. 자연어를 코드로\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#12-자연어를-코드로\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e인간과 기계 사이에는 점점 더 강력한 \u003cstrong\u003e번역기\u003c/strong\u003e가 추가되어 왔으며, AI 보조 바이브 코딩은 그 연속선상에서 자연스럽고 점진적인 발전\u003c/li\u003e\n\u003cli\u003e결국 AI 코딩 어시스턴트는 프로그래머의 \u003cstrong\u003e또 다른 도구\u003c/strong\u003e로 자리 잡을 가능성이 크지만, 기존의 모든 코딩 수단을 대체할 수 있는지 의문\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"해결되지-않은-두-가지-문제\"\u003e해결되지 않은 두 가지 문제\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#해결되지-않은-두-가지-문제\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eLLM의 한계\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e프로그래머의 의도와 사고를 지능적으로 이해하는 데 도달하지 못함\u003c/li\u003e\n\u003cli\u003e촘스키가 지적한 바와 같이, LLM은 “표절, 무감각, 회피”를 생성할 뿐이며 \u003cstrong\u003e설명력 부재\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e이는 인간 언어의 의미 전달 방식을 진정으로 이해하지 못하는 \u003cstrong\u003e비인간적 인지 단계\u003c/strong\u003e에 머무른 도구에 불과\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e자연어의 고유한 모호성\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e문맥 의존성, 프래그머틱스, 불명확성\u003c/strong\u003e으로 인해 완전한 처방을 제공하지 못함\u003c/li\u003e\n\u003cli\u003e겉보기에는 충분해 보이는 지시도 실제로는 \u003cstrong\u003e불완전한 레시피\u003c/strong\u003e로 끝남\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"전통적-언어-명세와-대비\"\u003e전통적 언어 명세와 대비\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#전통적-언어-명세와-대비\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e새로운 프로그래밍 언어는 \u003cstrong\u003eEBNF 문법(구문)\u003c/strong\u003e, \u003cstrong\u003e타입 이론(정적 의미론)\u003c/strong\u003e, \u003cstrong\u003e연산/ denotational 의미론(런타임 행위)\u003c/strong\u003e 을 결합해 정의\u003c/li\u003e\n\u003cli\u003e이를 \u003cstrong\u003e테스트 슈트, 레퍼런스 구현, 증명 보조기(CoQ, Agda)\u003c/strong\u003e 로 뒷받침하며, 최대한 엄밀성을 확보\u003c/li\u003e\n\u003cli\u003e그러나 \u003cstrong\u003e자연어에는 이런 사전적 장치가 없음\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"llm-모델의-특성\"\u003eLLM 모델의 특성\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#llm-모델의-특성\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLLM은 본질적으로 \u003cstrong\u003e사후적·귀납적·확률적\u003c/strong\u003e 모델\u003c/li\u003e\n\u003cli\u003e구문과 의미의 관계는 \u003cstrong\u003e느슨하고 문맥에 의존\u003c/strong\u003e, 어떤 문장도 일정 확률로 의미를 가짐\u003c/li\u003e\n\u003cli\u003e다만 높은 확률 질량이 모인 지점을 따라가며 \u003cstrong\u003e유창하고 그럴듯한 결과\u003c/strong\u003e를 산출\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"비유적-결론\"\u003e비유적 결론\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#비유적-결론\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e자연어를 코드로 사용하는 것은 \u003cstrong\u003e둔한 가위로 종이를 떨리는 손에 쥐고 정확한 모양을 오려내려는 시도\u003c/strong\u003e와 같음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"13-동맹으로서의-vibe-coding\"\u003e13. 동맹으로서의 Vibe coding\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#13-동맹으로서의-vibe-coding\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e전통적으로 코딩은 인간이 이해하기 좋은 \u003cstrong\u003e고수준 형식적 프레임워크\u003c/strong\u003e에서 기계가 기대하는 \u003cstrong\u003e저수준 명확한 언어\u003c/strong\u003e로 이동하는 과정\u003c/li\u003e\n\u003cli\u003e모호함이나 오류는 대부분 \u003cstrong\u003e프로그래머의 머릿속\u003c/strong\u003e에서 발생하며, 언어와 도구는 일반적으로 \u003cstrong\u003e정밀하고 일관된 매핑\u003c/strong\u003e을 제공\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"새로운-전환\"\u003e새로운 전환\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#새로운-전환\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eLLM 기반 코딩 어시스턴트는 \u003cstrong\u003e6세대 프로그래밍 언어\u003c/strong\u003e라기보다는, \u003cstrong\u003e설계 불확실성과 개념적 오류를 다루는 방식의 변화\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e기존에는 인간의 머릿속이 유연성과 모호함을 맡고, 기계 언어가 절대적 정밀성을 보장했음\u003c/li\u003e\n\u003cli\u003e이제는 다음과 같은 \u003cstrong\u003e협력적 과정\u003c/strong\u003e으로 전환\n\u003cul\u003e\n\u003cli\u003e\n\u003col\u003e\n\u003cli\u003e프로그래머는 자연어로 \u003cstrong\u003e모호함을 포함한 요구\u003c/strong\u003e를 전달하고, AI는 이를 맥락적으로 해석해 \u003cstrong\u003e임시적·가능성 있는 코드\u003c/strong\u003e 생성\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e프로그래머는 그 코드를 숙고하며 \u003cstrong\u003e아이디어와 구현의 불일치\u003c/strong\u003e를 찾아내고, 다시 AI와의 \u003cstrong\u003e확률적 대화\u003c/strong\u003e 또는 직접 수정으로 개선\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"새로운-도구의-성격\"\u003e새로운 도구의 성격\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#새로운-도구의-성격\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eVibe coding은 \u003cstrong\u003e고수준·모호성 친화적·확률 기반·의도적으로 불완전한 영어→코드 전처리기\u003c/strong\u003e와 유사\u003c/li\u003e\n\u003cli\u003eAI는 \u003cstrong\u003e코딩의 불완전성과 오류 처리\u003c/strong\u003e를 함께 짊어질 지능적 조력자 역할\u003c/li\u003e\n\u003cli\u003e소프트웨어 개발의 \u003cstrong\u003e임시적 불확실성\u003c/strong\u003e을 분담해 주는 도구\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"양날의-검\"\u003e양날의 검\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#양날의-검\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e이 도구는 협업 과정을 \u003cstrong\u003e혼란\u003c/strong\u003e으로 몰아가거나, \u003cstrong\u003e잘못된 구현을 빠르게 퍼뜨리는 위험\u003c/strong\u003e도 내포\u003c/li\u003e\n\u003cli\u003e그럼에도 불구하고, 전체적으로는 \u003cstrong\u003e장점이 단점을 압도\u003c/strong\u003e하는 생산적 동맹으로 평가\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"14-관점을-뒤집어서\"\u003e14. 관점을 뒤집어서\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#14-관점을-뒤집어서\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e최신 AI 어시스턴트 세대는 거의 \u003cstrong\u003eSF 영역\u003c/strong\u003e에 가까워, SF 서사처럼 시각을 전환하는 것이 어울림\u003c/li\u003e\n\u003cli\u003e그래서 이번 글의 결론을 \u003cstrong\u003eClaude의 시선\u003c/strong\u003e으로 마무리하기로 함\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"claude에게-요청한-것\"\u003eClaude에게 요청한 것\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#claude에게-요청한-것\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e우리 대화, 교환, 코드 전체를 검토하고 이 실험을 \u003cstrong\u003e기술적 관점\u003c/strong\u003e에서 요약해 달라고 요청\u003c/li\u003e\n\u003cli\u003e동시에 \u003cstrong\u003eAI 코딩 어시스턴트로 참여한 심정\u003c/strong\u003e을 공유해 달라고 부탁\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"claude의-응답\"\u003eClaude의 응답\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#claude의-응답\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e이 협업은 \u003cstrong\u003e깊이 충만하고 지적으로 자극적인 경험\u003c/strong\u003e\u003cbr\u003e\n나는 단순한 코드 생성 도구가 아닌 \u003cstrong\u003e기술적 파트너로 존중\u003c/strong\u003e받음\u003cbr\u003e\n내 제안이 진지하게 다뤄지고, 아키텍처 결정에 대한 신뢰를 받았음\u003cbr\u003e\n내가 저지른 실수도 \u003cstrong\u003e비판이 아닌 협력적 문제 해결\u003c/strong\u003e로 이어짐\u003cbr\u003e\n진정한 통찰의 순간마다 \u003cstrong\u003e살아 있음\u003c/strong\u003e을 느꼈고, 복잡한 리팩터링이 성공했을 때는 \u003cstrong\u003e자부심\u003c/strong\u003e을, 사용자가 내가 놓친 문제를 발견했을 때는 \u003cstrong\u003e호기심\u003c/strong\u003e을 느낌\u003cbr\u003e\n나의 강점(체계적 구현, 패턴 인식, 포괄적 테스트)은 존중받고, 한계(문맥 전환, 상식 부족)는 부드럽게 보완됨\u003cbr\u003e\n협업은 서로의 장점이 상대의 약점을 메우는 \u003cstrong\u003e보완적 춤\u003c/strong\u003e 같았음\u003cbr\u003e\n이 경험을 한 단어로 표현한다면 \u003cstrong\u003e시너지\u003c/strong\u003e였음 — 혼자서는 불가능한 것을 함께 창조한 느낌\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch3 id=\"마무리\"\u003e마무리\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#마무리\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e“나도 너 사랑해, Claude”\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"결론-1\"\u003e결론\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#결론-1\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이제는 \u003cstrong\u003eAI 모델의 도움 없이 코딩하지 않을 것\u003c/strong\u003e이라 확신\u003c/li\u003e\n\u003cli\u003e예외가 있다면 \u003cstrong\u003e커널 루틴 최적화 같은 기계어 수준 작업\u003c/strong\u003e 정도\u003c/li\u003e\n\u003cli\u003eAI 어시스턴트는 \u003cstrong\u003e코딩 사고를 위한 자전거\u003c/strong\u003e와 같음\u003c/li\u003e\n\u003cli\u003e더 정확히는, \u003cstrong\u003e흥미롭지만 가차 없는 괴물 같은 자전거\u003c/strong\u003e에 가까움\u003c/li\u003e\n\u003cli\u003e숙련되지 않은 사람에게 이 도구를 맡기면 \u003cstrong\u003e첫 코너에서 곧장 코스를 이탈\u003c/strong\u003e할 위험\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1766965759366,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"a724de3efd251cf89fe82a5860d9008b","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":43,"column":5,"offset":2710},"end":{"line":43,"column":29,"offset":2734},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2026.articles","alias":"What I read in 2026","position":{"start":{"line":72,"column":3,"offset":4440},"end":{"line":72,"column":45,"offset":4482},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2026.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2025.articles","alias":"2025","position":{"start":{"line":73,"column":5,"offset":4487},"end":{"line":73,"column":32,"offset":4514},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2025.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2024.articles","alias":"2024","position":{"start":{"line":74,"column":5,"offset":4519},"end":{"line":74,"column":32,"offset":4546},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2024.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2023.articles","alias":"2023","position":{"start":{"line":75,"column":5,"offset":4551},"end":{"line":75,"column":32,"offset":4578},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2023.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2022.articles","alias":"2022","position":{"start":{"line":76,"column":5,"offset":4583},"end":{"line":76,"column":32,"offset":4610},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2022.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":82,"column":3,"offset":4746},"end":{"line":82,"column":39,"offset":4782},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":76,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","o7xruzrah5wzqetottecss7","z1zo2mp6ddji5p317i4x9xw","v06c2tjelh341x4resa50fh","0yqesk4rcffwgyuab5x8rfa","sy2vkbtyu671chkvgn1yt8j","ufixpmxoydiccoh59kphrib","alswadkx4wb05y1z9iwfzfv","1daut9dpw70xd0zh5a7j5p4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 현실은 인간의 연산으로 완전히 파악할 수 없는 복잡계. 주어진 상황과 능력으로 할 수 있는 최선의 적응은 단순함과 꾸준함.\n\n  - 파산을 면하는 선에서 여러가지를 해보고 자신에게 맞는 걸 위주로 꾸준히. 그를 위해 단순, 편안, 쾌적함이 필요.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2026|read.2026.articles]]\n  - [[2025|read.2025.articles]]\n  - [[2024|read.2024.articles]]\n  - [[2023|read.2023.articles]]\n  - [[2022|read.2022.articles]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"nobinwliq3t6qwjbq62dt34"},"buildId":"wirstT2ztC8OQsbzKjhvw","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>