<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Code Vs No-code</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Code Vs No-code"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/ja7ebcppxm73uxmqol3tkug/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="6/23/2022"/><meta property="article:modified_time" content="6/23/2022"/><link rel="canonical" href="https://luke-snaw.github.io//notes/ja7ebcppxm73uxmqol3tkug/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_buildManifest.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="code-vs-no-code">Code Vs No-code<a aria-hidden="true" class="anchor-heading icon-link" href="#code-vs-no-code"></a></h1>
<blockquote>
<p><a href="https://jasonmorrissc.github.io/post/2022-02-24_no-code/">https://jasonmorrissc.github.io/post/2022-02-24_no-code/</a><br>
<a href="https://news.ycombinator.com/item?id=31843378">https://news.ycombinator.com/item?id=31843378</a></p>
</blockquote>
<p>There was a conversation on Twitter this week that helped to clarify my thinking about something, and I wanted to share.</p>
<p>There is a sort of tension between “code” and “no-code” (sometimes “low-code”) solutions.</p>
<p>People who consider themselves software developers see people trying to use no-code solutions to do things that the no-code solutions are not good at, and they get frustrated that the capabilities of those tools has been overestimated.</p>
<p>They are taking something that is really happening, and they are interpreting it really wrong. It’s useful and important to understand how, and why.</p>
<h3 id="the-complexityeffort-curve">The Complexity/Effort Curve<a aria-hidden="true" class="anchor-heading icon-link" href="#the-complexityeffort-curve"></a></h3>
<p>Let’s simplify the world, and pretend that effort is a single dimension, where things are always “harder” or “easier” along a single spectrum. Let’s also simplify the world and pretend that the complexity of the software project is also on a single dimension that goes from “simple” to “complex.” Neither of these things is true, but it helps to pretend.</p>
<p>If those things are true, then each software tool, whether a programming language, an app, or a no-code solution that sits somewhere in the middle between the two, has an effort/complexity curve. This line maps how difficult it is to use this tool for a task of the given complexity.</p>
<p>All tools are going to have a line with a positive correlation, but the shape of the line will differ. If a tool is very hard to learn, but very powerful, it will start high, and flatten out faster. Like, say, a programming language.</p>
<p><img src="https://jasonmorrissc.github.io/code_graph.png"></p>
<p>If a tool is easy to learn, and useful for simple things, but the simplifications become obstacles when you get into higher complexity, then the line will start low, and accellerate upward. Like, say, a no-code solution.</p>
<p><img src="https://jasonmorrissc.github.io/no_code_graph.png"></p>
<p>Now, if you are a person who knows both programming languages and no code tools, this seems like a simple problem. The combination of the two lines looks like this, and you can see the level of complexity at which they cross.</p>
<p><img src="https://jasonmorrissc.github.io/both_graph.png"></p>
<p>This is why programmers who are familiar with no-code tools say things like “people overestimate what these tools can do.” Because they see people on the right side of the dotted line, using no-code solutions, and they assume that the person must misunderstand where the orange line actually lies.</p>
<p>That’s not what’s happening. In the mind of the person who uses no-code tools and is not a programmer, this is what’s happening.</p>
<p><img src="https://jasonmorrissc.github.io/what_they_know.png"></p>
<p>They don’t know the shape of the curve for programming, because <em>that</em> is the thing they <em>haven’t</em> used. They may not understand the curve for no-code tools perfectly, but they definitely understand it better.</p>
<p>Given that information, what decision would you make?</p>
<p>You would obviously use the tool you have.</p>
<p>But even if we could educate people on the positions of the relative curves, the vertical dotted line represents best alternative in the abstract. It does not reflect the thing that the person actually cares about. If they are looking at doing something that is slightly beyond the point where using the no code tool is the best option, they are worried about new effort, not existing effort. They know how hard it is to do the things they have done before, and they are willing for future things to be at least that hard.</p>
<p>There is an increased amount of effort that they are willing to go through to get to this new level of complexity, and for each tool, they have a comfort level.</p>
<p>So if you imagine a person who has used the no-code tool for something before, but has never used code before, how do they do the math?</p>
<p><img src="https://jasonmorrissc.github.io/new_effort.png"></p>
<p>If you are trying to minimize the discomfort of not knowing what you are doing, you will continue to use the tools you know long after they are no longer the best tools for the job. And the each time you do it, you reduce the apparent cost of using the same tool again.</p>
<h2 id="so-what-do-we-do">So What Do We Do?<a aria-hidden="true" class="anchor-heading icon-link" href="#so-what-do-we-do"></a></h2>
<p>We need to tell people where the blue line is, right? We need to educate people better about what tools are good for what.</p>
<p>Sorry, no. Educate all you want, it doesn’t change the fact that in the beginning, the harder tools are harder. No one starts on the black diamond slope. Everyone starts on the bunny slope. People with high tolerance for the difficulty of learning programming are already well served by what we have, and people with a low tolerance for it will not be convinced if we merely insist.</p>
<p>You can <em>help</em> solve this problem by making the curve more visible from the beginning. If you can show people the range of uses of the tool, from simple to complex, and that demonstration is meaningful, then great. But even then, you are going to need to overcome the fact that people do not generally want to start with the harder thing.</p>
<p>So in an ideal world, what we need is tools that have a effort/complexity curve that is both visible, and looks like this:</p>
<p><img src="https://jasonmorrissc.github.io/ideal.png"></p>
<h2 id="how-do-you-do-it">How do you do it?<a aria-hidden="true" class="anchor-heading icon-link" href="#how-do-you-do-it"></a></h2>
<p>There are a lot of people a lot smarter than me working on that problem. If you’re interested, the <a href="https://futureofcoding.org/">Future of Coding</a> community is one that has a lot to say on the topic.</p>
<p>There are two main problems. The first is how to get the beginning of the curve lower. That’s the problem that the people selling no-code solutions are tackling, and with real success. They are empowering people, and that is a thing people will pay for.</p>
<p>For that problem, some of the answers seem to be to specialize the tools to small problem domains, eliminate text as the primary user interface, and replace it with something that fits the domain of the problem. It is a design problem, and one that people have made a lot of progress on.</p>
<p>The other main problem is how do you avoid the making complexity more expensive?</p>
<p>This is less obvious. Domain specificity can help, because you can say “if you want more, go elsewhere”, and then combine tools that each do a small thing well. Tying no-code tools together, in a no-code way, is the basic idea behind tools like Zapier, which have been wildly successful. But people inevitably want to do more, and it becomes harder to support in the simplified interface.</p>
<p>Another possibility that I’m pursuing with Blawx is the idea that it doesn’t need to be just one tool. You can have the beginner’s no-code tool that teaches the person to use the advanced code tool. Blawx lets the user see what s(CASP) code is being written for them. In that way, using Blawx can teaches you s(CASP), and you are less trapped inside the tool you already know when you reach its limits. But commercial no-code solutions often do not want their customers to escape in this way, so it may not be realistic to expect from commercial no-code solutions.</p>
<p>Another possibility is a tool that modifies itself in sophistication along with the user. We could have “beginner mode” and “advanced mode”, and try to detect when the features of the advanced mode would help what the user is currently doing. Imagine a programming language that doesn’t introduce the concept of a function until after you type almost the same code twice.</p>
<p>I have seen nothing of the sort, it’s just an idea.</p>
<p>Another possibility is that programming languages already have a sort of optimal effort/complexity curve at the high complexity end, so if we can just lower the start of the curve for an actual programming language, that solves the problem.</p>
<p>You can paint efforts to teach programming to children into this box, to some degree. Or, efforts to teach programming at all. But even in the world of Scratch and Blockly, the people involved insist they are not trying to replace programming languages, they are trying to promote the learning of them. Ultimately, they expect people to type code into a development environment. That has always seemed like a lack of vision, to me.</p>
<p>No one, that I am aware of, is trying to build a programming language that scales in complexity all the way from good-for-kids to general-purpose programming language.</p>
<h3 id="the-point">The Point<a aria-hidden="true" class="anchor-heading icon-link" href="#the-point"></a></h3>
<p>The point is, if people are choosing to do something one way, and not the “better” way, the problem is never with the people, the problem is with the “better” way. People will do what costs the least, but the costs are measured in stress, ambiguity, effort, and human experience.</p>
<p>Consider a hammer. A hammer is designed to do a specific thing. In the context of that thing, how to use it is obvious. But more than that, when you pick it up, you can feel intuitively what you are capable of now that you weren’t without it. You can imagine using it to do simple things, and complicated things. And you can imagine, and maybe even aspire to, getting better at using it.</p>
<p>That is the experience that any software tool should aspire to. Obviously valuable, obviously scalable, intuitive. Learning it should feel like play.</p>
<p>The fact that we programmers, who lived in the sliver of time shortly after the invention of programming, managed to acquire the skills to deploy it, doesn’t mean it has reached its evolutionary apex. Programming can be much, much better than it is. But only if the people who already understand it can genuinely focus on the interests of the people who don’t, without the hubris of assuming that their aspiration should be to become like us.</p>
<p>It is undoubtedly possible to share the power we have, without forcing people through what we went through to gain it. Abstraction and formalization are irremediably hard to learn. Everything else can be made easier.</p>
<hr>
<blockquote>
<p>No-code or low-code still means you're creating software, even if you're using a drag-and-drop UI to do so. And if you're building software, you're going to want things like version control, environments, code review, (test code) etc. Unfortunately, most of these tools have zero ability to do these things, or have really half-baked imitations of them, and as a result the apps you've built in no-code/low-code are unable to scale as your company grows.</p>
</blockquote>
<blockquote>
<p>For no code to work one needs to be sure the framework can handle the requirements well, so customizations and workarounds wont be needed. To know the requirements sufficiently well one usually needs something in production, and years of experience with it. Why bother with no/low code then? If a more modern reimplementation is needed, it can be elegantly implemented in one of the bazzilion software stacks out there.<br>
Another big disadvantage is lack of developers that like those kind of things and know them well. Those who do know those frameworks usually cost a lot more. Lots of those relatively niche things, such as mulesoft, are really just means to strengten the vendor lock in, and are sold to management, not engineering leads, on the premise of lessening the reliance on actual engineering. Which of course is a lie.</p>
</blockquote>
<blockquote>
<p>I've worked a lot with no/low code solutions. There actually ended up being a lot of code! Surprise. Code is an interface between human desires and customising computers. There are infinite human desires, thus there will be a need for an interface that is 'code', even if it isn't a big file with scary ASCII characters.</p>
<blockquote>
<p>My last project with a no-code solution was a visual designer where you flow-chart all the logic for workflows. At a very small scale, it might make sense but even for our meager need it was blown out so big that no one could really understand or modify it. And, worst of all, we were locked into this proprietary solution.<br>
In the end, I re-wrote the entire project in regular code and the end result works better and is easier to modify. We don't need to pay expensive consultants anymore. No extra licensing fee. No special software/server/hosting requirements. And any programmer can work on it -- I can even put new hires on it.</p>
<blockquote>
<p>Rewrite in code is way easier than developing in code from scratch. I think your scenario reflects the main benefit of no-code, to let business users fix their own requirements.</p>
<blockquote>
<p>In this case, this is absolutely true. All the requirements were well established and converting it was very quick because of it. But ultimately that doesn't matter because the reason the re-write was done was because the no-code solution failed in it's goal.
The process of developing this solution was funny. We had an absolutely fantastic team doing the requirements and the process was all agile except when it came to the tool itself. At that point, it turned into a waterfall project where everything had to be nailed down before the work was done.<br>
I can mock up a application form very fast so there's really no need for a tool to do that every so slightly faster but in a proprietary and limited way.</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<p>I think “code” is already at the right layer of abstraction. “Code” already solves this problem and has the curve the author’s looking for. “No-code” is a simple case of the wrong abstraction.</p>
<blockquote>
<p>It's all abstractions. Python code is no-C-code. C code is no-assembly-code. And so on...</p>
</blockquote>
</blockquote></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-complexityeffort-curve" title="The Complexity/Effort Curve">The Complexity/Effort Curve</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#so-what-do-we-do" title="So What Do We Do?">So What Do We Do?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#how-do-you-do-it" title="How do you do it?">How do you do it?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-point" title="The Point">The Point</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"ja7ebcppxm73uxmqol3tkug","title":"Code Vs No-code","desc":"","updated":1655971556995,"created":1655970734509,"custom":{},"fname":"dev.tools.code-vs-no_code","type":"note","vault":{"fsPath":"vault"},"contentHash":"5afc702c8f46a54c0450891560baf462","links":[],"anchors":{"the-complexityeffort-curve":{"type":"header","text":"The Complexity/Effort Curve","value":"the-complexityeffort-curve","line":19,"column":0,"depth":3},"so-what-do-we-do":{"type":"header","text":"So What Do We Do?","value":"so-what-do-we-do","line":59,"column":0,"depth":2},"how-do-you-do-it":{"type":"header","text":"How do you do it?","value":"how-do-you-do-it","line":71,"column":0,"depth":2},"the-point":{"type":"header","text":"The Point","value":"the-point","line":95,"column":0,"depth":3}},"children":[],"parent":"5iokala6y4rafqa368l1a4h","data":{}},"body":"\u003ch1 id=\"code-vs-no-code\"\u003eCode Vs No-code\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#code-vs-no-code\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://jasonmorrissc.github.io/post/2022-02-24_no-code/\"\u003ehttps://jasonmorrissc.github.io/post/2022-02-24_no-code/\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://news.ycombinator.com/item?id=31843378\"\u003ehttps://news.ycombinator.com/item?id=31843378\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThere was a conversation on Twitter this week that helped to clarify my thinking about something, and I wanted to share.\u003c/p\u003e\n\u003cp\u003eThere is a sort of tension between “code” and “no-code” (sometimes “low-code”) solutions.\u003c/p\u003e\n\u003cp\u003ePeople who consider themselves software developers see people trying to use no-code solutions to do things that the no-code solutions are not good at, and they get frustrated that the capabilities of those tools has been overestimated.\u003c/p\u003e\n\u003cp\u003eThey are taking something that is really happening, and they are interpreting it really wrong. It’s useful and important to understand how, and why.\u003c/p\u003e\n\u003ch3 id=\"the-complexityeffort-curve\"\u003eThe Complexity/Effort Curve\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-complexityeffort-curve\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLet’s simplify the world, and pretend that effort is a single dimension, where things are always “harder” or “easier” along a single spectrum. Let’s also simplify the world and pretend that the complexity of the software project is also on a single dimension that goes from “simple” to “complex.” Neither of these things is true, but it helps to pretend.\u003c/p\u003e\n\u003cp\u003eIf those things are true, then each software tool, whether a programming language, an app, or a no-code solution that sits somewhere in the middle between the two, has an effort/complexity curve. This line maps how difficult it is to use this tool for a task of the given complexity.\u003c/p\u003e\n\u003cp\u003eAll tools are going to have a line with a positive correlation, but the shape of the line will differ. If a tool is very hard to learn, but very powerful, it will start high, and flatten out faster. Like, say, a programming language.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://jasonmorrissc.github.io/code_graph.png\"\u003e\u003c/p\u003e\n\u003cp\u003eIf a tool is easy to learn, and useful for simple things, but the simplifications become obstacles when you get into higher complexity, then the line will start low, and accellerate upward. Like, say, a no-code solution.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://jasonmorrissc.github.io/no_code_graph.png\"\u003e\u003c/p\u003e\n\u003cp\u003eNow, if you are a person who knows both programming languages and no code tools, this seems like a simple problem. The combination of the two lines looks like this, and you can see the level of complexity at which they cross.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://jasonmorrissc.github.io/both_graph.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThis is why programmers who are familiar with no-code tools say things like “people overestimate what these tools can do.” Because they see people on the right side of the dotted line, using no-code solutions, and they assume that the person must misunderstand where the orange line actually lies.\u003c/p\u003e\n\u003cp\u003eThat’s not what’s happening. In the mind of the person who uses no-code tools and is not a programmer, this is what’s happening.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://jasonmorrissc.github.io/what_they_know.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThey don’t know the shape of the curve for programming, because \u003cem\u003ethat\u003c/em\u003e is the thing they \u003cem\u003ehaven’t\u003c/em\u003e used. They may not understand the curve for no-code tools perfectly, but they definitely understand it better.\u003c/p\u003e\n\u003cp\u003eGiven that information, what decision would you make?\u003c/p\u003e\n\u003cp\u003eYou would obviously use the tool you have.\u003c/p\u003e\n\u003cp\u003eBut even if we could educate people on the positions of the relative curves, the vertical dotted line represents best alternative in the abstract. It does not reflect the thing that the person actually cares about. If they are looking at doing something that is slightly beyond the point where using the no code tool is the best option, they are worried about new effort, not existing effort. They know how hard it is to do the things they have done before, and they are willing for future things to be at least that hard.\u003c/p\u003e\n\u003cp\u003eThere is an increased amount of effort that they are willing to go through to get to this new level of complexity, and for each tool, they have a comfort level.\u003c/p\u003e\n\u003cp\u003eSo if you imagine a person who has used the no-code tool for something before, but has never used code before, how do they do the math?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://jasonmorrissc.github.io/new_effort.png\"\u003e\u003c/p\u003e\n\u003cp\u003eIf you are trying to minimize the discomfort of not knowing what you are doing, you will continue to use the tools you know long after they are no longer the best tools for the job. And the each time you do it, you reduce the apparent cost of using the same tool again.\u003c/p\u003e\n\u003ch2 id=\"so-what-do-we-do\"\u003eSo What Do We Do?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#so-what-do-we-do\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWe need to tell people where the blue line is, right? We need to educate people better about what tools are good for what.\u003c/p\u003e\n\u003cp\u003eSorry, no. Educate all you want, it doesn’t change the fact that in the beginning, the harder tools are harder. No one starts on the black diamond slope. Everyone starts on the bunny slope. People with high tolerance for the difficulty of learning programming are already well served by what we have, and people with a low tolerance for it will not be convinced if we merely insist.\u003c/p\u003e\n\u003cp\u003eYou can \u003cem\u003ehelp\u003c/em\u003e solve this problem by making the curve more visible from the beginning. If you can show people the range of uses of the tool, from simple to complex, and that demonstration is meaningful, then great. But even then, you are going to need to overcome the fact that people do not generally want to start with the harder thing.\u003c/p\u003e\n\u003cp\u003eSo in an ideal world, what we need is tools that have a effort/complexity curve that is both visible, and looks like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://jasonmorrissc.github.io/ideal.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"how-do-you-do-it\"\u003eHow do you do it?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#how-do-you-do-it\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThere are a lot of people a lot smarter than me working on that problem. If you’re interested, the \u003ca href=\"https://futureofcoding.org/\"\u003eFuture of Coding\u003c/a\u003e community is one that has a lot to say on the topic.\u003c/p\u003e\n\u003cp\u003eThere are two main problems. The first is how to get the beginning of the curve lower. That’s the problem that the people selling no-code solutions are tackling, and with real success. They are empowering people, and that is a thing people will pay for.\u003c/p\u003e\n\u003cp\u003eFor that problem, some of the answers seem to be to specialize the tools to small problem domains, eliminate text as the primary user interface, and replace it with something that fits the domain of the problem. It is a design problem, and one that people have made a lot of progress on.\u003c/p\u003e\n\u003cp\u003eThe other main problem is how do you avoid the making complexity more expensive?\u003c/p\u003e\n\u003cp\u003eThis is less obvious. Domain specificity can help, because you can say “if you want more, go elsewhere”, and then combine tools that each do a small thing well. Tying no-code tools together, in a no-code way, is the basic idea behind tools like Zapier, which have been wildly successful. But people inevitably want to do more, and it becomes harder to support in the simplified interface.\u003c/p\u003e\n\u003cp\u003eAnother possibility that I’m pursuing with Blawx is the idea that it doesn’t need to be just one tool. You can have the beginner’s no-code tool that teaches the person to use the advanced code tool. Blawx lets the user see what s(CASP) code is being written for them. In that way, using Blawx can teaches you s(CASP), and you are less trapped inside the tool you already know when you reach its limits. But commercial no-code solutions often do not want their customers to escape in this way, so it may not be realistic to expect from commercial no-code solutions.\u003c/p\u003e\n\u003cp\u003eAnother possibility is a tool that modifies itself in sophistication along with the user. We could have “beginner mode” and “advanced mode”, and try to detect when the features of the advanced mode would help what the user is currently doing. Imagine a programming language that doesn’t introduce the concept of a function until after you type almost the same code twice.\u003c/p\u003e\n\u003cp\u003eI have seen nothing of the sort, it’s just an idea.\u003c/p\u003e\n\u003cp\u003eAnother possibility is that programming languages already have a sort of optimal effort/complexity curve at the high complexity end, so if we can just lower the start of the curve for an actual programming language, that solves the problem.\u003c/p\u003e\n\u003cp\u003eYou can paint efforts to teach programming to children into this box, to some degree. Or, efforts to teach programming at all. But even in the world of Scratch and Blockly, the people involved insist they are not trying to replace programming languages, they are trying to promote the learning of them. Ultimately, they expect people to type code into a development environment. That has always seemed like a lack of vision, to me.\u003c/p\u003e\n\u003cp\u003eNo one, that I am aware of, is trying to build a programming language that scales in complexity all the way from good-for-kids to general-purpose programming language.\u003c/p\u003e\n\u003ch3 id=\"the-point\"\u003eThe Point\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-point\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThe point is, if people are choosing to do something one way, and not the “better” way, the problem is never with the people, the problem is with the “better” way. People will do what costs the least, but the costs are measured in stress, ambiguity, effort, and human experience.\u003c/p\u003e\n\u003cp\u003eConsider a hammer. A hammer is designed to do a specific thing. In the context of that thing, how to use it is obvious. But more than that, when you pick it up, you can feel intuitively what you are capable of now that you weren’t without it. You can imagine using it to do simple things, and complicated things. And you can imagine, and maybe even aspire to, getting better at using it.\u003c/p\u003e\n\u003cp\u003eThat is the experience that any software tool should aspire to. Obviously valuable, obviously scalable, intuitive. Learning it should feel like play.\u003c/p\u003e\n\u003cp\u003eThe fact that we programmers, who lived in the sliver of time shortly after the invention of programming, managed to acquire the skills to deploy it, doesn’t mean it has reached its evolutionary apex. Programming can be much, much better than it is. But only if the people who already understand it can genuinely focus on the interests of the people who don’t, without the hubris of assuming that their aspiration should be to become like us.\u003c/p\u003e\n\u003cp\u003eIt is undoubtedly possible to share the power we have, without forcing people through what we went through to gain it. Abstraction and formalization are irremediably hard to learn. Everything else can be made easier.\u003c/p\u003e\n\u003chr\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNo-code or low-code still means you're creating software, even if you're using a drag-and-drop UI to do so. And if you're building software, you're going to want things like version control, environments, code review, (test code) etc. Unfortunately, most of these tools have zero ability to do these things, or have really half-baked imitations of them, and as a result the apps you've built in no-code/low-code are unable to scale as your company grows.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFor no code to work one needs to be sure the framework can handle the requirements well, so customizations and workarounds wont be needed. To know the requirements sufficiently well one usually needs something in production, and years of experience with it. Why bother with no/low code then? If a more modern reimplementation is needed, it can be elegantly implemented in one of the bazzilion software stacks out there.\u003cbr\u003e\nAnother big disadvantage is lack of developers that like those kind of things and know them well. Those who do know those frameworks usually cost a lot more. Lots of those relatively niche things, such as mulesoft, are really just means to strengten the vendor lock in, and are sold to management, not engineering leads, on the premise of lessening the reliance on actual engineering. Which of course is a lie.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI've worked a lot with no/low code solutions. There actually ended up being a lot of code! Surprise. Code is an interface between human desires and customising computers. There are infinite human desires, thus there will be a need for an interface that is 'code', even if it isn't a big file with scary ASCII characters.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMy last project with a no-code solution was a visual designer where you flow-chart all the logic for workflows. At a very small scale, it might make sense but even for our meager need it was blown out so big that no one could really understand or modify it. And, worst of all, we were locked into this proprietary solution.\u003cbr\u003e\nIn the end, I re-wrote the entire project in regular code and the end result works better and is easier to modify. We don't need to pay expensive consultants anymore. No extra licensing fee. No special software/server/hosting requirements. And any programmer can work on it -- I can even put new hires on it.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRewrite in code is way easier than developing in code from scratch. I think your scenario reflects the main benefit of no-code, to let business users fix their own requirements.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIn this case, this is absolutely true. All the requirements were well established and converting it was very quick because of it. But ultimately that doesn't matter because the reason the re-write was done was because the no-code solution failed in it's goal.\nThe process of developing this solution was funny. We had an absolutely fantastic team doing the requirements and the process was all agile except when it came to the tool itself. At that point, it turned into a waterfall project where everything had to be nailed down before the work was done.\u003cbr\u003e\nI can mock up a application form very fast so there's really no need for a tool to do that every so slightly faster but in a proprietary and limited way.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI think “code” is already at the right layer of abstraction. “Code” already solves this problem and has the curve the author’s looking for. “No-code” is a simple case of the wrong abstraction.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIt's all abstractions. Python code is no-C-code. C code is no-assembly-code. And so on...\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"ja7ebcppxm73uxmqol3tkug"},"buildId":"vOE8u-mg___OsOsz4tjEg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>