<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Understanding Authentication In Websites: A Banking Analogy</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Understanding Authentication In Websites: A Banking Analogy"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/515c59eesgg7k7pwwfiu2tx/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="2/1/2023"/><meta property="article:modified_time" content="2/1/2023"/><link rel="canonical" href="https://luke-snaw.github.io//notes/515c59eesgg7k7pwwfiu2tx/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/wirstT2ztC8OQsbzKjhvw/_buildManifest.js" defer=""></script><script src="/_next/static/wirstT2ztC8OQsbzKjhvw/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="understanding-authentication-in-websites-a-banking-analogy">Understanding Authentication In Websites: A Banking Analogy<a aria-hidden="true" class="anchor-heading icon-link" href="#understanding-authentication-in-websites-a-banking-analogy"></a></h1>
<blockquote>
<p>You’ll learn about tokens, authorization, CORS, credentials, HTTP headers, and such. It shouldn’t have to take a wizard to implement a good authentication system. Just a good banker!<br>
<a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/">https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/</a></p>
</blockquote>
<h2 id="your-password-matched-now-what">Your Password Matched. Now What? <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#your-password-matched-now-what">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#your-password-matched-now-what"></a></h2>
<p><strong>Authentication is the process of attributing a given request to a unique entity</strong>, usually a person. It then enables authorization, the process of allowing (or not) said person to access a resource, be it a web page or an API endpoint.</p>
<p>I will focus on the part I’ve always found the most difficult to understand: what happens after the user just submitted the login form and their credentials were confirmed as valid by the backend.</p>
<p>We are going to talk about tokens, CORS, cookies, and headers. Those concepts are sometimes quite abstract. To make them more real, I’ll take a shot at a banking analogy.</p>
<h2 id="authentication-relies-on-tokens-like-banks-rely-on-money">Authentication Relies On Tokens Like Banks Rely On Money <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#authentication-relies-on-tokens-like-banks-rely-on-money">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#authentication-relies-on-tokens-like-banks-rely-on-money"></a></h2>
<p>Let’s consider two common patterns:</p>
<ul>
<li><strong>JSON Web Tokens aka JWT.</strong><br>
It’s an open standard. You’ll find useful resources at the bottom of this article if you want to go further.</li>
<li><strong>Session-based authentication.</strong><br>
It’s a pattern more than a standard. So the implementation may vary, but I’ll try to give an overview of how it works.</li>
</ul>
<p>As a front-end developer, you may have no control over this design decision, so it’s important that you understand how both work.</p>
<p>As a full-stack or backend developer, you have control over this choice, so it’s even more important that you understand what you are doing. I mean, it’s kinda your job :)</p>
<h3 id="a-jwt-is-like-a-banknote">A JWT Is Like A Banknote <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#a-jwt-is-like-a-banknote">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#a-jwt-is-like-a-banknote"></a></h3>
<p>...</p>
<p>If you want to use your money, either at the bank to credit your account or in a store, people will double-check that your banknotes are real. A real banknote is one that has been created by the bank itself. When the banknote is confirmed to be legit, they can read the value on it to tell how many things you can buy.</p>
<p>JWTs work the same, the server can verify that they indeed created this token earlier, so it’s a real one, and then they can read the payload it contains to confirm who you are and what your permissions are.</p>
<p>Revoking a token can be hard. The server has to maintain a list of blacklisted tokens that are no longer valid, like the bank would need to list robbed banknotes’ unique numbers.</p>
<h3 id="session-based-authentication-is-like-a-credit-card">Session-Based Authentication Is Like A Credit Card <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#session-based-authentication-is-like-a-credit-card">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#session-based-authentication-is-like-a-credit-card"></a></h3>
<p>From the front-end developer standpoint, the main difference between JWT and session-based authentication lies in what the server will return in case of a successful login.</p>
<p>In session-based authentication, instead of having a claim full of user information, you just get a “session id.”</p>
<p>From the backend developer’s standpoint, session-based authentication involves an additional database collection or table to store the sessions. A session is just an object very similar to the JWT, which can contain, for instance, a user id and an expiration date.</p>
<p>This means that the server keeps a lot of control over the authentication. It can log a user out by removing the session from the database, whereas it cannot destroy JWTs, since it doesn’t store them.</p>
<p>Session-based authentication is comparable to credit cards. You go to the bank to open your account. The banker will check your id and issue a credit card with an expiration date. This is the authentication process.</p>
<p>The credit card itself has barely any value: it’s just plastic and a microchip whose purpose is to uniquely identify your account. It can easily be revoked by the bank, usually after a certain period of time, but also when you declare your card stolen.</p>
<p>When you want to pay for something, the store will communicate with your bank to check that your credit card is valid and has a positive balance.</p>
<p>When you access an authenticated resource, the server will check if the session id matches an open session and then if this session matches a user that is authorized to access this resource.</p>
<h2 id="tokens-are-as-precious-as-banknotes-and-credit-cards-dont-get-them-stolen">Tokens Are As Precious As Banknotes And Credit Cards. Don’t Get Them Stolen! <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#tokens-are-as-precious-as-banknotes-and-credit-cards-don-t-get-them-stolen">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#tokens-are-as-precious-as-banknotes-and-credit-cards-dont-get-them-stolen"></a></h2>
<p>It’s easy for companies and banks to store money. They have those big reinforced-steel safes with alarms and sometimes even dragons. Likewise, it’s easy for servers to talk securely to one another.</p>
<p>But websites are like private persons. They can’t have dragons, so they have to imagine specific approaches to store their precious tokens.</p>
<h3 id="where-do-you-store-your-money">Where Do You Store Your Money? <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#where-do-you-store-your-money">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#where-do-you-store-your-money"></a></h3>
<p>...</p>
<h3 id="not-all-requests-are-born-equal-loading-a-web-page-vs-calling-an-api">Not All Requests Are Born Equal: Loading A Web Page vs. Calling An API <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#not-all-requests-are-born-equal-loading-a-web-page-vs-calling-an-api">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#not-all-requests-are-born-equal-loading-a-web-page-vs-calling-an-api"></a></h3>
<p>We can divide authenticated content into two categories: web pages and API endpoints. From a technical standpoint, both are server endpoints. The former returns HTML content or files, the latter — any kind of content, often JSON data. They differ in the way they are consumed.</p>
<p>Web pages are accessed via a web browser that triggers GET requests automatically, depending on the current URL.</p>
<p>APIs are called using JavaScript code. This reliance on APIs and JavaScript is at the core of the Jamstack, REST, and Single-Page-Application philosophies.</p>
<p>Thus, let’s differentiate two use cases:</p>
<ol>
<li>You want to <strong>secure access to the web page</strong> itself. Meaning the user can’t even see the structure of your page or any HTML.</li>
<li>You want to <strong>secure calls from your web page to your API</strong>. Anyone can see your web page structure, but they can’t get any data.</li>
</ol>
<p>If you combine both, unauthenticated users can’t see the page structure and can’t get any data from your API.</p>
<h3 id="use-case-1-securing-a-web-page-access-with-cookies">Use Case 1: Securing A Web Page Access With Cookies <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#use-case-1-securing-a-web-page-access-with-cookies">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#use-case-1-securing-a-web-page-access-with-cookies"></a></h3>
<p>I’ll cut it short, to secure web page access, you have no other choice but to use cookies, ideally HTTP-Only, secure cookies.</p>
<p>From a technical standpoint, a cookie is a piece of data that should be sent alongside every request to a specific domain. They are part of the HTTP protocol.</p>
<p>That’s a pretty broad scope. When a website cookie popup differentiates “essential cookies” from other cookies, those essential cookies are often dedicated to authentication. The others are just a way to keep track of the product pages you’ve visited to later shove them in your face to the point of literally optimizing the billboard displays in your neighborhood as if you really, really wanted to buy two freezers within the same month.</p>
<p>Setting a cookie is possible in both directions. Client-side JavaScript can set cookies to be sent to the server. That’s how advertisement tracking works (though GDPR is forcing advertisers to use server-side logic more and more these days).</p>
<p>But the server can also tell the browser to store a cookie using the <code>Set-Cookie</code> header in the response.</p>
<p>This convenient feature lets the backend set what we call “HTTP-only” cookies: cookies that cannot be read by JavaScript. And “secure” cookies are only set through HTTPS for better security.</p>
<p><strong>Important note</strong>: <em>Using HTTP-only cookies prevents XSS attacks (script injection to steal the token) but not CSRF attacks (forging requests on behalf of your authenticated users, basically impersonating them). You need to combine multiple strategies to parry all possible attacks. I invite you to read more on these topics if you manage a non-trivial website.</em></p>
<p>During the authentication process, the <code>Set-Cookie</code> header should be used in response to the “login” request so the client becomes authenticated via a token.</p>
<blockquote>
<p>A <code>Set-Cookie</code> header in the response of the login request, as seen in browser development tools. The browser will automatically store this cookie. Since it’s HTTP-only, JavaScript can’t read it; it’s only handled by the browser directly. (<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/588a49e9-4e23-4962-926f-f0a5325195f3/5-authentication-websites-banking-analogy.png">Large preview</a>)</p>
</blockquote>
<p>Cookies are like a wallet. You can store fidelity cards in it and a picture of your cat, but also duller things, like your money. It’s in your pocket or your handbag, so it’s hard to access for other people (HTTP-only, no JavaScript access) if you don’t take it out in unsafe places (secure). Yet, you always have your token with you if needed.</p>
<blockquote>
<p>The cookie displayed in your browser development tools, after being set. It is NOT available to JavaScript code! A successful script injection cannot steal your users’ tokens, but be careful about other types of attacks like CSRF. Here the cookie is not ‘secure’ because I am in <code>localhost</code> mode. (<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e19a0377-4a0b-420f-a9a2-357fbdf0c170/9-authentication-websites-banking-analogy.png">Large preview</a>)</p>
</blockquote>
<p>Browsers rely a lot on cookies, and they send them automatically alongside every request they trigger as long as the domain and path match, so you don’t have to worry about them. If you carry your wallet with you anytime you go out, you’re always ready to pay.</p>
<blockquote>
<p>The <code>Cookie</code> header is added automatically to the request emitted by the browser during navigation, as long as the domain and path are matching. (<a href="https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8bdba247-4fa0-4ba7-9a10-9fb89b2e5146/8-authentication-websites-banking-analogy.png">Large preview</a>)</p>
</blockquote>
<h3 id="use-case-2-securing-api-calls-the-cookie-scenario">Use Case 2: Securing API Calls. The Cookie Scenario <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#use-case-2-securing-api-calls-the-cookie-scenario">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#use-case-2-securing-api-calls-the-cookie-scenario"></a></h3>
<p>Now, let’s authenticate calls to our API, which feeds the website with data. The easiest option would be to use a cookie, as we did in the previous section, to secure web pages. But contrary to the web page, there is also another option — using web storage. Which one is the most suited is debatable. Let me start with cookies.</p>
<p>The cookie that contains the auth token is sent automatically alongside requests triggered by the browser when you navigate a website or when you submit a form.</p>
<p>But requests triggered by JavaScript code do not fall into this category. When you trigger a request programmatically, you need a bit more configuration to send cookies.</p>
<p>Remember that the cookie should be HTTP-only, so you can’t read the cookie content with JavaScript nor inject your token in the <code>Authorization</code> header. You could do that with a cookie that is not HTTP-only, but then using a cookie doesn’t make sense in the first place.</p>
<p>All existing libraries capable of sending requests have to be based on the browser JavaScript API aka the “Browser Object Model,” which means either <code>XMLHttpRequest</code> or <code>fetch</code>. You have to rely on their configuration to enable sending HTTP-only cookies alongside the request.</p>
<p>In the case of <code>fetch</code>, this option is named <code>credentials</code>. Hopefully, for you, fellow front-end developers, it’s very easy to use.</p>
<pre class="language-js"><code class="language-js"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8000/account/signup"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  method<span class="token operator">:</span> <span class="token string">"POST"</span><span class="token punctuation">,</span>
  body<span class="token operator">:</span> <span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span> username<span class="token operator">:</span> <span class="token string">"foo"</span><span class="token punctuation">,</span> password<span class="token operator">:</span> <span class="token string">"barbar"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token comment">// This will include credentials (here, cookies) in the request</span>
  credentials<span class="token operator">:</span> <span class="token string">"include"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>With XHR, the option is named <code>withCredentials</code> and behaves similarly.</p>
<p><strong>Note</strong>: <em>Your server must also confirm that it indeed accepts credentials by setting the <code>Access-Control-Allow-Credentials</code> header to true in the responses. This option is symmetrical. It controls both sending cookies to the server, but also accepting the <code>Set-Cookie</code> header from it. So don’t forget to set it to true for the call to the login endpoint.</em></p>
<p>If the <code>credentials</code> option is not set and the server answers with a <code>Set-Cookie</code> header… the browser will silently ignore this attempt to set the cookie without even a warning. When this happens, start by double-checking your <code>credentials</code> option and then CORS if applicable (see next section).</p>
<p>Oops, I’ve almost forgotten your banking analogy! It’s a tough one but let’s say that you probably have your credit card or a few banknotes always there in your wallet. But some services expect a prepaid card, and you may need to explicitly remember to take them with you. <em>That’s the best analogy I could achieve. Comment if you can do better!</em></p>
<h3 id="return-of-use-case-2-securing-api-calls-the-web-storage-scenario">Return Of Use Case 2: Securing API Calls. The Web Storage Scenario <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#return-of-use-case-2-securing-api-calls-the-web-storage-scenario">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#return-of-use-case-2-securing-api-calls-the-web-storage-scenario"></a></h3>
<p>Remember, I said earlier that for API calls, you have the choice to either store the token in an HTTP-only cookie, like you would do to secure a web page, or to store the token in the web storage. By web storage, we mean either <code>sessionStorage</code> or <code>localStorage</code>.</p>
<p>I’ve seen and used both approaches, cookies and web storage, but I sincerely don’t have the expertise to assert that one is better than the other. I’ll stick to describing how it works so you can make an enlightened decision.</p>
<p>Codewise, they are much easier to use than HTTP-only cookies because web storage is available to JavaScript code. You can get the token from the login response payload, store it in <code>localStorage</code>, and insert it into the <code>Authorization</code> header in later requests. You have full control of the process without relying on some implicit browser behavior.</p>
<pre class="language-js"><code class="language-js">headers<span class="token operator">:</span> <span class="token punctuation">{</span>
    “Authorization”<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Bearer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token property-access">localStorage</span><span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span>“auth_token”<span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span>
</code></pre>
<p>Web storage is immune to certain attacks, namely Cross-Site Request Forgery. That’s because, contrary to cookies, they are not automatically tied to requests, so an attacker will have trouble forcing you to give your token. Think of a piggy bank. You can’t just get money out of it. It’s, however, very sensitive to script injection, where an attacker manages to run JavaScript and reads the token.</p>
<p>Therefore, if you go the web storage way, you’ll want to explore strategies that prevent XSS attacks from happening in the first place.</p>
<h3 id="jwt-specifics-what-information-they-should-contain-and-how-to-handle-the-refresh-token">JWT Specifics: What Information They Should Contain And How To Handle The Refresh Token <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#jwt-specifics-what-information-they-should-contain-and-how-to-handle-the-refresh-token">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#jwt-specifics-what-information-they-should-contain-and-how-to-handle-the-refresh-token"></a></h3>
<p>You should avoid storing critical information in a JSON web token, even when using HTTP-only cookies. If someone still manages to steal and decrypt the token, they will be able to impersonate the user, but at least they won’t be able to get much information from the token itself.</p>
<p>You can afford to lose a five-dollar banknote; it’s more problematic to lose a $5,000 banknote. By the way, if such a thing as a $5,000 banknote exists, please send me a specimen to prove it. Thank you.</p>
<p>JWTs are meant to be short-lived, like banknotes, which would wear quickly when used a lot. Since they are hard to revoke, giving them 5-minute lifetime guarantees that even a stolen JWT token cannot be a big problem.</p>
<p>Since you don’t want the user to log in again every 5 minutes, the token can be combined with a longer-lived refresh token. This second token can be used to get a new JWT.</p>
<p>A best practice is to store the refresh token in a cookie on a very specific path like <code>/refresh</code> (so it’s not sent with all requests, contrary to the JWT) and to make it a one-time-only token.</p>
<p>A refresh token is like bringing your ID card to get more money from your bank account. You don’t do that often, and you probably want to store your ID even more safely than your banknotes.</p>
<h2 id="cors-is-how-shops-communicate-with-their-bank">CORS Is How Shops Communicate With Their Bank <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#cors-is-how-shops-communicate-with-their-bank">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#cors-is-how-shops-communicate-with-their-bank"></a></h2>
<p>Formally, CORS (Cross-Origin Resource Sharing) is a protocol used by servers in order to instruct browsers to selectively relax some of the Same-Origin Policy (SOP) restrictions on network access for some trusted clients.</p>
<p>Less formally, the server can tell your browser that the request you send is legit based on the request’s origin. If the server says it’s not legit, the browser won’t send the request.</p>
<p>For instance, <code>https://www.foobar.com</code>, <code>https://qarzed.fake</code>, and <code>http://localhost:8080</code> are possible origins. The port and protocol matter.</p>
<p>An API hosted on <code>https://api.foobar.com</code> will most often allow requests only from <code>https://www.foobar.com</code> and <code>https://mobile.foobar.com</code>.</p>
<p>I will focus here on API calls triggered with <code>fetch</code> in JavaScript, and only if the API lives in another Web origin. CORS also affects more advanced use cases like embedding images from another website in your own website, iframe, navigating from one site to another, and so on, but that’s beyond the scope of authentication per se.</p>
<p>Websites are like stores. People can enter them and try to buy things. But the store also has its own complicated internal back office logic. Namely, it relies on a bank to process payments.</p>
<p>Any shop owner can try to connect to any bank. Any website can try to connect to any API. But the payment won’t be processed by the bank if they don’t have a company account there.</p>
<blockquote>
<p>A store (a website) should only communicate with banks (APIs) they work with. Other banks will politely reject their requests. Note: this strategy is not enough to secure a server; CORS can be bypassed by attackers.</p>
</blockquote>
<p>Likewise, if you host the website on <code>www.foobar.com</code> and the API on <code>www.foobar.com/api</code>, there is one origin only <code>www.foobar.com</code>. No need for CORS because there is no “cross-origin” call involved. You’ll need to bother about CORS if, instead, you host the API on <code>api.foobar.com</code>. We have two distinct origins, <code>api.foobar.com</code> and <code>www.foobar.com</code>.</p>
<p>This also applies to using different ports on <code>localhost</code> during development. The IP <code>127.0.0.1</code> is even different from <code>localhost</code>, as origins are compared directly as strings and not based on their actual IP address.</p>
<p>Some big companies, like car sellers, have their own internal bank. It’s easier for them to communicate with this bank if it’s literally located in the same office. They are like full-stack monolithic applications.</p>
<p>But if this internal bank is located in a different country (API separate from the website), this doesn’t work anymore. It could as well be a traditional bank with multiple clients (a third-party API). CORS is needed either way.</p>
<p>CORS is a concept specific to browser-server communication. When a server talks to another server, the Same-Origin Policy doesn’t apply. The API may either block those requests with no origin completely or, on the contrary, accept them, or filter them based on IP and so on.</p>
<p>Banks have specific patterns of communicating with each other that are different from how they communicate with their client companies.</p>
<h3 id="a-polite-cross-origin-discussion-between-a-server-and-a-client-using-preflight-requests">A Polite Cross-origin Discussion Between A Server And A Client, Using Preflight Requests <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#a-polite-cross-origin-discussion-between-a-server-and-a-client-using-preflight-requests">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#a-polite-cross-origin-discussion-between-a-server-and-a-client-using-preflight-requests"></a></h3>
<p>Here’s a more concrete vision of what happens during a cross-origin request and how the server response headers should be set.</p>
<p>From the browser standpoint, whenever a website sends a “non-simple” request to an API, the browser will first send a preflight request. It’s a request to the same URL but using the OPTIONS method, which is dedicated to checking whether you can actually consume this API endpoint.</p>
<p>Fetching JSON data falls into this “non-simple” category in standard browsers, as well as calling your login endpoint if the auth API doesn’t live on the same domain as your website, so this step is extremely important.</p>
<p>The server receives this request, which includes an Origin header. It checks its own list of accepted origins. If the origin is allowed, it will respond with the right <code>Access-Control-Allow-Origin</code> header.</p>
<p>This server header should match the website’s origin. It can also be a wildcard <code>*</code> if the API is totally open, but that works only for requests without credentials, so forget about this if your API requires authentication.</p>
<p>If the response header doesn’t match, the browser will trigger an error at this point because they already know that they can’t call this API. Otherwise, they will keep going and send the actual request.</p>
<p>A store (the API) can decide to accept only certain types of credit cards. Some stores accept only their own card, and they don’t even use CORS (same-origin scenario). Some stores accept only Visa or Mastercards (cross-origin scenario). The cashier (the browser) won’t let you pay if they are told your card is not accepted by the store.</p>
<p>There are a few other <code>Access-Control</code> headers that provide more information, like accepted methods or headers. <code>Allow-Origin</code> is the most basic one, as well as <code>Allow-Credentials</code>, so cookies and <code>Set-Cookie</code> headers are properly enabled when using <code>fetch</code>.</p>
<pre><code>Access-control-allow-origin: https://www.foobar.com
Access-control-allow-credentials: true
</code></pre>
<p><em>Expected response headers for an authenticated call (or the “login” form submission) if the website lives on <code>https://www.foobar.com</code> and the API is on another domain or port.</em></p>
<p><strong>Note</strong>: <em>The server specifies the CORS policy, and the browser enforces it. If suddenly everyone used an unsafe browser run by pirates, they could swarm your server with forged requests. Hopefully, people usually don’t use a shady browser they found in a USB key itself found lying on the ground of a dark alley at 3 am.</em></p>
<p>The header things and the browser behavior are just politeness. The browser is an excessively polite software. It will never spam the server with requests that will be rejected anyway. And it won’t talk to rude servers that don’t set the proper headers. That’s why the <code>Accept-Control-Allow-Origin</code> response header must be correctly set for cross-origin requests to work.</p>
<p>Before going as far as aiming a customer with a shotgun, the banker will probably tell you, “sir, you entered the wrong bank office,” and the customer will probably answer, “oh, sorry, my mistake. I will leave immediately!”.</p>
<h3 id="cookies-or-not-cookies-the-samesite-option">Cookies Or Not Cookies: The SameSite Option <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#cookies-or-not-cookies-the-samesite-option">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#cookies-or-not-cookies-the-samesite-option"></a></h3>
<p>Setting the <code>credentials</code> attribute in your <code>fetch</code> request is not enough for sending the cookie, plus it doesn’t apply to pages, only to programmatic requests. The <code>SameSite</code> attribute of cookies lets you configure when a cookie should be sent, depending on the current site.</p>
<p>The concept of “Site” is slightly different from the concept of domain:</p>
<ul>
<li><code>https://api.foobar.com</code> and <code>https://www.foobar.com</code> are 2 different domains.</li>
<li>They are, however, the same site. Nowadays, the scheme matters, too (HTTP vs. HTTPS).</li>
<li>There is an exception to this rule, e.g., in multi-tenant architectures: <code>foo.github.io</code> and <code>bar.github.io</code> will be different sites despite having the same domain, and the server owner can configure that to their will.</li>
</ul>
<p>If the <code>Access-control</code> response headers are correctly set, and the preflight request succeeds, the browser will proceed with the actual request.</p>
<p>But if <code>SameSite</code> is not set with the right value in the cookie containing the authentication token, this cookie won’t be sent to the server. When loading a page, you will be considered unauthenticated by the server just because it literally doesn’t have your cookie.</p>
<p>The <code>SameSite</code>: <code>Lax</code> value is usually the most appropriate. It will only send cookies to the same site but also when the user comes from another site and is redirected to your page (only for top-level navigations). This is the current default in most browsers.</p>
<p>With <code>SameSite</code>: <code>Lax</code>, the website <code>www.foobar.com</code> will automatically include the authentication cookie when it sends requests to <code>api.foobar.com</code>, which is part of the same site. Authentication will work as expected.</p>
<h3 id="sec-fetch-helps-detecting-cross-origin-requests-but-are-not-standard-yet">Sec-Fetch Helps Detecting Cross-origin Requests But Are Not Standard Yet <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#sec-fetch-helps-detecting-cross-origin-requests-but-are-not-standard-yet">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#sec-fetch-helps-detecting-cross-origin-requests-but-are-not-standard-yet"></a></h3>
<p>Related to CORS, you may also hear about the <code>Sec-Fetch</code> request headers. They provide information about the request context to the server. For instance, if <code>Sec-Fetch-Site</code> is <code>same-origin</code>, there is no need to check the Origin header. It’s slightly more intuitive than manually checking the request origin against predefined rules. If it’s <code>same-site</code>, you still need to add the required CORS headers in the response because the site and the origin are different concepts.</p>
<p>However, those headers are not sent by all browsers. Namely, Safari doesn’t support them at the time of writing. Therefore, they can only act as a secondary solution to identify a request’s origin.</p>
<p>A bank can identify you via your passport, but not everybody has a passport, so you will always need to resort to a good old ID card. Passports are still a cool way to identify people when available. That’s what the <code>Sec-Fetch</code> headers are.</p>
<p>Keep in mind that attackers may trick users into sending requests they don’t want to, but they still have no control over which browser will send the request. Thus, <code>Sec-Fetch</code> headers are still useful despite being supported only by some browsers. When they are present, they are a reliable piece of information.</p>
<p>More broadly, cross-origin and cross-site security patterns are based on the fact that users are using legitimate browsers that should never try to voluntarily mislead servers about the origin. Beware of more elaborate attacks, such as subdomain takeover, that can still bypass these security measures.</p>
<p>You may think, what about servers, then? Server requests are able to spoof a request origin, effectively bypassing CORS. Well, that’s right: CORS is a browser-server security mechanism; it simply doesn’t apply to server-server calls. Someone can build an API that calls your own API and serve the result to another website. True.</p>
<p>However, the thief will have to host a server, which isn’t free, so they will pay actual money for this API call, and the server IP may be traced back to them. It’s way less attractive than forcing browsers to send the request directly to your API, which would be free and trace back to the first victim, your user, and not to the attacker. Thanks to CORS, this worst-case scenario is not possible.</p>
<h2 id="no-we-dont-take-checks-dont-confuse-a-web-page-access-and-an-api-call">No, We Don’t Take Checks: Don’t Confuse A Web Page Access And An API Call <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#no-we-don-t-take-checks-don-t-confuse-a-web-page-access-and-an-api-call">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#no-we-dont-take-checks-dont-confuse-a-web-page-access-and-an-api-call"></a></h2>
<p>If you’ve stumbled upon this article, you have probably read a lot of documentation before that. You might have encountered various patterns that seem very different from one another and may be very different from what I’ve been describing so far.</p>
<p>I’d like to point out that this article is about authentication for <em>websites</em>. This is, I believe, the root of all confusion. First, the requests are sent by a browser, not by another server. Then, a page of a website can be accessed via the URL bar, and the website can send calls to an API via JavaScript; that’s two very different situations.</p>
<p>We have detailed the technical differences between each scenario earlier in this article. But let’s recap again to better understand the most common sources of confusion.</p>
<h3 id="using-browser-storage-session-local-and-friend-is-like-using-your-mailbox-as-a-piggy-bank">Using Browser Storage (Session, Local, And Friend) Is Like Using Your Mailbox As A Piggy Bank <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#using-browser-storage-session-local-and-friend-is-like-using-your-mailbox-as-a-piggy-bank">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#using-browser-storage-session-local-and-friend-is-like-using-your-mailbox-as-a-piggy-bank"></a></h3>
<p>Setting your token in <code>localStorage</code> is like storing money in your physical mailbox. Well, technically, it’s safe. It’s even used to temporarily store your mail. Session storage is similar; it’s just like getting your mail every day instead of letting it rot for weeks. Be nice to the postman!</p>
<p>But either way, the storage is accessible to JavaScript. It’s not open like your mailbox most probably has a lock. But it’s still lying outside.</p>
<p>Someone who is really mean could craft a key and go as far as discreetly stealing your mail for days. That’s what would happen to your users if someone manages to run a script injection attack in your application. They can craft a JS script that reads the <code>localStorage</code>, and sends them the tokens of any of your users affected by the breach!</p>
<p>There are ways to prevent cross-scripting attacks. It’s not a fatality, and some would argue that it’s still better than using an HTTP-only cookie! But if you go the web storage way, don’t forget to protect your mailbox.</p>
<h3 id="jwts-passed-as-header-its-a-pattern-for-api-calls-only">JWTs Passed As Header: It’s A Pattern For API Calls Only <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#jwts-passed-as-header-it-s-a-pattern-for-api-calls-only">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#jwts-passed-as-header-its-a-pattern-for-api-calls-only"></a></h3>
<p>I’d like to go one step further and understand <em>why</em> so many developers are tempted to use the browser storage without even considering the cookie option.</p>
<p>I think there are two main reasons:</p>
<ol>
<li>The API doesn’t use <code>Set-Cookie</code> during the login step. It often happens in APIs that were not specifically designed to be accessed from a browser, and they use an authentication pattern that works for servers, too (so no cookies). Your back-end developer will claim it was a “design choice.” Don’t trust them.</li>
<li>The client needs to set an <code>Authorization</code> header with the token. That’s just the symmetrical issue; the API chose not to rely on cookies.</li>
</ol>
<p>You’ll meet a lot of documentation in the wild that shows headers like this:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token maybe-class-name">Authorization</span><span class="token operator">:</span> <span class="token maybe-class-name">Bearer</span> <span class="token operator">&#x3C;</span>token<span class="token operator">></span>
</code></pre>
<p>Setting the <code>Authorization</code> header implies you cannot use an HTTP-Only cookie. Of course, you can set the headers of a request using JavaScript. However, this means that the token must be available to JavaScript in the first place. Let’s repeat it once again: <strong>it’s ok not to use a cookie and prefer web storage, but be very careful with XSS attacks!</strong></p>
<p>Moreover, this pattern works only for programmatic requests with fetch and XHR. You can’t secure access to the web page itself because the browser won’t set this header automatically during navigation. You just really can’t.</p>
<p>If you need to secure web pages, the backend of your website (which may differ from your actual API that serves data) should use HTTP-only cookies, or you should set a non-HTTP-only cookie manually. Either way, be careful that by using cookies, you are introducing a new vector of attacks.</p>
<p>Not all websites need to be secured this way, though. It’s actually pretty uncommon for public-facing websites. Remember Blitz.js’ motto “secure data, not pages.” But the cookie way is still a pattern you must be aware of.</p>
<p>If you really need to secure a web page, reach out to your backend developer and explain to them that cookies are good. They won’t contradict this claim.</p>
<p>If it’s really not possible to improve the API, you might want to adopt a pattern named “backend-for-frontend” (BFF). Basically, have a tiny server owned by the front-end team that takes care of calling authenticated APIs server-side, among other things. It works pretty well with frameworks like Remix or Next.js that have built-in server-oriented features.</p>
<h3 id="side-note-on-basic-auth-looks-like-a-header-behaves-like-a-cookie">Side Note On Basic Auth: Looks Like A Header, Behaves Like A Cookie <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#side-note-on-basic-auth-looks-like-a-header-behaves-like-a-cookie">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#side-note-on-basic-auth-looks-like-a-header-behaves-like-a-cookie"></a></h3>
<p>Of course, every rule must have its exceptions. There is only one common scenario I know where the token can be passed as a request header without using JavaScript: using basic authentication.</p>
<p>Basic authentication is an unsafe pattern, as identifiers are sent alongside every request, not just a token but the actual username and password. It’s a bit like asking your local drug dealer to pay your rent and give them your ID card and 2000$ that they should kindly bring to your landlord. It’s only ok if this is a fake ID. Actually, no, fake IDs and drug dealers are not ok. But you get the point!</p>
<p>It’s still interesting for a few use cases, like quickly securing the demo of a website. As long as you can accept the password to be stolen without that many consequences, typically if the password has been generated by an admin for a temporary occasion (NOT a user-set password that could be reused for multiple services!).</p>
<p>In basic authentication, the browser sets the <code>Authorization</code> header for you. You still need to set the <code>credentials</code> option properly when using <code>fetch</code> programmatically so that the header is also set in this case. But you don’t have to manually tweak the header. It really behaves like a cookie.</p>
<p>That’s actually one reason why this fetch option is named “credentials” and not just “cookies”: it also applies to the basic authentication header.</p>
<h2 id="conclusion">Conclusion <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#conclusion">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#conclusion"></a></h2>
<p>Wow, if you’ve read this far, you definitely earned your right to a quick summary!</p>
<p>But before that, I have another gift for you: <a href="https://github.com/lbke/deno-auth-demo">an open-source demo of authentication with Deno and HTMX for the front end</a>!</p>
<p>This is a very basic setup, but it puts the concepts described in this article into action using the “cookie way.”</p>
<p>Here is your well-deserved TL;DR:</p>
<ul>
<li><strong>JWT is like banknotes, and sessionId is like credit cards.</strong> They are two authentication patterns, but either way, you want to store those tokens safely client-side.</li>
<li><strong>One safe place to store tokens in a browser is an HTTP-only and secure cookie, set via the <code>Set-Cookie</code> header of the login response.</strong> It cannot be stolen by malicious JavaScript code. Web storage is another possibility if you only secure API calls and not web page access. If you pick web storage, then be very careful with XSS attacks.</li>
<li><strong>Cookies are automatically sent alongside every request provided you use the right options</strong>, namely the <code>path</code> and <code>SameSite</code> attributes of the cookie. Like a wallet, you would carry it on you all the time and take it out of your bag only in safe places when a payment is needed.</li>
<li><strong>When navigating via URL, the browser takes care of sending the cookie containing the auth token (if properly set).</strong> But you may also need to call authenticated APIs using JavaScript code. Fetch <code>credentials</code> and XHR <code>withCredentials</code> options have to be configured correctly, so cookies are also sent alongside those programmatic requests. Don’t forget to set the <code>Access-Control-Allow-Credentials</code> response header as well.</li>
<li><strong>Auth is about politeness: the server must set the proper headers for everything to work.</strong> You can’t enter a bank and yell at people to get your money.</li>
<li>This is particularly true for cross-origin requests. Companies must have secure and polite discussions with their bank, which can be separate organizations or located in a distant country. That’s what CORS is for websites and APIs. Don’t forget to properly <strong>set the <code>Access-Control-Allow-Origin</code> and <code>Access-Control-Allow-Credentials</code> headers</strong> in the response.</li>
<li>If you store your savings in your mailbox, put a camera on top of it, and <strong>if you store your token in the web storage, protect it against XSS attacks</strong>.</li>
<li>Banks don’t treat people like they treat other banks. <strong>Don’t confuse webpages patterns</strong> (have to rely on cookies and browser’s built-in features) <strong>and API patterns</strong> (relying on headers, which can be implemented using client-side JavaScript).</li>
<li><strong>Basic auth is a fun pattern that blurs the line, as it uses an Authorization header like for APIs, but it can be used for webpages too.</strong> It’s a specific and very insecure pattern that is only meant for a handful of limited use cases. Basic auth headers are a reason why <code>fetch</code> and <code>XHR</code> options are named “credentials” and not just “cookies.”</li>
</ul>
<h3 id="resources">Resources <a href="https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#resources">#</a><a aria-hidden="true" class="anchor-heading icon-link" href="#resources"></a></h3>
<ul>
<li>Sending programmatic requests with fetch (as opposed to accessing a URL or submitting an HTML form and letting the browser send the request):
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">Using the Fetch API</a>, Mozilla docs</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/fetch">fetch()</a>, Mozilla docs</li>
</ul>
</li>
<li><a href="https://jwt.io/introduction">Intro to JWT token.</a><br>
You’ll notice the ambiguity: it states that JWT should not be stored in browser storage, yet they should usually be passed via header… which implies storing the token in browser storage. But that’s not the only choice. HTTP-only cookies can be used too, and which is the best is an open debate.</li>
<li>“<a href="https://portswigger.net/research/web-storage-the-lesser-evil-for-session-tokens">Web Storage: the lesser evil for session tokens</a>”, James Kettle<br>
HTTP-only cookies are debated: an article in favor of the web storage.</li>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3106237.3121282">Reflections on the REST architectural style and “principled design of the modern web architecture” (impact paper award)</a>, Fielding, R. T., Taylor, R. N., Erenkrantz, J. R., Gorlick, M. M., Whitehead, J., Khare, R., &#x26; Oreizy, P. (2017, August). In Proceedings of the 2017 11th joint meeting on foundations of software engineering (pp. 4-14).<br>
This paper from Fielding et al. states that the use case of session management has been overlooked in the past when defining the REST architectural style, leading to confusion and poor technological solutions</li>
<li>You’ll find many great tutorials in the wild. A quick search for “authentication” on Smashing Magazine will confirm that there are already two great pieces just for Next.js:
<ul>
<li>“<a href="https://www.smashingmagazine.com/2022/04/dynamic-data-fetching-authenticated-nextjs-app/">Dynamic Data-Fetching In An Authenticated Next.js App</a>”, Caleb Olojo (Self-hosted authentication)</li>
<li>“<a href="https://www.smashingmagazine.com/2021/05/implement-authentication-nextjs-auth0/">How To Implement Authentication In Next.js With Auth0</a>”, Facundo Giuliani</li>
</ul>
</li>
<li><a href="https://www.rfc-editor.org/rfc/rfc7519">Standard RFC for JWT</a></li>
<li>“<a href="https://www.smashingmagazine.com/2016/06/the-current-state-of-authentication-we-have-a-password-problem/">The Current State Of Authentication: We Have A Password Problem</a>”, Drew Thomas<br>
There are other ways to authenticate the user than passwords. Most of the content of my article should, however, still hold even with other approaches (magic link, OpenID Connect…).</li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/HTTP/Methods/OPTIONS">The OPTIONS HTTP verb used by the CORS preflight request</a> (triggered on non-simple requests like calling a JSON API with fetch)</li>
<li><a href="https://jub0bs.com/posts/2022-02-08-cve-2022-21703-writeup/#bypassing-content-type-validation-and-avoiding-cors-preflight">Breaking CORS preflight request to bypass CORS</a></li>
<li>“<a href="https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties">Exploiting CORS misconfigurations for Bitcoins and bounties</a>”, James Kettle<br>
Why the scheme (HTTP or HTTPS) matters with CORS; <a href="https://twitter.com/jub0bs/status/1352160391032401923/photo/1">some exploit examples</a>.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#credentialed_requests_and_wildcards">The Wildcard exception</a></li>
<li><a href="https://fetch.spec.whatwg.org/#concept-request-client">Fetch standard definition of a “client”</a></li>
<li><a href="https://stackoverflow.com/questions/10636611/how-does-access-control-allow-origin-header-work">Excellent explanation on Access-Control-Allow-Origin, the header that controls CORS</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">About CORS, and definition of “simple requests”</a></li>
<li><a href="https://stackoverflow.com/a/48231372/5513532">XHR withCredentials in Axios</a></li>
<li><a href="https://portswigger.net/web-security/csrf">CSRF</a><br>
A type of attack to bypass cross-origin restriction (not covered in this article, great read to go further, especially if you go “the cookie way” for API authentication)</li>
<li><a href="https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage">Limits of storing tokens in browser storage</a></li>
<li><a href="https://portswigger.net/web-security/csrf/samesite-cookies">SameSite</a><br>
Configure the cookies to be sent or not when coming from another site</li>
<li>About <a href="https://web.dev/i18n/en/samesite-cookies-explained/">the SameSite attribute for cookies</a>, from web.dev</li>
<li><a href="https://www.honeybadger.io/blog/subdomain-takeover/">Subdomain takeover</a></li>
<li><a href="https://stackoverflow.com/questions/67689503/what-is-top-level-navigation-in-browser-terminology-and-in-what-ways-it-can-be-t">What is a “top-level navigation” in the browser</a></li>
<li>“<a href="https://web.dev/fetch-metadata/">Protect your resources from web attacks with Fetch Metadata</a>”, Lukas Weichselbaum<br>
Another brilliant piece from web.dev about Sec-Fetch headers.</li>
<li>The canonical <a href="https://samnewman.io/patterns/architectural/bff/">definition of Backend For Front-end</a>.<br>
It’s similar to using a centralized API gateway for the front end, except that BFF is decentralized.</li>
<li>“<a href="https://httptoolkit.tech/blog/cache-your-cors/">Cache your CORS, for performance &#x26; profit</a>”, Tim Perry<br>
How to cache preflight requests to reduce your API workload (non-standard at the moment but extremely useful at scale).</li>
<li><a href="https://stackoverflow.com/questions/58173809/next-js-redirect-from-to-another-page">Redirecting in Next.js</a></li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#your-password-matched-now-what" title="Your Password Matched. Now What? #">Your Password Matched. Now What? #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#authentication-relies-on-tokens-like-banks-rely-on-money" title="Authentication Relies On Tokens Like Banks Rely On Money #">Authentication Relies On Tokens Like Banks Rely On Money #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#a-jwt-is-like-a-banknote" title="A JWT Is Like A Banknote #">A JWT Is Like A Banknote #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#session-based-authentication-is-like-a-credit-card" title="Session-Based Authentication Is Like A Credit Card #">Session-Based Authentication Is Like A Credit Card #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#tokens-are-as-precious-as-banknotes-and-credit-cards-dont-get-them-stolen" title="Tokens Are As Precious As Banknotes And Credit Cards. Don’t Get Them Stolen! #">Tokens Are As Precious As Banknotes And Credit Cards. Don’t Get Them Stolen! #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#where-do-you-store-your-money" title="Where Do You Store Your Money? #">Where Do You Store Your Money? #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#not-all-requests-are-born-equal-loading-a-web-page-vs-calling-an-api" title="Not All Requests Are Born Equal: Loading A Web Page vs. Calling An API #">Not All Requests Are Born Equal: Loading A Web Page vs. Calling An API #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#use-case-1-securing-a-web-page-access-with-cookies" title="Use Case 1: Securing A Web Page Access With Cookies #">Use Case 1: Securing A Web Page Access With Cookies #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#use-case-2-securing-api-calls-the-cookie-scenario" title="Use Case 2: Securing API Calls. The Cookie Scenario #">Use Case 2: Securing API Calls. The Cookie Scenario #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#return-of-use-case-2-securing-api-calls-the-web-storage-scenario" title="Return Of Use Case 2: Securing API Calls. The Web Storage Scenario #">Return Of Use Case 2: Securing API Calls. The Web Storage Scenario #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#jwt-specifics-what-information-they-should-contain-and-how-to-handle-the-refresh-token" title="JWT Specifics: What Information They Should Contain And How To Handle The Refresh Token #">JWT Specifics: What Information They Should Contain And How To Handle The Refresh Token #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#cors-is-how-shops-communicate-with-their-bank" title="CORS Is How Shops Communicate With Their Bank #">CORS Is How Shops Communicate With Their Bank #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#a-polite-cross-origin-discussion-between-a-server-and-a-client-using-preflight-requests" title="A Polite Cross-origin Discussion Between A Server And A Client, Using Preflight Requests #">A Polite Cross-origin Discussion Between A Server And A Client, Using Preflight Requests #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#cookies-or-not-cookies-the-samesite-option" title="Cookies Or Not Cookies: The SameSite Option #">Cookies Or Not Cookies: The SameSite Option #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#sec-fetch-helps-detecting-cross-origin-requests-but-are-not-standard-yet" title="Sec-Fetch Helps Detecting Cross-origin Requests But Are Not Standard Yet #">Sec-Fetch Helps Detecting Cross-origin Requests But Are Not Standard Yet #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#no-we-dont-take-checks-dont-confuse-a-web-page-access-and-an-api-call" title="No, We Don’t Take Checks: Don’t Confuse A Web Page Access And An API Call #">No, We Don’t Take Checks: Don’t Confuse A Web Page Access And An API Call #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#using-browser-storage-session-local-and-friend-is-like-using-your-mailbox-as-a-piggy-bank" title="Using Browser Storage (Session, Local, And Friend) Is Like Using Your Mailbox As A Piggy Bank #">Using Browser Storage (Session, Local, And Friend) Is Like Using Your Mailbox As A Piggy Bank #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#jwts-passed-as-header-its-a-pattern-for-api-calls-only" title="JWTs Passed As Header: It’s A Pattern For API Calls Only #">JWTs Passed As Header: It’s A Pattern For API Calls Only #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#side-note-on-basic-auth-looks-like-a-header-behaves-like-a-cookie" title="Side Note On Basic Auth: Looks Like A Header, Behaves Like A Cookie #">Side Note On Basic Auth: Looks Like A Header, Behaves Like A Cookie #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#conclusion" title="Conclusion #">Conclusion #</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#resources" title="Resources #">Resources #</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"515c59eesgg7k7pwwfiu2tx","title":"Understanding Authentication In Websites: A Banking Analogy","desc":"","updated":1675226019807,"created":1675211419496,"custom":{},"fname":"dev.auth.authentication-websites-banking-analogy","type":"note","vault":{"fsPath":"vault"},"contentHash":"2fd3033cbf06a450e841bade85ac1fd2","links":[],"anchors":{"your-password-matched-now-what":{"type":"header","text":"Your Password Matched. Now What? #","value":"your-password-matched-now-what","line":11,"column":0,"depth":2},"authentication-relies-on-tokens-like-banks-rely-on-money":{"type":"header","text":"Authentication Relies On Tokens Like Banks Rely On Money #","value":"authentication-relies-on-tokens-like-banks-rely-on-money","line":19,"column":0,"depth":2},"a-jwt-is-like-a-banknote":{"type":"header","text":"A JWT Is Like A Banknote #","value":"a-jwt-is-like-a-banknote","line":32,"column":0,"depth":3},"session-based-authentication-is-like-a-credit-card":{"type":"header","text":"Session-Based Authentication Is Like A Credit Card #","value":"session-based-authentication-is-like-a-credit-card","line":42,"column":0,"depth":3},"tokens-are-as-precious-as-banknotes-and-credit-cards-dont-get-them-stolen":{"type":"header","text":"Tokens Are As Precious As Banknotes And Credit Cards. Don’t Get Them Stolen! #","value":"tokens-are-as-precious-as-banknotes-and-credit-cards-dont-get-them-stolen","line":60,"column":0,"depth":2},"where-do-you-store-your-money":{"type":"header","text":"Where Do You Store Your Money? #","value":"where-do-you-store-your-money","line":66,"column":0,"depth":3},"not-all-requests-are-born-equal-loading-a-web-page-vs-calling-an-api":{"type":"header","text":"Not All Requests Are Born Equal: Loading A Web Page vs. Calling An API #","value":"not-all-requests-are-born-equal-loading-a-web-page-vs-calling-an-api","line":70,"column":0,"depth":3},"use-case-1-securing-a-web-page-access-with-cookies":{"type":"header","text":"Use Case 1: Securing A Web Page Access With Cookies #","value":"use-case-1-securing-a-web-page-access-with-cookies","line":85,"column":0,"depth":3},"use-case-2-securing-api-calls-the-cookie-scenario":{"type":"header","text":"Use Case 2: Securing API Calls. The Cookie Scenario #","value":"use-case-2-securing-api-calls-the-cookie-scenario","line":113,"column":0,"depth":3},"return-of-use-case-2-securing-api-calls-the-web-storage-scenario":{"type":"header","text":"Return Of Use Case 2: Securing API Calls. The Web Storage Scenario #","value":"return-of-use-case-2-securing-api-calls-the-web-storage-scenario","line":144,"column":0,"depth":3},"jwt-specifics-what-information-they-should-contain-and-how-to-handle-the-refresh-token":{"type":"header","text":"JWT Specifics: What Information They Should Contain And How To Handle The Refresh Token #","value":"jwt-specifics-what-information-they-should-contain-and-how-to-handle-the-refresh-token","line":162,"column":0,"depth":3},"cors-is-how-shops-communicate-with-their-bank":{"type":"header","text":"CORS Is How Shops Communicate With Their Bank #","value":"cors-is-how-shops-communicate-with-their-bank","line":176,"column":0,"depth":2},"a-polite-cross-origin-discussion-between-a-server-and-a-client-using-preflight-requests":{"type":"header","text":"A Polite Cross-origin Discussion Between A Server And A Client, Using Preflight Requests #","value":"a-polite-cross-origin-discussion-between-a-server-and-a-client-using-preflight-requests","line":206,"column":0,"depth":3},"cookies-or-not-cookies-the-samesite-option":{"type":"header","text":"Cookies Or Not Cookies: The SameSite Option #","value":"cookies-or-not-cookies-the-samesite-option","line":237,"column":0,"depth":3},"sec-fetch-helps-detecting-cross-origin-requests-but-are-not-standard-yet":{"type":"header","text":"Sec-Fetch Helps Detecting Cross-origin Requests But Are Not Standard Yet #","value":"sec-fetch-helps-detecting-cross-origin-requests-but-are-not-standard-yet","line":255,"column":0,"depth":3},"no-we-dont-take-checks-dont-confuse-a-web-page-access-and-an-api-call":{"type":"header","text":"No, We Don’t Take Checks: Don’t Confuse A Web Page Access And An API Call #","value":"no-we-dont-take-checks-dont-confuse-a-web-page-access-and-an-api-call","line":271,"column":0,"depth":2},"using-browser-storage-session-local-and-friend-is-like-using-your-mailbox-as-a-piggy-bank":{"type":"header","text":"Using Browser Storage (Session, Local, And Friend) Is Like Using Your Mailbox As A Piggy Bank #","value":"using-browser-storage-session-local-and-friend-is-like-using-your-mailbox-as-a-piggy-bank","line":279,"column":0,"depth":3},"jwts-passed-as-header-its-a-pattern-for-api-calls-only":{"type":"header","text":"JWTs Passed As Header: It’s A Pattern For API Calls Only #","value":"jwts-passed-as-header-its-a-pattern-for-api-calls-only","line":289,"column":0,"depth":3},"side-note-on-basic-auth-looks-like-a-header-behaves-like-a-cookie":{"type":"header","text":"Side Note On Basic Auth: Looks Like A Header, Behaves Like A Cookie #","value":"side-note-on-basic-auth-looks-like-a-header-behaves-like-a-cookie","line":316,"column":0,"depth":3},"conclusion":{"type":"header","text":"Conclusion #","value":"conclusion","line":328,"column":0,"depth":2},"resources":{"type":"header","text":"Resources #","value":"resources","line":348,"column":0,"depth":3}},"children":[],"parent":"v45kc46huiqczj6vx691qf9","data":{}},"body":"\u003ch1 id=\"understanding-authentication-in-websites-a-banking-analogy\"\u003eUnderstanding Authentication In Websites: A Banking Analogy\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#understanding-authentication-in-websites-a-banking-analogy\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eYou’ll learn about tokens, authorization, CORS, credentials, HTTP headers, and such. It shouldn’t have to take a wizard to implement a good authentication system. Just a good banker!\u003cbr\u003e\n\u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/\"\u003ehttps://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"your-password-matched-now-what\"\u003eYour Password Matched. Now What? \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#your-password-matched-now-what\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#your-password-matched-now-what\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eAuthentication is the process of attributing a given request to a unique entity\u003c/strong\u003e, usually a person. It then enables authorization, the process of allowing (or not) said person to access a resource, be it a web page or an API endpoint.\u003c/p\u003e\n\u003cp\u003eI will focus on the part I’ve always found the most difficult to understand: what happens after the user just submitted the login form and their credentials were confirmed as valid by the backend.\u003c/p\u003e\n\u003cp\u003eWe are going to talk about tokens, CORS, cookies, and headers. Those concepts are sometimes quite abstract. To make them more real, I’ll take a shot at a banking analogy.\u003c/p\u003e\n\u003ch2 id=\"authentication-relies-on-tokens-like-banks-rely-on-money\"\u003eAuthentication Relies On Tokens Like Banks Rely On Money \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#authentication-relies-on-tokens-like-banks-rely-on-money\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#authentication-relies-on-tokens-like-banks-rely-on-money\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLet’s consider two common patterns:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eJSON Web Tokens aka JWT.\u003c/strong\u003e\u003cbr\u003e\nIt’s an open standard. You’ll find useful resources at the bottom of this article if you want to go further.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eSession-based authentication.\u003c/strong\u003e\u003cbr\u003e\nIt’s a pattern more than a standard. So the implementation may vary, but I’ll try to give an overview of how it works.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs a front-end developer, you may have no control over this design decision, so it’s important that you understand how both work.\u003c/p\u003e\n\u003cp\u003eAs a full-stack or backend developer, you have control over this choice, so it’s even more important that you understand what you are doing. I mean, it’s kinda your job :)\u003c/p\u003e\n\u003ch3 id=\"a-jwt-is-like-a-banknote\"\u003eA JWT Is Like A Banknote \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#a-jwt-is-like-a-banknote\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#a-jwt-is-like-a-banknote\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e...\u003c/p\u003e\n\u003cp\u003eIf you want to use your money, either at the bank to credit your account or in a store, people will double-check that your banknotes are real. A real banknote is one that has been created by the bank itself. When the banknote is confirmed to be legit, they can read the value on it to tell how many things you can buy.\u003c/p\u003e\n\u003cp\u003eJWTs work the same, the server can verify that they indeed created this token earlier, so it’s a real one, and then they can read the payload it contains to confirm who you are and what your permissions are.\u003c/p\u003e\n\u003cp\u003eRevoking a token can be hard. The server has to maintain a list of blacklisted tokens that are no longer valid, like the bank would need to list robbed banknotes’ unique numbers.\u003c/p\u003e\n\u003ch3 id=\"session-based-authentication-is-like-a-credit-card\"\u003eSession-Based Authentication Is Like A Credit Card \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#session-based-authentication-is-like-a-credit-card\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#session-based-authentication-is-like-a-credit-card\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eFrom the front-end developer standpoint, the main difference between JWT and session-based authentication lies in what the server will return in case of a successful login.\u003c/p\u003e\n\u003cp\u003eIn session-based authentication, instead of having a claim full of user information, you just get a “session id.”\u003c/p\u003e\n\u003cp\u003eFrom the backend developer’s standpoint, session-based authentication involves an additional database collection or table to store the sessions. A session is just an object very similar to the JWT, which can contain, for instance, a user id and an expiration date.\u003c/p\u003e\n\u003cp\u003eThis means that the server keeps a lot of control over the authentication. It can log a user out by removing the session from the database, whereas it cannot destroy JWTs, since it doesn’t store them.\u003c/p\u003e\n\u003cp\u003eSession-based authentication is comparable to credit cards. You go to the bank to open your account. The banker will check your id and issue a credit card with an expiration date. This is the authentication process.\u003c/p\u003e\n\u003cp\u003eThe credit card itself has barely any value: it’s just plastic and a microchip whose purpose is to uniquely identify your account. It can easily be revoked by the bank, usually after a certain period of time, but also when you declare your card stolen.\u003c/p\u003e\n\u003cp\u003eWhen you want to pay for something, the store will communicate with your bank to check that your credit card is valid and has a positive balance.\u003c/p\u003e\n\u003cp\u003eWhen you access an authenticated resource, the server will check if the session id matches an open session and then if this session matches a user that is authorized to access this resource.\u003c/p\u003e\n\u003ch2 id=\"tokens-are-as-precious-as-banknotes-and-credit-cards-dont-get-them-stolen\"\u003eTokens Are As Precious As Banknotes And Credit Cards. Don’t Get Them Stolen! \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#tokens-are-as-precious-as-banknotes-and-credit-cards-don-t-get-them-stolen\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#tokens-are-as-precious-as-banknotes-and-credit-cards-dont-get-them-stolen\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIt’s easy for companies and banks to store money. They have those big reinforced-steel safes with alarms and sometimes even dragons. Likewise, it’s easy for servers to talk securely to one another.\u003c/p\u003e\n\u003cp\u003eBut websites are like private persons. They can’t have dragons, so they have to imagine specific approaches to store their precious tokens.\u003c/p\u003e\n\u003ch3 id=\"where-do-you-store-your-money\"\u003eWhere Do You Store Your Money? \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#where-do-you-store-your-money\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#where-do-you-store-your-money\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e...\u003c/p\u003e\n\u003ch3 id=\"not-all-requests-are-born-equal-loading-a-web-page-vs-calling-an-api\"\u003eNot All Requests Are Born Equal: Loading A Web Page vs. Calling An API \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#not-all-requests-are-born-equal-loading-a-web-page-vs-calling-an-api\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#not-all-requests-are-born-equal-loading-a-web-page-vs-calling-an-api\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eWe can divide authenticated content into two categories: web pages and API endpoints. From a technical standpoint, both are server endpoints. The former returns HTML content or files, the latter — any kind of content, often JSON data. They differ in the way they are consumed.\u003c/p\u003e\n\u003cp\u003eWeb pages are accessed via a web browser that triggers GET requests automatically, depending on the current URL.\u003c/p\u003e\n\u003cp\u003eAPIs are called using JavaScript code. This reliance on APIs and JavaScript is at the core of the Jamstack, REST, and Single-Page-Application philosophies.\u003c/p\u003e\n\u003cp\u003eThus, let’s differentiate two use cases:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eYou want to \u003cstrong\u003esecure access to the web page\u003c/strong\u003e itself. Meaning the user can’t even see the structure of your page or any HTML.\u003c/li\u003e\n\u003cli\u003eYou want to \u003cstrong\u003esecure calls from your web page to your API\u003c/strong\u003e. Anyone can see your web page structure, but they can’t get any data.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIf you combine both, unauthenticated users can’t see the page structure and can’t get any data from your API.\u003c/p\u003e\n\u003ch3 id=\"use-case-1-securing-a-web-page-access-with-cookies\"\u003eUse Case 1: Securing A Web Page Access With Cookies \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#use-case-1-securing-a-web-page-access-with-cookies\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#use-case-1-securing-a-web-page-access-with-cookies\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eI’ll cut it short, to secure web page access, you have no other choice but to use cookies, ideally HTTP-Only, secure cookies.\u003c/p\u003e\n\u003cp\u003eFrom a technical standpoint, a cookie is a piece of data that should be sent alongside every request to a specific domain. They are part of the HTTP protocol.\u003c/p\u003e\n\u003cp\u003eThat’s a pretty broad scope. When a website cookie popup differentiates “essential cookies” from other cookies, those essential cookies are often dedicated to authentication. The others are just a way to keep track of the product pages you’ve visited to later shove them in your face to the point of literally optimizing the billboard displays in your neighborhood as if you really, really wanted to buy two freezers within the same month.\u003c/p\u003e\n\u003cp\u003eSetting a cookie is possible in both directions. Client-side JavaScript can set cookies to be sent to the server. That’s how advertisement tracking works (though GDPR is forcing advertisers to use server-side logic more and more these days).\u003c/p\u003e\n\u003cp\u003eBut the server can also tell the browser to store a cookie using the \u003ccode\u003eSet-Cookie\u003c/code\u003e header in the response.\u003c/p\u003e\n\u003cp\u003eThis convenient feature lets the backend set what we call “HTTP-only” cookies: cookies that cannot be read by JavaScript. And “secure” cookies are only set through HTTPS for better security.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eImportant note\u003c/strong\u003e: \u003cem\u003eUsing HTTP-only cookies prevents XSS attacks (script injection to steal the token) but not CSRF attacks (forging requests on behalf of your authenticated users, basically impersonating them). You need to combine multiple strategies to parry all possible attacks. I invite you to read more on these topics if you manage a non-trivial website.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eDuring the authentication process, the \u003ccode\u003eSet-Cookie\u003c/code\u003e header should be used in response to the “login” request so the client becomes authenticated via a token.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA \u003ccode\u003eSet-Cookie\u003c/code\u003e header in the response of the login request, as seen in browser development tools. The browser will automatically store this cookie. Since it’s HTTP-only, JavaScript can’t read it; it’s only handled by the browser directly. (\u003ca href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/588a49e9-4e23-4962-926f-f0a5325195f3/5-authentication-websites-banking-analogy.png\"\u003eLarge preview\u003c/a\u003e)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eCookies are like a wallet. You can store fidelity cards in it and a picture of your cat, but also duller things, like your money. It’s in your pocket or your handbag, so it’s hard to access for other people (HTTP-only, no JavaScript access) if you don’t take it out in unsafe places (secure). Yet, you always have your token with you if needed.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe cookie displayed in your browser development tools, after being set. It is NOT available to JavaScript code! A successful script injection cannot steal your users’ tokens, but be careful about other types of attacks like CSRF. Here the cookie is not ‘secure’ because I am in \u003ccode\u003elocalhost\u003c/code\u003e mode. (\u003ca href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/e19a0377-4a0b-420f-a9a2-357fbdf0c170/9-authentication-websites-banking-analogy.png\"\u003eLarge preview\u003c/a\u003e)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eBrowsers rely a lot on cookies, and they send them automatically alongside every request they trigger as long as the domain and path match, so you don’t have to worry about them. If you carry your wallet with you anytime you go out, you’re always ready to pay.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe \u003ccode\u003eCookie\u003c/code\u003e header is added automatically to the request emitted by the browser during navigation, as long as the domain and path are matching. (\u003ca href=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8bdba247-4fa0-4ba7-9a10-9fb89b2e5146/8-authentication-websites-banking-analogy.png\"\u003eLarge preview\u003c/a\u003e)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"use-case-2-securing-api-calls-the-cookie-scenario\"\u003eUse Case 2: Securing API Calls. The Cookie Scenario \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#use-case-2-securing-api-calls-the-cookie-scenario\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#use-case-2-securing-api-calls-the-cookie-scenario\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eNow, let’s authenticate calls to our API, which feeds the website with data. The easiest option would be to use a cookie, as we did in the previous section, to secure web pages. But contrary to the web page, there is also another option — using web storage. Which one is the most suited is debatable. Let me start with cookies.\u003c/p\u003e\n\u003cp\u003eThe cookie that contains the auth token is sent automatically alongside requests triggered by the browser when you navigate a website or when you submit a form.\u003c/p\u003e\n\u003cp\u003eBut requests triggered by JavaScript code do not fall into this category. When you trigger a request programmatically, you need a bit more configuration to send cookies.\u003c/p\u003e\n\u003cp\u003eRemember that the cookie should be HTTP-only, so you can’t read the cookie content with JavaScript nor inject your token in the \u003ccode\u003eAuthorization\u003c/code\u003e header. You could do that with a cookie that is not HTTP-only, but then using a cookie doesn’t make sense in the first place.\u003c/p\u003e\n\u003cp\u003eAll existing libraries capable of sending requests have to be based on the browser JavaScript API aka the “Browser Object Model,” which means either \u003ccode\u003eXMLHttpRequest\u003c/code\u003e or \u003ccode\u003efetch\u003c/code\u003e. You have to rely on their configuration to enable sending HTTP-only cookies alongside the request.\u003c/p\u003e\n\u003cp\u003eIn the case of \u003ccode\u003efetch\u003c/code\u003e, this option is named \u003ccode\u003ecredentials\u003c/code\u003e. Hopefully, for you, fellow front-end developers, it’s very easy to use.\u003c/p\u003e\n\u003cpre class=\"language-js\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"token function\"\u003efetch\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"http://localhost:8000/account/signup\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  method\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"POST\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  body\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token known-class-name class-name\"\u003eJSON\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003estringify\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e username\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"foo\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e password\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"barbar\"\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// This will include credentials (here, cookies) in the request\u003c/span\u003e\n  credentials\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"include\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith XHR, the option is named \u003ccode\u003ewithCredentials\u003c/code\u003e and behaves similarly.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: \u003cem\u003eYour server must also confirm that it indeed accepts credentials by setting the \u003ccode\u003eAccess-Control-Allow-Credentials\u003c/code\u003e header to true in the responses. This option is symmetrical. It controls both sending cookies to the server, but also accepting the \u003ccode\u003eSet-Cookie\u003c/code\u003e header from it. So don’t forget to set it to true for the call to the login endpoint.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIf the \u003ccode\u003ecredentials\u003c/code\u003e option is not set and the server answers with a \u003ccode\u003eSet-Cookie\u003c/code\u003e header… the browser will silently ignore this attempt to set the cookie without even a warning. When this happens, start by double-checking your \u003ccode\u003ecredentials\u003c/code\u003e option and then CORS if applicable (see next section).\u003c/p\u003e\n\u003cp\u003eOops, I’ve almost forgotten your banking analogy! It’s a tough one but let’s say that you probably have your credit card or a few banknotes always there in your wallet. But some services expect a prepaid card, and you may need to explicitly remember to take them with you. \u003cem\u003eThat’s the best analogy I could achieve. Comment if you can do better!\u003c/em\u003e\u003c/p\u003e\n\u003ch3 id=\"return-of-use-case-2-securing-api-calls-the-web-storage-scenario\"\u003eReturn Of Use Case 2: Securing API Calls. The Web Storage Scenario \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#return-of-use-case-2-securing-api-calls-the-web-storage-scenario\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#return-of-use-case-2-securing-api-calls-the-web-storage-scenario\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eRemember, I said earlier that for API calls, you have the choice to either store the token in an HTTP-only cookie, like you would do to secure a web page, or to store the token in the web storage. By web storage, we mean either \u003ccode\u003esessionStorage\u003c/code\u003e or \u003ccode\u003elocalStorage\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eI’ve seen and used both approaches, cookies and web storage, but I sincerely don’t have the expertise to assert that one is better than the other. I’ll stick to describing how it works so you can make an enlightened decision.\u003c/p\u003e\n\u003cp\u003eCodewise, they are much easier to use than HTTP-only cookies because web storage is available to JavaScript code. You can get the token from the login response payload, store it in \u003ccode\u003elocalStorage\u003c/code\u003e, and insert it into the \u003ccode\u003eAuthorization\u003c/code\u003e header in later requests. You have full control of the process without relying on some implicit browser behavior.\u003c/p\u003e\n\u003cpre class=\"language-js\"\u003e\u003ccode class=\"language-js\"\u003eheaders\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    “Authorization”\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token template-string\"\u003e\u003cspan class=\"token template-punctuation string\"\u003e`\u003c/span\u003e\u003cspan class=\"token string\"\u003eBearer \u003c/span\u003e\u003cspan class=\"token interpolation\"\u003e\u003cspan class=\"token interpolation-punctuation punctuation\"\u003e${\u003c/span\u003e\u003cspan class=\"token dom variable\"\u003ewindow\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token property-access\"\u003elocalStorage\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003eget\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e“auth_token”\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token interpolation-punctuation punctuation\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token template-punctuation string\"\u003e`\u003c/span\u003e\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWeb storage is immune to certain attacks, namely Cross-Site Request Forgery. That’s because, contrary to cookies, they are not automatically tied to requests, so an attacker will have trouble forcing you to give your token. Think of a piggy bank. You can’t just get money out of it. It’s, however, very sensitive to script injection, where an attacker manages to run JavaScript and reads the token.\u003c/p\u003e\n\u003cp\u003eTherefore, if you go the web storage way, you’ll want to explore strategies that prevent XSS attacks from happening in the first place.\u003c/p\u003e\n\u003ch3 id=\"jwt-specifics-what-information-they-should-contain-and-how-to-handle-the-refresh-token\"\u003eJWT Specifics: What Information They Should Contain And How To Handle The Refresh Token \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#jwt-specifics-what-information-they-should-contain-and-how-to-handle-the-refresh-token\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#jwt-specifics-what-information-they-should-contain-and-how-to-handle-the-refresh-token\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eYou should avoid storing critical information in a JSON web token, even when using HTTP-only cookies. If someone still manages to steal and decrypt the token, they will be able to impersonate the user, but at least they won’t be able to get much information from the token itself.\u003c/p\u003e\n\u003cp\u003eYou can afford to lose a five-dollar banknote; it’s more problematic to lose a $5,000 banknote. By the way, if such a thing as a $5,000 banknote exists, please send me a specimen to prove it. Thank you.\u003c/p\u003e\n\u003cp\u003eJWTs are meant to be short-lived, like banknotes, which would wear quickly when used a lot. Since they are hard to revoke, giving them 5-minute lifetime guarantees that even a stolen JWT token cannot be a big problem.\u003c/p\u003e\n\u003cp\u003eSince you don’t want the user to log in again every 5 minutes, the token can be combined with a longer-lived refresh token. This second token can be used to get a new JWT.\u003c/p\u003e\n\u003cp\u003eA best practice is to store the refresh token in a cookie on a very specific path like \u003ccode\u003e/refresh\u003c/code\u003e (so it’s not sent with all requests, contrary to the JWT) and to make it a one-time-only token.\u003c/p\u003e\n\u003cp\u003eA refresh token is like bringing your ID card to get more money from your bank account. You don’t do that often, and you probably want to store your ID even more safely than your banknotes.\u003c/p\u003e\n\u003ch2 id=\"cors-is-how-shops-communicate-with-their-bank\"\u003eCORS Is How Shops Communicate With Their Bank \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#cors-is-how-shops-communicate-with-their-bank\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#cors-is-how-shops-communicate-with-their-bank\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eFormally, CORS (Cross-Origin Resource Sharing) is a protocol used by servers in order to instruct browsers to selectively relax some of the Same-Origin Policy (SOP) restrictions on network access for some trusted clients.\u003c/p\u003e\n\u003cp\u003eLess formally, the server can tell your browser that the request you send is legit based on the request’s origin. If the server says it’s not legit, the browser won’t send the request.\u003c/p\u003e\n\u003cp\u003eFor instance, \u003ccode\u003ehttps://www.foobar.com\u003c/code\u003e, \u003ccode\u003ehttps://qarzed.fake\u003c/code\u003e, and \u003ccode\u003ehttp://localhost:8080\u003c/code\u003e are possible origins. The port and protocol matter.\u003c/p\u003e\n\u003cp\u003eAn API hosted on \u003ccode\u003ehttps://api.foobar.com\u003c/code\u003e will most often allow requests only from \u003ccode\u003ehttps://www.foobar.com\u003c/code\u003e and \u003ccode\u003ehttps://mobile.foobar.com\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eI will focus here on API calls triggered with \u003ccode\u003efetch\u003c/code\u003e in JavaScript, and only if the API lives in another Web origin. CORS also affects more advanced use cases like embedding images from another website in your own website, iframe, navigating from one site to another, and so on, but that’s beyond the scope of authentication per se.\u003c/p\u003e\n\u003cp\u003eWebsites are like stores. People can enter them and try to buy things. But the store also has its own complicated internal back office logic. Namely, it relies on a bank to process payments.\u003c/p\u003e\n\u003cp\u003eAny shop owner can try to connect to any bank. Any website can try to connect to any API. But the payment won’t be processed by the bank if they don’t have a company account there.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA store (a website) should only communicate with banks (APIs) they work with. Other banks will politely reject their requests. Note: this strategy is not enough to secure a server; CORS can be bypassed by attackers.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eLikewise, if you host the website on \u003ccode\u003ewww.foobar.com\u003c/code\u003e and the API on \u003ccode\u003ewww.foobar.com/api\u003c/code\u003e, there is one origin only \u003ccode\u003ewww.foobar.com\u003c/code\u003e. No need for CORS because there is no “cross-origin” call involved. You’ll need to bother about CORS if, instead, you host the API on \u003ccode\u003eapi.foobar.com\u003c/code\u003e. We have two distinct origins, \u003ccode\u003eapi.foobar.com\u003c/code\u003e and \u003ccode\u003ewww.foobar.com\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis also applies to using different ports on \u003ccode\u003elocalhost\u003c/code\u003e during development. The IP \u003ccode\u003e127.0.0.1\u003c/code\u003e is even different from \u003ccode\u003elocalhost\u003c/code\u003e, as origins are compared directly as strings and not based on their actual IP address.\u003c/p\u003e\n\u003cp\u003eSome big companies, like car sellers, have their own internal bank. It’s easier for them to communicate with this bank if it’s literally located in the same office. They are like full-stack monolithic applications.\u003c/p\u003e\n\u003cp\u003eBut if this internal bank is located in a different country (API separate from the website), this doesn’t work anymore. It could as well be a traditional bank with multiple clients (a third-party API). CORS is needed either way.\u003c/p\u003e\n\u003cp\u003eCORS is a concept specific to browser-server communication. When a server talks to another server, the Same-Origin Policy doesn’t apply. The API may either block those requests with no origin completely or, on the contrary, accept them, or filter them based on IP and so on.\u003c/p\u003e\n\u003cp\u003eBanks have specific patterns of communicating with each other that are different from how they communicate with their client companies.\u003c/p\u003e\n\u003ch3 id=\"a-polite-cross-origin-discussion-between-a-server-and-a-client-using-preflight-requests\"\u003eA Polite Cross-origin Discussion Between A Server And A Client, Using Preflight Requests \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#a-polite-cross-origin-discussion-between-a-server-and-a-client-using-preflight-requests\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#a-polite-cross-origin-discussion-between-a-server-and-a-client-using-preflight-requests\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eHere’s a more concrete vision of what happens during a cross-origin request and how the server response headers should be set.\u003c/p\u003e\n\u003cp\u003eFrom the browser standpoint, whenever a website sends a “non-simple” request to an API, the browser will first send a preflight request. It’s a request to the same URL but using the OPTIONS method, which is dedicated to checking whether you can actually consume this API endpoint.\u003c/p\u003e\n\u003cp\u003eFetching JSON data falls into this “non-simple” category in standard browsers, as well as calling your login endpoint if the auth API doesn’t live on the same domain as your website, so this step is extremely important.\u003c/p\u003e\n\u003cp\u003eThe server receives this request, which includes an Origin header. It checks its own list of accepted origins. If the origin is allowed, it will respond with the right \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e header.\u003c/p\u003e\n\u003cp\u003eThis server header should match the website’s origin. It can also be a wildcard \u003ccode\u003e*\u003c/code\u003e if the API is totally open, but that works only for requests without credentials, so forget about this if your API requires authentication.\u003c/p\u003e\n\u003cp\u003eIf the response header doesn’t match, the browser will trigger an error at this point because they already know that they can’t call this API. Otherwise, they will keep going and send the actual request.\u003c/p\u003e\n\u003cp\u003eA store (the API) can decide to accept only certain types of credit cards. Some stores accept only their own card, and they don’t even use CORS (same-origin scenario). Some stores accept only Visa or Mastercards (cross-origin scenario). The cashier (the browser) won’t let you pay if they are told your card is not accepted by the store.\u003c/p\u003e\n\u003cp\u003eThere are a few other \u003ccode\u003eAccess-Control\u003c/code\u003e headers that provide more information, like accepted methods or headers. \u003ccode\u003eAllow-Origin\u003c/code\u003e is the most basic one, as well as \u003ccode\u003eAllow-Credentials\u003c/code\u003e, so cookies and \u003ccode\u003eSet-Cookie\u003c/code\u003e headers are properly enabled when using \u003ccode\u003efetch\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAccess-control-allow-origin: https://www.foobar.com\nAccess-control-allow-credentials: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eExpected response headers for an authenticated call (or the “login” form submission) if the website lives on \u003ccode\u003ehttps://www.foobar.com\u003c/code\u003e and the API is on another domain or port.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: \u003cem\u003eThe server specifies the CORS policy, and the browser enforces it. If suddenly everyone used an unsafe browser run by pirates, they could swarm your server with forged requests. Hopefully, people usually don’t use a shady browser they found in a USB key itself found lying on the ground of a dark alley at 3 am.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThe header things and the browser behavior are just politeness. The browser is an excessively polite software. It will never spam the server with requests that will be rejected anyway. And it won’t talk to rude servers that don’t set the proper headers. That’s why the \u003ccode\u003eAccept-Control-Allow-Origin\u003c/code\u003e response header must be correctly set for cross-origin requests to work.\u003c/p\u003e\n\u003cp\u003eBefore going as far as aiming a customer with a shotgun, the banker will probably tell you, “sir, you entered the wrong bank office,” and the customer will probably answer, “oh, sorry, my mistake. I will leave immediately!”.\u003c/p\u003e\n\u003ch3 id=\"cookies-or-not-cookies-the-samesite-option\"\u003eCookies Or Not Cookies: The SameSite Option \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#cookies-or-not-cookies-the-samesite-option\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#cookies-or-not-cookies-the-samesite-option\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSetting the \u003ccode\u003ecredentials\u003c/code\u003e attribute in your \u003ccode\u003efetch\u003c/code\u003e request is not enough for sending the cookie, plus it doesn’t apply to pages, only to programmatic requests. The \u003ccode\u003eSameSite\u003c/code\u003e attribute of cookies lets you configure when a cookie should be sent, depending on the current site.\u003c/p\u003e\n\u003cp\u003eThe concept of “Site” is slightly different from the concept of domain:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ehttps://api.foobar.com\u003c/code\u003e and \u003ccode\u003ehttps://www.foobar.com\u003c/code\u003e are 2 different domains.\u003c/li\u003e\n\u003cli\u003eThey are, however, the same site. Nowadays, the scheme matters, too (HTTP vs. HTTPS).\u003c/li\u003e\n\u003cli\u003eThere is an exception to this rule, e.g., in multi-tenant architectures: \u003ccode\u003efoo.github.io\u003c/code\u003e and \u003ccode\u003ebar.github.io\u003c/code\u003e will be different sites despite having the same domain, and the server owner can configure that to their will.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf the \u003ccode\u003eAccess-control\u003c/code\u003e response headers are correctly set, and the preflight request succeeds, the browser will proceed with the actual request.\u003c/p\u003e\n\u003cp\u003eBut if \u003ccode\u003eSameSite\u003c/code\u003e is not set with the right value in the cookie containing the authentication token, this cookie won’t be sent to the server. When loading a page, you will be considered unauthenticated by the server just because it literally doesn’t have your cookie.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eSameSite\u003c/code\u003e: \u003ccode\u003eLax\u003c/code\u003e value is usually the most appropriate. It will only send cookies to the same site but also when the user comes from another site and is redirected to your page (only for top-level navigations). This is the current default in most browsers.\u003c/p\u003e\n\u003cp\u003eWith \u003ccode\u003eSameSite\u003c/code\u003e: \u003ccode\u003eLax\u003c/code\u003e, the website \u003ccode\u003ewww.foobar.com\u003c/code\u003e will automatically include the authentication cookie when it sends requests to \u003ccode\u003eapi.foobar.com\u003c/code\u003e, which is part of the same site. Authentication will work as expected.\u003c/p\u003e\n\u003ch3 id=\"sec-fetch-helps-detecting-cross-origin-requests-but-are-not-standard-yet\"\u003eSec-Fetch Helps Detecting Cross-origin Requests But Are Not Standard Yet \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#sec-fetch-helps-detecting-cross-origin-requests-but-are-not-standard-yet\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#sec-fetch-helps-detecting-cross-origin-requests-but-are-not-standard-yet\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eRelated to CORS, you may also hear about the \u003ccode\u003eSec-Fetch\u003c/code\u003e request headers. They provide information about the request context to the server. For instance, if \u003ccode\u003eSec-Fetch-Site\u003c/code\u003e is \u003ccode\u003esame-origin\u003c/code\u003e, there is no need to check the Origin header. It’s slightly more intuitive than manually checking the request origin against predefined rules. If it’s \u003ccode\u003esame-site\u003c/code\u003e, you still need to add the required CORS headers in the response because the site and the origin are different concepts.\u003c/p\u003e\n\u003cp\u003eHowever, those headers are not sent by all browsers. Namely, Safari doesn’t support them at the time of writing. Therefore, they can only act as a secondary solution to identify a request’s origin.\u003c/p\u003e\n\u003cp\u003eA bank can identify you via your passport, but not everybody has a passport, so you will always need to resort to a good old ID card. Passports are still a cool way to identify people when available. That’s what the \u003ccode\u003eSec-Fetch\u003c/code\u003e headers are.\u003c/p\u003e\n\u003cp\u003eKeep in mind that attackers may trick users into sending requests they don’t want to, but they still have no control over which browser will send the request. Thus, \u003ccode\u003eSec-Fetch\u003c/code\u003e headers are still useful despite being supported only by some browsers. When they are present, they are a reliable piece of information.\u003c/p\u003e\n\u003cp\u003eMore broadly, cross-origin and cross-site security patterns are based on the fact that users are using legitimate browsers that should never try to voluntarily mislead servers about the origin. Beware of more elaborate attacks, such as subdomain takeover, that can still bypass these security measures.\u003c/p\u003e\n\u003cp\u003eYou may think, what about servers, then? Server requests are able to spoof a request origin, effectively bypassing CORS. Well, that’s right: CORS is a browser-server security mechanism; it simply doesn’t apply to server-server calls. Someone can build an API that calls your own API and serve the result to another website. True.\u003c/p\u003e\n\u003cp\u003eHowever, the thief will have to host a server, which isn’t free, so they will pay actual money for this API call, and the server IP may be traced back to them. It’s way less attractive than forcing browsers to send the request directly to your API, which would be free and trace back to the first victim, your user, and not to the attacker. Thanks to CORS, this worst-case scenario is not possible.\u003c/p\u003e\n\u003ch2 id=\"no-we-dont-take-checks-dont-confuse-a-web-page-access-and-an-api-call\"\u003eNo, We Don’t Take Checks: Don’t Confuse A Web Page Access And An API Call \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#no-we-don-t-take-checks-don-t-confuse-a-web-page-access-and-an-api-call\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#no-we-dont-take-checks-dont-confuse-a-web-page-access-and-an-api-call\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIf you’ve stumbled upon this article, you have probably read a lot of documentation before that. You might have encountered various patterns that seem very different from one another and may be very different from what I’ve been describing so far.\u003c/p\u003e\n\u003cp\u003eI’d like to point out that this article is about authentication for \u003cem\u003ewebsites\u003c/em\u003e. This is, I believe, the root of all confusion. First, the requests are sent by a browser, not by another server. Then, a page of a website can be accessed via the URL bar, and the website can send calls to an API via JavaScript; that’s two very different situations.\u003c/p\u003e\n\u003cp\u003eWe have detailed the technical differences between each scenario earlier in this article. But let’s recap again to better understand the most common sources of confusion.\u003c/p\u003e\n\u003ch3 id=\"using-browser-storage-session-local-and-friend-is-like-using-your-mailbox-as-a-piggy-bank\"\u003eUsing Browser Storage (Session, Local, And Friend) Is Like Using Your Mailbox As A Piggy Bank \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#using-browser-storage-session-local-and-friend-is-like-using-your-mailbox-as-a-piggy-bank\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#using-browser-storage-session-local-and-friend-is-like-using-your-mailbox-as-a-piggy-bank\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSetting your token in \u003ccode\u003elocalStorage\u003c/code\u003e is like storing money in your physical mailbox. Well, technically, it’s safe. It’s even used to temporarily store your mail. Session storage is similar; it’s just like getting your mail every day instead of letting it rot for weeks. Be nice to the postman!\u003c/p\u003e\n\u003cp\u003eBut either way, the storage is accessible to JavaScript. It’s not open like your mailbox most probably has a lock. But it’s still lying outside.\u003c/p\u003e\n\u003cp\u003eSomeone who is really mean could craft a key and go as far as discreetly stealing your mail for days. That’s what would happen to your users if someone manages to run a script injection attack in your application. They can craft a JS script that reads the \u003ccode\u003elocalStorage\u003c/code\u003e, and sends them the tokens of any of your users affected by the breach!\u003c/p\u003e\n\u003cp\u003eThere are ways to prevent cross-scripting attacks. It’s not a fatality, and some would argue that it’s still better than using an HTTP-only cookie! But if you go the web storage way, don’t forget to protect your mailbox.\u003c/p\u003e\n\u003ch3 id=\"jwts-passed-as-header-its-a-pattern-for-api-calls-only\"\u003eJWTs Passed As Header: It’s A Pattern For API Calls Only \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#jwts-passed-as-header-it-s-a-pattern-for-api-calls-only\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#jwts-passed-as-header-its-a-pattern-for-api-calls-only\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eI’d like to go one step further and understand \u003cem\u003ewhy\u003c/em\u003e so many developers are tempted to use the browser storage without even considering the cookie option.\u003c/p\u003e\n\u003cp\u003eI think there are two main reasons:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe API doesn’t use \u003ccode\u003eSet-Cookie\u003c/code\u003e during the login step. It often happens in APIs that were not specifically designed to be accessed from a browser, and they use an authentication pattern that works for servers, too (so no cookies). Your back-end developer will claim it was a “design choice.” Don’t trust them.\u003c/li\u003e\n\u003cli\u003eThe client needs to set an \u003ccode\u003eAuthorization\u003c/code\u003e header with the token. That’s just the symmetrical issue; the API chose not to rely on cookies.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eYou’ll meet a lot of documentation in the wild that shows headers like this:\u003c/p\u003e\n\u003cpre class=\"language-javascript\"\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"token maybe-class-name\"\u003eAuthorization\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token maybe-class-name\"\u003eBearer\u003c/span\u003e \u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003etoken\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSetting the \u003ccode\u003eAuthorization\u003c/code\u003e header implies you cannot use an HTTP-Only cookie. Of course, you can set the headers of a request using JavaScript. However, this means that the token must be available to JavaScript in the first place. Let’s repeat it once again: \u003cstrong\u003eit’s ok not to use a cookie and prefer web storage, but be very careful with XSS attacks!\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMoreover, this pattern works only for programmatic requests with fetch and XHR. You can’t secure access to the web page itself because the browser won’t set this header automatically during navigation. You just really can’t.\u003c/p\u003e\n\u003cp\u003eIf you need to secure web pages, the backend of your website (which may differ from your actual API that serves data) should use HTTP-only cookies, or you should set a non-HTTP-only cookie manually. Either way, be careful that by using cookies, you are introducing a new vector of attacks.\u003c/p\u003e\n\u003cp\u003eNot all websites need to be secured this way, though. It’s actually pretty uncommon for public-facing websites. Remember Blitz.js’ motto “secure data, not pages.” But the cookie way is still a pattern you must be aware of.\u003c/p\u003e\n\u003cp\u003eIf you really need to secure a web page, reach out to your backend developer and explain to them that cookies are good. They won’t contradict this claim.\u003c/p\u003e\n\u003cp\u003eIf it’s really not possible to improve the API, you might want to adopt a pattern named “backend-for-frontend” (BFF). Basically, have a tiny server owned by the front-end team that takes care of calling authenticated APIs server-side, among other things. It works pretty well with frameworks like Remix or Next.js that have built-in server-oriented features.\u003c/p\u003e\n\u003ch3 id=\"side-note-on-basic-auth-looks-like-a-header-behaves-like-a-cookie\"\u003eSide Note On Basic Auth: Looks Like A Header, Behaves Like A Cookie \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#side-note-on-basic-auth-looks-like-a-header-behaves-like-a-cookie\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#side-note-on-basic-auth-looks-like-a-header-behaves-like-a-cookie\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eOf course, every rule must have its exceptions. There is only one common scenario I know where the token can be passed as a request header without using JavaScript: using basic authentication.\u003c/p\u003e\n\u003cp\u003eBasic authentication is an unsafe pattern, as identifiers are sent alongside every request, not just a token but the actual username and password. It’s a bit like asking your local drug dealer to pay your rent and give them your ID card and 2000$ that they should kindly bring to your landlord. It’s only ok if this is a fake ID. Actually, no, fake IDs and drug dealers are not ok. But you get the point!\u003c/p\u003e\n\u003cp\u003eIt’s still interesting for a few use cases, like quickly securing the demo of a website. As long as you can accept the password to be stolen without that many consequences, typically if the password has been generated by an admin for a temporary occasion (NOT a user-set password that could be reused for multiple services!).\u003c/p\u003e\n\u003cp\u003eIn basic authentication, the browser sets the \u003ccode\u003eAuthorization\u003c/code\u003e header for you. You still need to set the \u003ccode\u003ecredentials\u003c/code\u003e option properly when using \u003ccode\u003efetch\u003c/code\u003e programmatically so that the header is also set in this case. But you don’t have to manually tweak the header. It really behaves like a cookie.\u003c/p\u003e\n\u003cp\u003eThat’s actually one reason why this fetch option is named “credentials” and not just “cookies”: it also applies to the basic authentication header.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#conclusion\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#conclusion\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eWow, if you’ve read this far, you definitely earned your right to a quick summary!\u003c/p\u003e\n\u003cp\u003eBut before that, I have another gift for you: \u003ca href=\"https://github.com/lbke/deno-auth-demo\"\u003ean open-source demo of authentication with Deno and HTMX for the front end\u003c/a\u003e!\u003c/p\u003e\n\u003cp\u003eThis is a very basic setup, but it puts the concepts described in this article into action using the “cookie way.”\u003c/p\u003e\n\u003cp\u003eHere is your well-deserved TL;DR:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eJWT is like banknotes, and sessionId is like credit cards.\u003c/strong\u003e They are two authentication patterns, but either way, you want to store those tokens safely client-side.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eOne safe place to store tokens in a browser is an HTTP-only and secure cookie, set via the \u003ccode\u003eSet-Cookie\u003c/code\u003e header of the login response.\u003c/strong\u003e It cannot be stolen by malicious JavaScript code. Web storage is another possibility if you only secure API calls and not web page access. If you pick web storage, then be very careful with XSS attacks.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCookies are automatically sent alongside every request provided you use the right options\u003c/strong\u003e, namely the \u003ccode\u003epath\u003c/code\u003e and \u003ccode\u003eSameSite\u003c/code\u003e attributes of the cookie. Like a wallet, you would carry it on you all the time and take it out of your bag only in safe places when a payment is needed.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWhen navigating via URL, the browser takes care of sending the cookie containing the auth token (if properly set).\u003c/strong\u003e But you may also need to call authenticated APIs using JavaScript code. Fetch \u003ccode\u003ecredentials\u003c/code\u003e and XHR \u003ccode\u003ewithCredentials\u003c/code\u003e options have to be configured correctly, so cookies are also sent alongside those programmatic requests. Don’t forget to set the \u003ccode\u003eAccess-Control-Allow-Credentials\u003c/code\u003e response header as well.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAuth is about politeness: the server must set the proper headers for everything to work.\u003c/strong\u003e You can’t enter a bank and yell at people to get your money.\u003c/li\u003e\n\u003cli\u003eThis is particularly true for cross-origin requests. Companies must have secure and polite discussions with their bank, which can be separate organizations or located in a distant country. That’s what CORS is for websites and APIs. Don’t forget to properly \u003cstrong\u003eset the \u003ccode\u003eAccess-Control-Allow-Origin\u003c/code\u003e and \u003ccode\u003eAccess-Control-Allow-Credentials\u003c/code\u003e headers\u003c/strong\u003e in the response.\u003c/li\u003e\n\u003cli\u003eIf you store your savings in your mailbox, put a camera on top of it, and \u003cstrong\u003eif you store your token in the web storage, protect it against XSS attacks\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eBanks don’t treat people like they treat other banks. \u003cstrong\u003eDon’t confuse webpages patterns\u003c/strong\u003e (have to rely on cookies and browser’s built-in features) \u003cstrong\u003eand API patterns\u003c/strong\u003e (relying on headers, which can be implemented using client-side JavaScript).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eBasic auth is a fun pattern that blurs the line, as it uses an Authorization header like for APIs, but it can be used for webpages too.\u003c/strong\u003e It’s a specific and very insecure pattern that is only meant for a handful of limited use cases. Basic auth headers are a reason why \u003ccode\u003efetch\u003c/code\u003e and \u003ccode\u003eXHR\u003c/code\u003e options are named “credentials” and not just “cookies.”\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"resources\"\u003eResources \u003ca href=\"https://www.smashingmagazine.com/2023/01/authentication-websites-banking-analogy/#resources\"\u003e#\u003c/a\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#resources\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eSending programmatic requests with fetch (as opposed to accessing a URL or submitting an HTML form and letting the browser send the request):\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\"\u003eUsing the Fetch API\u003c/a\u003e, Mozilla docs\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/fetch\"\u003efetch()\u003c/a\u003e, Mozilla docs\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://jwt.io/introduction\"\u003eIntro to JWT token.\u003c/a\u003e\u003cbr\u003e\nYou’ll notice the ambiguity: it states that JWT should not be stored in browser storage, yet they should usually be passed via header… which implies storing the token in browser storage. But that’s not the only choice. HTTP-only cookies can be used too, and which is the best is an open debate.\u003c/li\u003e\n\u003cli\u003e“\u003ca href=\"https://portswigger.net/research/web-storage-the-lesser-evil-for-session-tokens\"\u003eWeb Storage: the lesser evil for session tokens\u003c/a\u003e”, James Kettle\u003cbr\u003e\nHTTP-only cookies are debated: an article in favor of the web storage.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dl.acm.org/doi/pdf/10.1145/3106237.3121282\"\u003eReflections on the REST architectural style and “principled design of the modern web architecture” (impact paper award)\u003c/a\u003e, Fielding, R. T., Taylor, R. N., Erenkrantz, J. R., Gorlick, M. M., Whitehead, J., Khare, R., \u0026#x26; Oreizy, P. (2017, August). In Proceedings of the 2017 11th joint meeting on foundations of software engineering (pp. 4-14).\u003cbr\u003e\nThis paper from Fielding et al. states that the use case of session management has been overlooked in the past when defining the REST architectural style, leading to confusion and poor technological solutions\u003c/li\u003e\n\u003cli\u003eYou’ll find many great tutorials in the wild. A quick search for “authentication” on Smashing Magazine will confirm that there are already two great pieces just for Next.js:\n\u003cul\u003e\n\u003cli\u003e“\u003ca href=\"https://www.smashingmagazine.com/2022/04/dynamic-data-fetching-authenticated-nextjs-app/\"\u003eDynamic Data-Fetching In An Authenticated Next.js App\u003c/a\u003e”, Caleb Olojo (Self-hosted authentication)\u003c/li\u003e\n\u003cli\u003e“\u003ca href=\"https://www.smashingmagazine.com/2021/05/implement-authentication-nextjs-auth0/\"\u003eHow To Implement Authentication In Next.js With Auth0\u003c/a\u003e”, Facundo Giuliani\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.rfc-editor.org/rfc/rfc7519\"\u003eStandard RFC for JWT\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e“\u003ca href=\"https://www.smashingmagazine.com/2016/06/the-current-state-of-authentication-we-have-a-password-problem/\"\u003eThe Current State Of Authentication: We Have A Password Problem\u003c/a\u003e”, Drew Thomas\u003cbr\u003e\nThere are other ways to authenticate the user than passwords. Most of the content of my article should, however, still hold even with other approaches (magic link, OpenID Connect…).\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/fr/docs/Web/HTTP/Methods/OPTIONS\"\u003eThe OPTIONS HTTP verb used by the CORS preflight request\u003c/a\u003e (triggered on non-simple requests like calling a JSON API with fetch)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://jub0bs.com/posts/2022-02-08-cve-2022-21703-writeup/#bypassing-content-type-validation-and-avoiding-cors-preflight\"\u003eBreaking CORS preflight request to bypass CORS\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e“\u003ca href=\"https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties\"\u003eExploiting CORS misconfigurations for Bitcoins and bounties\u003c/a\u003e”, James Kettle\u003cbr\u003e\nWhy the scheme (HTTP or HTTPS) matters with CORS; \u003ca href=\"https://twitter.com/jub0bs/status/1352160391032401923/photo/1\"\u003esome exploit examples\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#credentialed_requests_and_wildcards\"\u003eThe Wildcard exception\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://fetch.spec.whatwg.org/#concept-request-client\"\u003eFetch standard definition of a “client”\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/10636611/how-does-access-control-allow-origin-header-work\"\u003eExcellent explanation on Access-Control-Allow-Origin, the header that controls CORS\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\"\u003eAbout CORS, and definition of “simple requests”\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/a/48231372/5513532\"\u003eXHR withCredentials in Axios\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://portswigger.net/web-security/csrf\"\u003eCSRF\u003c/a\u003e\u003cbr\u003e\nA type of attack to bypass cross-origin restriction (not covered in this article, great read to go further, especially if you go “the cookie way” for API authentication)\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#local-storage\"\u003eLimits of storing tokens in browser storage\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://portswigger.net/web-security/csrf/samesite-cookies\"\u003eSameSite\u003c/a\u003e\u003cbr\u003e\nConfigure the cookies to be sent or not when coming from another site\u003c/li\u003e\n\u003cli\u003eAbout \u003ca href=\"https://web.dev/i18n/en/samesite-cookies-explained/\"\u003ethe SameSite attribute for cookies\u003c/a\u003e, from web.dev\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.honeybadger.io/blog/subdomain-takeover/\"\u003eSubdomain takeover\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/67689503/what-is-top-level-navigation-in-browser-terminology-and-in-what-ways-it-can-be-t\"\u003eWhat is a “top-level navigation” in the browser\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e“\u003ca href=\"https://web.dev/fetch-metadata/\"\u003eProtect your resources from web attacks with Fetch Metadata\u003c/a\u003e”, Lukas Weichselbaum\u003cbr\u003e\nAnother brilliant piece from web.dev about Sec-Fetch headers.\u003c/li\u003e\n\u003cli\u003eThe canonical \u003ca href=\"https://samnewman.io/patterns/architectural/bff/\"\u003edefinition of Backend For Front-end\u003c/a\u003e.\u003cbr\u003e\nIt’s similar to using a centralized API gateway for the front end, except that BFF is decentralized.\u003c/li\u003e\n\u003cli\u003e“\u003ca href=\"https://httptoolkit.tech/blog/cache-your-cors/\"\u003eCache your CORS, for performance \u0026#x26; profit\u003c/a\u003e”, Tim Perry\u003cbr\u003e\nHow to cache preflight requests to reduce your API workload (non-standard at the moment but extremely useful at scale).\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/58173809/next-js-redirect-from-to-another-page\"\u003eRedirecting in Next.js\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1766965759366,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"a724de3efd251cf89fe82a5860d9008b","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":43,"column":5,"offset":2710},"end":{"line":43,"column":29,"offset":2734},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2026.articles","alias":"What I read in 2026","position":{"start":{"line":72,"column":3,"offset":4440},"end":{"line":72,"column":45,"offset":4482},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2026.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2025.articles","alias":"2025","position":{"start":{"line":73,"column":5,"offset":4487},"end":{"line":73,"column":32,"offset":4514},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2025.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2024.articles","alias":"2024","position":{"start":{"line":74,"column":5,"offset":4519},"end":{"line":74,"column":32,"offset":4546},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2024.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2023.articles","alias":"2023","position":{"start":{"line":75,"column":5,"offset":4551},"end":{"line":75,"column":32,"offset":4578},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2023.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2022.articles","alias":"2022","position":{"start":{"line":76,"column":5,"offset":4583},"end":{"line":76,"column":32,"offset":4610},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2022.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":82,"column":3,"offset":4746},"end":{"line":82,"column":39,"offset":4782},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":76,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","o7xruzrah5wzqetottecss7","z1zo2mp6ddji5p317i4x9xw","v06c2tjelh341x4resa50fh","0yqesk4rcffwgyuab5x8rfa","sy2vkbtyu671chkvgn1yt8j","ufixpmxoydiccoh59kphrib","alswadkx4wb05y1z9iwfzfv","1daut9dpw70xd0zh5a7j5p4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 현실은 인간의 연산으로 완전히 파악할 수 없는 복잡계. 주어진 상황과 능력으로 할 수 있는 최선의 적응은 단순함과 꾸준함.\n\n  - 파산을 면하는 선에서 여러가지를 해보고 자신에게 맞는 걸 위주로 꾸준히. 그를 위해 단순, 편안, 쾌적함이 필요.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2026|read.2026.articles]]\n  - [[2025|read.2025.articles]]\n  - [[2024|read.2024.articles]]\n  - [[2023|read.2023.articles]]\n  - [[2022|read.2022.articles]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"515c59eesgg7k7pwwfiu2tx"},"buildId":"wirstT2ztC8OQsbzKjhvw","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>