<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>I&#x27;m All-In on Server-Side SQLite</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="I&#x27;m All-In on Server-Side SQLite"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/51vp6g9mkchaqv0h92xmvs7/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="7/17/2024"/><meta property="article:modified_time" content="7/17/2024"/><link rel="canonical" href="https://luke-snaw.github.io//notes/51vp6g9mkchaqv0h92xmvs7/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_buildManifest.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="im-all-in-on-server-side-sqlite">I'm All-In on Server-Side SQLite<a aria-hidden="true" class="anchor-heading icon-link" href="#im-all-in-on-server-side-sqlite"></a></h1>
<blockquote>
<p><a href="https://fly.io/blog/all-in-on-sqlite-litestream/">https://fly.io/blog/all-in-on-sqlite-litestream/</a></p>
</blockquote>
<h2 id="summary-of-kagi">Summary of Kagi<a aria-hidden="true" class="anchor-heading icon-link" href="#summary-of-kagi"></a></h2>
<p>SQLite is a powerful embedded database that can serve as the core data and persistence layer for many production applications, rather than just for unit testing.</p>
<p>Modern hardware advancements have made the scaling limitations of SQLite less relevant for most applications, which often don't require handling terabytes of data.</p>
<p>SQLite's simplicity and performance advantages make it an attractive option, as database optimization is becoming less crucial for typical applications.</p>
<p>Litestream is an open-source project that enables reliable replication and distribution of SQLite databases, addressing common concerns around resilience and concurrency.</p>
<p>Litestream allows SQLite databases to be easily replicated to cloud storage or between database instances, providing resilience and scalability.</p>
<p>Embedding the database directly in the application process can dramatically reduce latency compared to client-server database architectures.</p>
<p>The reduced latency and simplified architecture of SQLite with Litestream can improve developer productivity and the user experience of applications.</p>
<p>While Litestream has some limitations, the author is committed to continually improving it to make SQLite a viable option for more full-stack applications.</p>
<p>The author advocates for reconsidering the conventional wisdom that relegates SQLite to only being used for unit tests, and argues it can serve as the core data layer for many production applications.</p>
<p>The document showcases the author's expertise in databases and their passion for making SQLite a more robust and practical option for modern application development.</p>
<h2 id="summary-of-perplexity">Summary of Perplexity<a aria-hidden="true" class="anchor-heading icon-link" href="#summary-of-perplexity"></a></h2>
<p>This article discusses the potential of using SQLite as the primary database for full-stack applications, challenging the conventional n-tier architecture wisdom. The author, Ben Johnson, argues that SQLite, combined with Litestream (an open-source replication tool), can be a viable and efficient alternative to traditional client-server databases like PostgreSQL for many applications[1].</p>
<p>Key points include:</p>
<ol>
<li>SQLite's advantages: Simplicity, performance, and reliability.</li>
<li>Litestream: A tool that adds replication capabilities to SQLite, addressing concerns about resilience and scalability[1].</li>
<li>Operational simplicity: SQLite with Litestream requires less configuration and management compared to traditional databases.</li>
<li>Latency benefits: SQLite's embedded nature allows for significantly lower query latency compared to client-server databases[1].</li>
<li>Scalability: Litestream enables live replication and distributed read replicas, allowing for global scalability of read-heavy applications[1].</li>
</ol>
<p>The author argues that while SQLite may not be suitable for all use cases, it should be considered more seriously for many full-stack applications due to its simplicity, performance, and the added reliability provided by Litestream[1].</p>
<p>Citations:
[1] <a href="https://fly.io/blog/all-in-on-sqlite-litestream/">https://fly.io/blog/all-in-on-sqlite-litestream/</a></p>
<h2 id="geeknews">GeekNews<a aria-hidden="true" class="anchor-heading icon-link" href="#geeknews"></a></h2>
<blockquote>
<p><a href="https://news.hada.io/topic?id=6557">https://news.hada.io/topic?id=6557</a></p>
</blockquote>
<ul>
<li>BoltDB(임베디드 키밸류 DB)를 만든 벤 존슨이 이제 FlyIO에서 Litestream 개발중</li>
<li>풀스택 어플리케이션의 상식적인 구조는 n-Tier : 앱서버 + DB서버<br>
→ 이 아키텍처에서 SQLite는 유닛테스트용으로만 사용했지만, 이제는 데이터 및 지속 레이어로 충분히 사용 가능</li>
<li>Litestream 은 Replication을 통해서 SQLite를 풀스택 어플리케이션에 사용가능하게 만들어주는 오픈소스</li>
</ul>
<h2 id="어플리케이션-데이터베이스의-간략한-역사">어플리케이션 데이터베이스의 간략한 역사<a aria-hidden="true" class="anchor-heading icon-link" href="#어플리케이션-데이터베이스의-간략한-역사"></a></h2>
<ul>
<li>50년이 긴 시간이 아니지만, 소프트웨어가 데이터를 관리하는 방법은 엄청난 변화가 있었음<br>
→ 70년대에는 관계형 데이터베이스라는 것을 정의한 "Codd의 법칙" 이 있었음<br>
→ 모든 데이터는 테이블에 있고, CRUD, 스키마, SQL 언어 등<br>
→ 80년대와 90년대에는 Oracle/DB2/Postgres/MySQL등 SQL 데이터베이스가 폭발적으로 많아짐<br>
→ 2000년대의 XML 데이터베이스는 안 좋았고, 같은 시간대에 훌륭한 컬럼 DB들이 등장<br>
→ 2010년대에는 대규모 오픈소스 분산 DB 프로젝트들이 출시되고, 이제는 누구나 클러스터를 만들고 테라바이트 단위의 데이터를 쿼리 가능</li>
<li>데이터베이스가 진화하면서, DB를 어플리케이션에 연결하는 전략도 발전<br>
→ Codd 이후로 티어로 분리<br>
→ 가장 처음엔 데이터베이스 티어<br>
→ 그다음엔 memcached 와 Redis의 캐슁 티어<br>
→ 백그라운드 잡 티어(Sidekiq), 라우팅 티어(PgBouncer), Distribution 티어 등<br>
→ 많은 튜토리얼이 3-Tier 인 것 처럼 얘기하지만, 얼마나 많은 티어들이 들어올지 모르니 "n-Tier"라고 부르고 있음</li>
<li>50년의 시간동안 CPU,메모리,디스크가 수백배 빠르고 저렴해지는 것도 보았음<br>
→ 2010년대 데이터베이스 혁신을 실제 정의하는 단어는 "빅데이터"임<br>
→ 하지만 하드웨어 개선으로 2020년에 와서는 그 컨셉도 유지하기 어려워졌음<br>
→ 1996년에 1GB DB 관리는 정말 큰 일이었지만, 2022년엔 노트북이나 t3.micro에서도 운영해도 충분</li>
<li>우리가 새로운 DB 아키텍처에 대해 생각할 때, 확장성 제한때문에 최면이 걸림<br>
→ 페타바이트 또는 최소 테라바이트 단위를 데이터를 처리하지 못하면 대화에 끼지도 못함<br>
→ 하지만 대부분의 어플리케이션은 성공하더라도 테라바이트의 데이터를 보기 어려움<br>
→ 우린 못을 박기 위해 착암기(JackHammer)를 쓰고 있는 것</li>
</ul>
<h2 id="sqlite의-달콤한-릴리즈">SQLite의 달콤한 릴리즈<a aria-hidden="true" class="anchor-heading icon-link" href="#sqlite의-달콤한-릴리즈"></a></h2>
<ul>
<li>이런 경향을 잘 반영하는 데이터베이스가 있음</li>
<li>세계에서 가장 유명한 SQL DB중 하나이고, 미국 의회 도서관의 공식 보관 형식이며, 신뢰성과 가늠하기 어려운 크기의 테스트 스위트로 유명하고, 성능도 너무 훌륭</li>
<li>이 정도면 이름을 말할 필요도 없겠지만.. 뒤에서 손들고 있는 분을 위해.. 이건 바로 <strong>SQLite</strong> 이야기임</li>
<li>SQLite는 임베디드 DB임. 일반적인 아키텍처 티어에선 존재하지 않는, 당신의 어플리케이션 서버 프로세스에 링크되는 그냥 라이브러리 임<br>
→ 다른 서버에 의존하지 않고 혼자 실행 되는 "싱글 프로세스 어플리케이션"</li>
<li>내가 DB를 만드는 사람이기 때문에 이런 종류의 어플리케이션에 관심을 가짐</li>
<li>나는 Go 에코시스템에서 유명한 임베디드 Key/Value DB인 BoltDB를 만들었음</li>
<li>BoltDB는 안정적이고, 인프로세스 DB에서 기대하는 것처럼 Nitro가 달린 장난감 자동차 같은 성능을 보여줌</li>
<li>하지만, BoltDB는 제한점이 있음<br>
→ 스키마가 Go코드로 정의되기 때문에 DB 마이그레이션이 어려움. 직접 당신이 도구를 만들어야 함. 심지어 REPL도 없음</li>
<li>당신이 조심만 한다면, 이런 종류의 DB를 쓰면 엄청난 성능을 얻을 수 있음</li>
<li>하지만 일반적인 용도로는 이런 DB를 운영하기 원하지 않을 것</li>
<li>나는 BoltDB를 더 많은 어플리케이션에서 사용가능하게 만들기 위해 뭘 해야할지를 고민했는데, 내가 도달한 결론은 "SQLite가 딱 그것을 위해 만들어졌다는 것"</li>
<li>SQLite에도 물론 제약이 있음. 가장 큰것은 단일 프로세스 어플리케이션은 SPOF(Single Point of Failure)가 있다는 것: 서버를 잃어버리면 데이터베이스도 잃어버림. 이것은 SQLite의 결함이 아니라 디자인이 원래 그렇게 된 것</li>
</ul>
<h2 id="enter-litestream">Enter Litestream<a aria-hidden="true" class="anchor-heading icon-link" href="#enter-litestream"></a></h2>
<ul>
<li>많은 사람들이 SQLite를 기본으로 사용하지 않는 두가지 큰 이유는<br>
→ 첫째 스토리지 오류에 대한 복원력(Resilience)<br>
→ 둘째 규모가 클 때의 동시성(Concurrency)</li>
<li>Litestream이 이 두가지 문제에 대해서 할 말이 있음</li>
<li>Litestream은 SQLite 의 WAL(Write Ahead Log) 모드 저널링을 제어함으로써 동작</li>
<li>WAL모드에서는 쓰기 오퍼레이션들이 SQLite의 메인 DB 파일외의 별도 로그파일에 추가됨</li>
<li>Reader들은 쿼리를 충족시키기 위해 WAL 파일과 메인DB를 모두 확인함</li>
<li>일반적으로 SQLite는 자동으로 WAL에서 메인 DB로 페이지를 자동 체크포인트를 실행함</li>
<li>Litestream은 이 중단단계에서 끼어들어 자동 체크포인트를 방지하는 무한 읽기 트랜잭션을 오픈하고, WAL업데이트를 직접 캡쳐하고 복제하고, 스스로 체크포인트를 트리거함
<blockquote>
<p>Litestream에 이해해야 하는 가장 중요한 것은 그냥 SQLite라는 것. 애플리케이션은 표준 SQLite를 사용하며, 종속성을 추가하거나 쿼리를 분석하거나 프록시 동작을 하는게 아님. 그냥 SQLite가 가진 저널링 및 동시성 기능을 활용하는 것. 대부분의 경우 당신의 코드는 Litestream의 존재를 인식하지 못할 수도 있음</p>
</blockquote>
</li>
<li>복잡해 보이지만, 실제로는 엄청 간단함. 써보면 그냥 "just works"라는 걸 알수 있음
<pre class="language-shell"><code class="language-shell">$ litestream replicate fruits.db <span class="token punctuation">[</span>s3://my-bukkit:9000/fruits.db<span class="token punctuation">]</span><span class="token punctuation">(</span>https://s3//my-bukkit:9000/fruits.db<span class="token punctuation">)</span>
$ litestream restore -o fruits-replica.db <span class="token punctuation">[</span>s3://my-bukkit:9000/fruits.db<span class="token punctuation">]</span><span class="token punctuation">(</span>https://s3//my-bukkit:9000/fruits.db<span class="token punctuation">)</span>
</code></pre>
</li>
<li>일반적으로 사람들은 SQLite DB를 복제해서 S3에 저장하는 용도로 사용</li>
<li>운영상 큰 이점을 줌. 당신의 DB는 탄력적이고 쉽게 옮기거나 마이그레이션 가능해짐</li>
<li>하지만 Litestream으로 더 많은 것들을 할 수 있음.</li>
<li>다음 버전에서는 SQLite DB간에 실시간 복제가 가능해져서, 분산 Read Replica 와 Write-Leader DB를 셋업하는게 가능해 짐<br>
→ Read Replica는 Write를 캐치해서 Leader에게 Redirect 가능<br>
→ 많은 어플리케이션들은 Read-heavy니까 이 셋업은 어플리케이션에게 글로벌하게 스케일 가능한 DB를 제공할수 있게 되는 것</li>
</ul>
<h2 id="당신은-이-옵션어플리케이션-db로-sqlite를-사용하는-것을-더-심각하게-받아들여야-함">당신은 이 옵션(어플리케이션 DB로 SQLite를 사용하는 것)을 더 심각하게 받아들여야 함<a aria-hidden="true" class="anchor-heading icon-link" href="#당신은-이-옵션어플리케이션-db로-sqlite를-사용하는-것을-더-심각하게-받아들여야-함"></a></h2>
<ul>
<li>나의 초창기 IT 직업중 하나는 2000년대 초 오라클DBA 였음</li>
<li>나는 오라클에 대해서 배우기 위해 수많은 책과 문서들을 읽는데 시간을 보냈음</li>
<li>관리자 매뉴얼은 거의 천페이지 가량이었고, 그건 수백개의 문서중 하나였음</li>
<li>쿼리를 최적화 하거나 쓰기를 개선하기 위해 뭘 해야 하는 지를 배우면 그 당시에는 큰 차이를 만들어냈음</li>
<li>초당 수십메가를 읽는 하드디스크가 있으므로, 더 나은 인덱스를 활용하면 5분 걸리는 쿼리를 30초 짜리 쿼리로 바꿔줄수 있음</li>
<li>하지만 DB최적화는 점점 일반 어플리케이션엔 중요하지 않아짐</li>
<li>1GB DB를 가지고 있다면 NVMe디스크는 1초 이내에 모든 것을 메모리에 담을 수 있음</li>
<li>SQL 쿼리 최적화를 좋아하지만, 많은 어플리케이션 개발자들에게 이건 죽어가는 기술이 되고 있음</li>
<li>제대로 튜닝되지 않은 쿼리라도 많은 데이터베이스에서 1초이내에 실행 가능</li>
<li>최신 Postgres는 기적임. 수년간 그 코드를 읽으면서 많은 것들을 배웠음</li>
<li>쿼리 옵티마이저, 행단위 보안 정책, 6가지 유형의 인덱스 등</li>
<li>이런 기능을 원한다면 필요하겠지만, 대부분은 그렇지 않음</li>
<li>그리고 만약 이런 Postgres 기능을 원하지 않는다면, 책임이 뒤따름</li>
<li>여러개의 계정을 사용하지 않더라고 호스 기반 인증을 구성해야 하고, 방화벽을 해제해야함</li>
<li>더 많은 기능은 더 많은 문서를 의미하므로 실제로 당신이 운영중인 소프트웨어에 대해 알기 어려움</li>
<li>Postgre14 의 문서는 거의 3천페이지임</li>
<li>SQLite는 Postgres 기능의 서브셋을 가짐. 하지만 내가 일반적으로 원하는 기능의 99.9% 임</li>
<li>뛰어난 SQL 지원, 윈도우 기능, CTE, 전문 검색, JSON 지원 등</li>
<li>기능이 부족하자면 데이터가 내 애플리케이션 옆에 있으므로 가져와서 처리하기에 오버헤드가 별로 없음</li>
<li>한편 정말 해결해야 하는 복잡한 문제는 핵심 데이터베이스 기능으로는 해결되지 않음</li>
<li>대신 레이턴시와 개발자 경험 두가지만 최적화 하고 싶음</li>
<li>따라서, SQLite를 진지하게 고려해야 하는 한가지 이유는 운영이 정말 간단하기 때문</li>
<li>데이터베이스 계층을 설계하지 않고 그냥 어플리케이션 코드 작성에 시간을 쓰는 것이 가능</li>
<li>하지만 다른 문제가 있음</li>
</ul>
<h2 id="빛은-너무-느리다--the-light-is-too-damn-slow">빛은 너무 느리다 : The Light is Too Damn Slow<a aria-hidden="true" class="anchor-heading icon-link" href="#빛은-너무-느리다--the-light-is-too-damn-slow"></a></h2>
<ul>
<li>이론적인 한계에 부딪히기 시작. 진공상태에서 빛은 1밀리초에 186마일을 이동(필라델피아에서 뉴욕까지 왕복 거리)</li>
<li>네트워크 스위치, 방화벽 및 애플리케이션 프로토콜 레이어를 추가하면 더 느려짐</li>
<li>단일 AWS 리젼내에서 Postgres 쿼리에 대한 레이턴시 오버헤드는 최대 1밀리초 이내</li>
<li>이것은 Postgres가 느리다는 것이 아니라 데이터 이동 속도의 한계에 도달한 것</li>
<li>최신 어플리케이션은 HTTP 요청을 처리하며, 여러개의 데이터베이스 쿼리와 비즈니스 로직 또는 렌더링 하기 전에 이미 10ms를 소모함</li>
<li>애플리케이션 레이턴시에는 매직 넘버가 있음 : 100ms 이하의 응답은 거의 즉시처럼 느껴 진다는 것</li>
<li>즉시 응답하는(Snappy) 어플리케이션은 행복한 사용자를 만듦</li>
<li>100ms는 많은 것 같지만 무심코 먹어버리기 쉬움</li>
<li>100ms 임계값은 매우 중요하기 때문에 사람들은 레이턴시를 줄이기 위해 페이지를 프리렌더링하고 CDN에 태움</li>
<li>우린 데이터를 어플리케이션 가까이로 옮기는게 좋음. 얼마나? 정말 가깝게</li>
<li>SQLite는 당신의 어플리케이션과 같은 머신에 있는 것만이 아니라, 당신의 어플리케이션 프로세스 안에 포함됨</li>
<li>데이터를 어플리케이션 옆에 두면 쿼리당 레이턴시가 10~20 마이크로세컨드(μ)로 떨어지는 것을 볼수 있음</li>
<li>즉 동일 리젼내의 Postgres 쿼리보다 50~100x 빠름</li>
<li>하지만, 더 많은 것이 있음. 쿼리당 지연시간을 효율적으로 제거했음. 우리 어플리케이션이 빠르면서도 더 간단함</li>
<li>큰 쿼리들을 더 작은 관리 가능한 쿼리로 분할할 수 있고, 새로운 기능을 구축하기 위해 N+1 쿼리 패턴을 찾는데 시간을 더 할애할 수 있음</li>
<li>레이턴시를 최소화 하는 것은 프로덕션만을 위한 것은 아님. 기존 클라이언트/서버 DB와 연통 테스트를 하는 것은 로컬에서 몇분씩 걸릴 정도로 곧 잘 늘어나며, CI로 푸시해도 고통은 계속 됨</li>
<li>코드 변경에서 테스트 완료까지의 피드백 루프를 줄이면 시간이 절약되고 개발하는 동안 포커스를 유지할 수 있음</li>
<li>SQLite에서 한 줄 변경하는 것은 메모리에서 실행해서 통합 테스트를 몇 초 이내에 실행 가능</li>
</ul>
<h2 id="작고-빠르고-신뢰할수-있고-글로벌-분산되어-있고--이-중에서-4개를-선택하세요">작고, 빠르고, 신뢰할수 있고, 글로벌 분산되어 있고 : 이 중에서 4개를 선택하세요<a aria-hidden="true" class="anchor-heading icon-link" href="#작고-빠르고-신뢰할수-있고-글로벌-분산되어-있고--이-중에서-4개를-선택하세요"></a></h2>
<ul>
<li>Litestream 은 분산 되어있고, 복제되며, 가장 중요한 것은 <strong>이해하기 쉬움</strong></li>
<li>진지하게, "한번 시도해 보세요" 알아야할 것이 별로 없습니다</li>
<li>내 주장은 이겁니다 :
<ul>
<li>SQLite를 위한 안정적이고 사용하기 쉬운 복제를 구축하면, SQLite에서만 운영되는 풀스택 어플리케이션을 매력적으로 만든다는 것</li>
<li>예전 "Rails로 Blog로 만들기 튜토리얼"이 작성되었던 시절엔 이 옵션을 간과했지만, 요즘의 SQLite는 대부분의 어플리케이션 쓰기 부하를 견딜수 있으며, 복제본을 통해서 수많은 인스턴스에서 읽어갈수 있도록 로드밸런싱이 가능</li>
</ul>
</li>
<li>Litestream에도 제약이 있음
<ul>
<li>싱글 노드 어플리케이션을 위해 만들었기 때문에, 서버리스 플랫폼이나 롤링 배포에는 잘 동작하지 않음</li>
<li>모든 변경사항을 순차적으로 복원해야 하므로 DB 리스토어에 몇분가량 걸릴수 있음</li>
<li>우리는 실시간 복제 기능을 준비하고 있지만, 별도 프로세스 모델은 복제 보장에 대한 세부제어 부분에서 제약이 있음</li>
</ul>
</li>
<li>더 잘할 수 있음
<ul>
<li>지난 1년간 내가 해온 일은 Litestream의 핵심을 정하고 정확성에 초점을 맞추는 것</li>
<li>현재 도착한 위치에 만족함</li>
<li>단순한 스트리밍 백업 도구로 시작했지만, 점차 안정적이고 분산된 데이터베이스로 발전 중</li>
<li>나의 Fly.io에서의 일은 이걸 더 빠르고 심리스하게 만드는 것</li>
<li>Fly.io 와 상관없이 Litestream에 더 많은 개선들이 추가 될 것</li>
</ul>
</li>
<li>Litestream 은 Fly.io에서 새 집을 꾸렸지만, 계속 오픈소스 프로젝트 일 것</li>
<li>차후 몇년간 내 계획은 어플리케이션이 어디서 실행되는 지와 상관없이, 더 유용하게 만들고, SQLite 모델이 어디까지 나아갈수 있을지 확인하는 것</li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#summary-of-kagi" title="Summary of Kagi">Summary of Kagi</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#summary-of-perplexity" title="Summary of Perplexity">Summary of Perplexity</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#geeknews" title="GeekNews">GeekNews</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#어플리케이션-데이터베이스의-간략한-역사" title="어플리케이션 데이터베이스의 간략한 역사">어플리케이션 데이터베이스의 간략한 역사</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#sqlite의-달콤한-릴리즈" title="SQLite의 달콤한 릴리즈">SQLite의 달콤한 릴리즈</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#enter-litestream" title="Enter Litestream">Enter Litestream</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#당신은-이-옵션어플리케이션-db로-sqlite를-사용하는-것을-더-심각하게-받아들여야-함" title="당신은 이 옵션(어플리케이션 DB로 SQLite를 사용하는 것)을 더 심각하게 받아들여야 함">당신은 이 옵션(어플리케이션 DB로 SQLite를 사용하는 것)을 더 심각하게 받아들여야 함</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#빛은-너무-느리다--the-light-is-too-damn-slow" title="빛은 너무 느리다 : The Light is Too Damn Slow">빛은 너무 느리다 : The Light is Too Damn Slow</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#작고-빠르고-신뢰할수-있고-글로벌-분산되어-있고--이-중에서-4개를-선택하세요" title="작고, 빠르고, 신뢰할수 있고, 글로벌 분산되어 있고 : 이 중에서 4개를 선택하세요">작고, 빠르고, 신뢰할수 있고, 글로벌 분산되어 있고 : 이 중에서 4개를 선택하세요</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"51vp6g9mkchaqv0h92xmvs7","title":"I'm All-In on Server-Side SQLite","desc":"","updated":1721259637937,"created":1721259343020,"custom":{},"fname":"dev.DB.sqlite.all-in-on-sqlite-litestream","type":"note","vault":{"fsPath":"vault"},"contentHash":"44ed3febce2f6d694aebea7180b1185c","links":[],"anchors":{"summary-of-kagi":{"type":"header","text":"Summary of Kagi","value":"summary-of-kagi","line":10,"column":0,"depth":2},"summary-of-perplexity":{"type":"header","text":"Summary of Perplexity","value":"summary-of-perplexity","line":32,"column":0,"depth":2},"geeknews":{"type":"header","text":"GeekNews","value":"geeknews","line":49,"column":0,"depth":2},"어플리케이션-데이터베이스의-간략한-역사":{"type":"header","text":"어플리케이션 데이터베이스의 간략한 역사","value":"어플리케이션-데이터베이스의-간략한-역사","line":58,"column":0,"depth":2},"sqlite의-달콤한-릴리즈":{"type":"header","text":"SQLite의 달콤한 릴리즈","value":"sqlite의-달콤한-릴리즈","line":81,"column":0,"depth":2},"enter-litestream":{"type":"header","text":"Enter Litestream","value":"enter-litestream","line":98,"column":0,"depth":2},"당신은-이-옵션어플리케이션-db로-sqlite를-사용하는-것을-더-심각하게-받아들여야-함":{"type":"header","text":"당신은 이 옵션(어플리케이션 DB로 SQLite를 사용하는 것)을 더 심각하게 받아들여야 함","value":"당신은-이-옵션어플리케이션-db로-sqlite를-사용하는-것을-더-심각하게-받아들여야-함","line":122,"column":0,"depth":2},"빛은-너무-느리다--the-light-is-too-damn-slow":{"type":"header","text":"빛은 너무 느리다 : The Light is Too Damn Slow","value":"빛은-너무-느리다--the-light-is-too-damn-slow","line":149,"column":0,"depth":2},"작고-빠르고-신뢰할수-있고-글로벌-분산되어-있고--이-중에서-4개를-선택하세요":{"type":"header","text":"작고, 빠르고, 신뢰할수 있고, 글로벌 분산되어 있고 : 이 중에서 4개를 선택하세요","value":"작고-빠르고-신뢰할수-있고-글로벌-분산되어-있고--이-중에서-4개를-선택하세요","line":170,"column":0,"depth":2}},"children":[],"parent":"droc7w967f365b24yxuvm1y","data":{}},"body":"\u003ch1 id=\"im-all-in-on-server-side-sqlite\"\u003eI'm All-In on Server-Side SQLite\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#im-all-in-on-server-side-sqlite\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://fly.io/blog/all-in-on-sqlite-litestream/\"\u003ehttps://fly.io/blog/all-in-on-sqlite-litestream/\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"summary-of-kagi\"\u003eSummary of Kagi\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#summary-of-kagi\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSQLite is a powerful embedded database that can serve as the core data and persistence layer for many production applications, rather than just for unit testing.\u003c/p\u003e\n\u003cp\u003eModern hardware advancements have made the scaling limitations of SQLite less relevant for most applications, which often don't require handling terabytes of data.\u003c/p\u003e\n\u003cp\u003eSQLite's simplicity and performance advantages make it an attractive option, as database optimization is becoming less crucial for typical applications.\u003c/p\u003e\n\u003cp\u003eLitestream is an open-source project that enables reliable replication and distribution of SQLite databases, addressing common concerns around resilience and concurrency.\u003c/p\u003e\n\u003cp\u003eLitestream allows SQLite databases to be easily replicated to cloud storage or between database instances, providing resilience and scalability.\u003c/p\u003e\n\u003cp\u003eEmbedding the database directly in the application process can dramatically reduce latency compared to client-server database architectures.\u003c/p\u003e\n\u003cp\u003eThe reduced latency and simplified architecture of SQLite with Litestream can improve developer productivity and the user experience of applications.\u003c/p\u003e\n\u003cp\u003eWhile Litestream has some limitations, the author is committed to continually improving it to make SQLite a viable option for more full-stack applications.\u003c/p\u003e\n\u003cp\u003eThe author advocates for reconsidering the conventional wisdom that relegates SQLite to only being used for unit tests, and argues it can serve as the core data layer for many production applications.\u003c/p\u003e\n\u003cp\u003eThe document showcases the author's expertise in databases and their passion for making SQLite a more robust and practical option for modern application development.\u003c/p\u003e\n\u003ch2 id=\"summary-of-perplexity\"\u003eSummary of Perplexity\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#summary-of-perplexity\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThis article discusses the potential of using SQLite as the primary database for full-stack applications, challenging the conventional n-tier architecture wisdom. The author, Ben Johnson, argues that SQLite, combined with Litestream (an open-source replication tool), can be a viable and efficient alternative to traditional client-server databases like PostgreSQL for many applications[1].\u003c/p\u003e\n\u003cp\u003eKey points include:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSQLite's advantages: Simplicity, performance, and reliability.\u003c/li\u003e\n\u003cli\u003eLitestream: A tool that adds replication capabilities to SQLite, addressing concerns about resilience and scalability[1].\u003c/li\u003e\n\u003cli\u003eOperational simplicity: SQLite with Litestream requires less configuration and management compared to traditional databases.\u003c/li\u003e\n\u003cli\u003eLatency benefits: SQLite's embedded nature allows for significantly lower query latency compared to client-server databases[1].\u003c/li\u003e\n\u003cli\u003eScalability: Litestream enables live replication and distributed read replicas, allowing for global scalability of read-heavy applications[1].\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe author argues that while SQLite may not be suitable for all use cases, it should be considered more seriously for many full-stack applications due to its simplicity, performance, and the added reliability provided by Litestream[1].\u003c/p\u003e\n\u003cp\u003eCitations:\n[1] \u003ca href=\"https://fly.io/blog/all-in-on-sqlite-litestream/\"\u003ehttps://fly.io/blog/all-in-on-sqlite-litestream/\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"geeknews\"\u003eGeekNews\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#geeknews\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://news.hada.io/topic?id=6557\"\u003ehttps://news.hada.io/topic?id=6557\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eBoltDB(임베디드 키밸류 DB)를 만든 벤 존슨이 이제 FlyIO에서 Litestream 개발중\u003c/li\u003e\n\u003cli\u003e풀스택 어플리케이션의 상식적인 구조는 n-Tier : 앱서버 + DB서버\u003cbr\u003e\n→ 이 아키텍처에서 SQLite는 유닛테스트용으로만 사용했지만, 이제는 데이터 및 지속 레이어로 충분히 사용 가능\u003c/li\u003e\n\u003cli\u003eLitestream 은 Replication을 통해서 SQLite를 풀스택 어플리케이션에 사용가능하게 만들어주는 오픈소스\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"어플리케이션-데이터베이스의-간략한-역사\"\u003e어플리케이션 데이터베이스의 간략한 역사\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#어플리케이션-데이터베이스의-간략한-역사\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e50년이 긴 시간이 아니지만, 소프트웨어가 데이터를 관리하는 방법은 엄청난 변화가 있었음\u003cbr\u003e\n→ 70년대에는 관계형 데이터베이스라는 것을 정의한 \"Codd의 법칙\" 이 있었음\u003cbr\u003e\n→ 모든 데이터는 테이블에 있고, CRUD, 스키마, SQL 언어 등\u003cbr\u003e\n→ 80년대와 90년대에는 Oracle/DB2/Postgres/MySQL등 SQL 데이터베이스가 폭발적으로 많아짐\u003cbr\u003e\n→ 2000년대의 XML 데이터베이스는 안 좋았고, 같은 시간대에 훌륭한 컬럼 DB들이 등장\u003cbr\u003e\n→ 2010년대에는 대규모 오픈소스 분산 DB 프로젝트들이 출시되고, 이제는 누구나 클러스터를 만들고 테라바이트 단위의 데이터를 쿼리 가능\u003c/li\u003e\n\u003cli\u003e데이터베이스가 진화하면서, DB를 어플리케이션에 연결하는 전략도 발전\u003cbr\u003e\n→ Codd 이후로 티어로 분리\u003cbr\u003e\n→ 가장 처음엔 데이터베이스 티어\u003cbr\u003e\n→ 그다음엔 memcached 와 Redis의 캐슁 티어\u003cbr\u003e\n→ 백그라운드 잡 티어(Sidekiq), 라우팅 티어(PgBouncer), Distribution 티어 등\u003cbr\u003e\n→ 많은 튜토리얼이 3-Tier 인 것 처럼 얘기하지만, 얼마나 많은 티어들이 들어올지 모르니 \"n-Tier\"라고 부르고 있음\u003c/li\u003e\n\u003cli\u003e50년의 시간동안 CPU,메모리,디스크가 수백배 빠르고 저렴해지는 것도 보았음\u003cbr\u003e\n→ 2010년대 데이터베이스 혁신을 실제 정의하는 단어는 \"빅데이터\"임\u003cbr\u003e\n→ 하지만 하드웨어 개선으로 2020년에 와서는 그 컨셉도 유지하기 어려워졌음\u003cbr\u003e\n→ 1996년에 1GB DB 관리는 정말 큰 일이었지만, 2022년엔 노트북이나 t3.micro에서도 운영해도 충분\u003c/li\u003e\n\u003cli\u003e우리가 새로운 DB 아키텍처에 대해 생각할 때, 확장성 제한때문에 최면이 걸림\u003cbr\u003e\n→ 페타바이트 또는 최소 테라바이트 단위를 데이터를 처리하지 못하면 대화에 끼지도 못함\u003cbr\u003e\n→ 하지만 대부분의 어플리케이션은 성공하더라도 테라바이트의 데이터를 보기 어려움\u003cbr\u003e\n→ 우린 못을 박기 위해 착암기(JackHammer)를 쓰고 있는 것\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"sqlite의-달콤한-릴리즈\"\u003eSQLite의 달콤한 릴리즈\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#sqlite의-달콤한-릴리즈\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이런 경향을 잘 반영하는 데이터베이스가 있음\u003c/li\u003e\n\u003cli\u003e세계에서 가장 유명한 SQL DB중 하나이고, 미국 의회 도서관의 공식 보관 형식이며, 신뢰성과 가늠하기 어려운 크기의 테스트 스위트로 유명하고, 성능도 너무 훌륭\u003c/li\u003e\n\u003cli\u003e이 정도면 이름을 말할 필요도 없겠지만.. 뒤에서 손들고 있는 분을 위해.. 이건 바로 \u003cstrong\u003eSQLite\u003c/strong\u003e 이야기임\u003c/li\u003e\n\u003cli\u003eSQLite는 임베디드 DB임. 일반적인 아키텍처 티어에선 존재하지 않는, 당신의 어플리케이션 서버 프로세스에 링크되는 그냥 라이브러리 임\u003cbr\u003e\n→ 다른 서버에 의존하지 않고 혼자 실행 되는 \"싱글 프로세스 어플리케이션\"\u003c/li\u003e\n\u003cli\u003e내가 DB를 만드는 사람이기 때문에 이런 종류의 어플리케이션에 관심을 가짐\u003c/li\u003e\n\u003cli\u003e나는 Go 에코시스템에서 유명한 임베디드 Key/Value DB인 BoltDB를 만들었음\u003c/li\u003e\n\u003cli\u003eBoltDB는 안정적이고, 인프로세스 DB에서 기대하는 것처럼 Nitro가 달린 장난감 자동차 같은 성능을 보여줌\u003c/li\u003e\n\u003cli\u003e하지만, BoltDB는 제한점이 있음\u003cbr\u003e\n→ 스키마가 Go코드로 정의되기 때문에 DB 마이그레이션이 어려움. 직접 당신이 도구를 만들어야 함. 심지어 REPL도 없음\u003c/li\u003e\n\u003cli\u003e당신이 조심만 한다면, 이런 종류의 DB를 쓰면 엄청난 성능을 얻을 수 있음\u003c/li\u003e\n\u003cli\u003e하지만 일반적인 용도로는 이런 DB를 운영하기 원하지 않을 것\u003c/li\u003e\n\u003cli\u003e나는 BoltDB를 더 많은 어플리케이션에서 사용가능하게 만들기 위해 뭘 해야할지를 고민했는데, 내가 도달한 결론은 \"SQLite가 딱 그것을 위해 만들어졌다는 것\"\u003c/li\u003e\n\u003cli\u003eSQLite에도 물론 제약이 있음. 가장 큰것은 단일 프로세스 어플리케이션은 SPOF(Single Point of Failure)가 있다는 것: 서버를 잃어버리면 데이터베이스도 잃어버림. 이것은 SQLite의 결함이 아니라 디자인이 원래 그렇게 된 것\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"enter-litestream\"\u003eEnter Litestream\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#enter-litestream\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e많은 사람들이 SQLite를 기본으로 사용하지 않는 두가지 큰 이유는\u003cbr\u003e\n→ 첫째 스토리지 오류에 대한 복원력(Resilience)\u003cbr\u003e\n→ 둘째 규모가 클 때의 동시성(Concurrency)\u003c/li\u003e\n\u003cli\u003eLitestream이 이 두가지 문제에 대해서 할 말이 있음\u003c/li\u003e\n\u003cli\u003eLitestream은 SQLite 의 WAL(Write Ahead Log) 모드 저널링을 제어함으로써 동작\u003c/li\u003e\n\u003cli\u003eWAL모드에서는 쓰기 오퍼레이션들이 SQLite의 메인 DB 파일외의 별도 로그파일에 추가됨\u003c/li\u003e\n\u003cli\u003eReader들은 쿼리를 충족시키기 위해 WAL 파일과 메인DB를 모두 확인함\u003c/li\u003e\n\u003cli\u003e일반적으로 SQLite는 자동으로 WAL에서 메인 DB로 페이지를 자동 체크포인트를 실행함\u003c/li\u003e\n\u003cli\u003eLitestream은 이 중단단계에서 끼어들어 자동 체크포인트를 방지하는 무한 읽기 트랜잭션을 오픈하고, WAL업데이트를 직접 캡쳐하고 복제하고, 스스로 체크포인트를 트리거함\n\u003cblockquote\u003e\n\u003cp\u003eLitestream에 이해해야 하는 가장 중요한 것은 그냥 SQLite라는 것. 애플리케이션은 표준 SQLite를 사용하며, 종속성을 추가하거나 쿼리를 분석하거나 프록시 동작을 하는게 아님. 그냥 SQLite가 가진 저널링 및 동시성 기능을 활용하는 것. 대부분의 경우 당신의 코드는 Litestream의 존재를 인식하지 못할 수도 있음\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e복잡해 보이지만, 실제로는 엄청 간단함. 써보면 그냥 \"just works\"라는 걸 알수 있음\n\u003cpre class=\"language-shell\"\u003e\u003ccode class=\"language-shell\"\u003e$ litestream replicate fruits.db \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003es3://my-bukkit:9000/fruits.db\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ehttps://s3//my-bukkit:9000/fruits.db\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n$ litestream restore -o fruits-replica.db \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003es3://my-bukkit:9000/fruits.db\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ehttps://s3//my-bukkit:9000/fruits.db\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e일반적으로 사람들은 SQLite DB를 복제해서 S3에 저장하는 용도로 사용\u003c/li\u003e\n\u003cli\u003e운영상 큰 이점을 줌. 당신의 DB는 탄력적이고 쉽게 옮기거나 마이그레이션 가능해짐\u003c/li\u003e\n\u003cli\u003e하지만 Litestream으로 더 많은 것들을 할 수 있음.\u003c/li\u003e\n\u003cli\u003e다음 버전에서는 SQLite DB간에 실시간 복제가 가능해져서, 분산 Read Replica 와 Write-Leader DB를 셋업하는게 가능해 짐\u003cbr\u003e\n→ Read Replica는 Write를 캐치해서 Leader에게 Redirect 가능\u003cbr\u003e\n→ 많은 어플리케이션들은 Read-heavy니까 이 셋업은 어플리케이션에게 글로벌하게 스케일 가능한 DB를 제공할수 있게 되는 것\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"당신은-이-옵션어플리케이션-db로-sqlite를-사용하는-것을-더-심각하게-받아들여야-함\"\u003e당신은 이 옵션(어플리케이션 DB로 SQLite를 사용하는 것)을 더 심각하게 받아들여야 함\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#당신은-이-옵션어플리케이션-db로-sqlite를-사용하는-것을-더-심각하게-받아들여야-함\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e나의 초창기 IT 직업중 하나는 2000년대 초 오라클DBA 였음\u003c/li\u003e\n\u003cli\u003e나는 오라클에 대해서 배우기 위해 수많은 책과 문서들을 읽는데 시간을 보냈음\u003c/li\u003e\n\u003cli\u003e관리자 매뉴얼은 거의 천페이지 가량이었고, 그건 수백개의 문서중 하나였음\u003c/li\u003e\n\u003cli\u003e쿼리를 최적화 하거나 쓰기를 개선하기 위해 뭘 해야 하는 지를 배우면 그 당시에는 큰 차이를 만들어냈음\u003c/li\u003e\n\u003cli\u003e초당 수십메가를 읽는 하드디스크가 있으므로, 더 나은 인덱스를 활용하면 5분 걸리는 쿼리를 30초 짜리 쿼리로 바꿔줄수 있음\u003c/li\u003e\n\u003cli\u003e하지만 DB최적화는 점점 일반 어플리케이션엔 중요하지 않아짐\u003c/li\u003e\n\u003cli\u003e1GB DB를 가지고 있다면 NVMe디스크는 1초 이내에 모든 것을 메모리에 담을 수 있음\u003c/li\u003e\n\u003cli\u003eSQL 쿼리 최적화를 좋아하지만, 많은 어플리케이션 개발자들에게 이건 죽어가는 기술이 되고 있음\u003c/li\u003e\n\u003cli\u003e제대로 튜닝되지 않은 쿼리라도 많은 데이터베이스에서 1초이내에 실행 가능\u003c/li\u003e\n\u003cli\u003e최신 Postgres는 기적임. 수년간 그 코드를 읽으면서 많은 것들을 배웠음\u003c/li\u003e\n\u003cli\u003e쿼리 옵티마이저, 행단위 보안 정책, 6가지 유형의 인덱스 등\u003c/li\u003e\n\u003cli\u003e이런 기능을 원한다면 필요하겠지만, 대부분은 그렇지 않음\u003c/li\u003e\n\u003cli\u003e그리고 만약 이런 Postgres 기능을 원하지 않는다면, 책임이 뒤따름\u003c/li\u003e\n\u003cli\u003e여러개의 계정을 사용하지 않더라고 호스 기반 인증을 구성해야 하고, 방화벽을 해제해야함\u003c/li\u003e\n\u003cli\u003e더 많은 기능은 더 많은 문서를 의미하므로 실제로 당신이 운영중인 소프트웨어에 대해 알기 어려움\u003c/li\u003e\n\u003cli\u003ePostgre14 의 문서는 거의 3천페이지임\u003c/li\u003e\n\u003cli\u003eSQLite는 Postgres 기능의 서브셋을 가짐. 하지만 내가 일반적으로 원하는 기능의 99.9% 임\u003c/li\u003e\n\u003cli\u003e뛰어난 SQL 지원, 윈도우 기능, CTE, 전문 검색, JSON 지원 등\u003c/li\u003e\n\u003cli\u003e기능이 부족하자면 데이터가 내 애플리케이션 옆에 있으므로 가져와서 처리하기에 오버헤드가 별로 없음\u003c/li\u003e\n\u003cli\u003e한편 정말 해결해야 하는 복잡한 문제는 핵심 데이터베이스 기능으로는 해결되지 않음\u003c/li\u003e\n\u003cli\u003e대신 레이턴시와 개발자 경험 두가지만 최적화 하고 싶음\u003c/li\u003e\n\u003cli\u003e따라서, SQLite를 진지하게 고려해야 하는 한가지 이유는 운영이 정말 간단하기 때문\u003c/li\u003e\n\u003cli\u003e데이터베이스 계층을 설계하지 않고 그냥 어플리케이션 코드 작성에 시간을 쓰는 것이 가능\u003c/li\u003e\n\u003cli\u003e하지만 다른 문제가 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"빛은-너무-느리다--the-light-is-too-damn-slow\"\u003e빛은 너무 느리다 : The Light is Too Damn Slow\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#빛은-너무-느리다--the-light-is-too-damn-slow\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e이론적인 한계에 부딪히기 시작. 진공상태에서 빛은 1밀리초에 186마일을 이동(필라델피아에서 뉴욕까지 왕복 거리)\u003c/li\u003e\n\u003cli\u003e네트워크 스위치, 방화벽 및 애플리케이션 프로토콜 레이어를 추가하면 더 느려짐\u003c/li\u003e\n\u003cli\u003e단일 AWS 리젼내에서 Postgres 쿼리에 대한 레이턴시 오버헤드는 최대 1밀리초 이내\u003c/li\u003e\n\u003cli\u003e이것은 Postgres가 느리다는 것이 아니라 데이터 이동 속도의 한계에 도달한 것\u003c/li\u003e\n\u003cli\u003e최신 어플리케이션은 HTTP 요청을 처리하며, 여러개의 데이터베이스 쿼리와 비즈니스 로직 또는 렌더링 하기 전에 이미 10ms를 소모함\u003c/li\u003e\n\u003cli\u003e애플리케이션 레이턴시에는 매직 넘버가 있음 : 100ms 이하의 응답은 거의 즉시처럼 느껴 진다는 것\u003c/li\u003e\n\u003cli\u003e즉시 응답하는(Snappy) 어플리케이션은 행복한 사용자를 만듦\u003c/li\u003e\n\u003cli\u003e100ms는 많은 것 같지만 무심코 먹어버리기 쉬움\u003c/li\u003e\n\u003cli\u003e100ms 임계값은 매우 중요하기 때문에 사람들은 레이턴시를 줄이기 위해 페이지를 프리렌더링하고 CDN에 태움\u003c/li\u003e\n\u003cli\u003e우린 데이터를 어플리케이션 가까이로 옮기는게 좋음. 얼마나? 정말 가깝게\u003c/li\u003e\n\u003cli\u003eSQLite는 당신의 어플리케이션과 같은 머신에 있는 것만이 아니라, 당신의 어플리케이션 프로세스 안에 포함됨\u003c/li\u003e\n\u003cli\u003e데이터를 어플리케이션 옆에 두면 쿼리당 레이턴시가 10~20 마이크로세컨드(μ)로 떨어지는 것을 볼수 있음\u003c/li\u003e\n\u003cli\u003e즉 동일 리젼내의 Postgres 쿼리보다 50~100x 빠름\u003c/li\u003e\n\u003cli\u003e하지만, 더 많은 것이 있음. 쿼리당 지연시간을 효율적으로 제거했음. 우리 어플리케이션이 빠르면서도 더 간단함\u003c/li\u003e\n\u003cli\u003e큰 쿼리들을 더 작은 관리 가능한 쿼리로 분할할 수 있고, 새로운 기능을 구축하기 위해 N+1 쿼리 패턴을 찾는데 시간을 더 할애할 수 있음\u003c/li\u003e\n\u003cli\u003e레이턴시를 최소화 하는 것은 프로덕션만을 위한 것은 아님. 기존 클라이언트/서버 DB와 연통 테스트를 하는 것은 로컬에서 몇분씩 걸릴 정도로 곧 잘 늘어나며, CI로 푸시해도 고통은 계속 됨\u003c/li\u003e\n\u003cli\u003e코드 변경에서 테스트 완료까지의 피드백 루프를 줄이면 시간이 절약되고 개발하는 동안 포커스를 유지할 수 있음\u003c/li\u003e\n\u003cli\u003eSQLite에서 한 줄 변경하는 것은 메모리에서 실행해서 통합 테스트를 몇 초 이내에 실행 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"작고-빠르고-신뢰할수-있고-글로벌-분산되어-있고--이-중에서-4개를-선택하세요\"\u003e작고, 빠르고, 신뢰할수 있고, 글로벌 분산되어 있고 : 이 중에서 4개를 선택하세요\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#작고-빠르고-신뢰할수-있고-글로벌-분산되어-있고--이-중에서-4개를-선택하세요\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLitestream 은 분산 되어있고, 복제되며, 가장 중요한 것은 \u003cstrong\u003e이해하기 쉬움\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e진지하게, \"한번 시도해 보세요\" 알아야할 것이 별로 없습니다\u003c/li\u003e\n\u003cli\u003e내 주장은 이겁니다 :\n\u003cul\u003e\n\u003cli\u003eSQLite를 위한 안정적이고 사용하기 쉬운 복제를 구축하면, SQLite에서만 운영되는 풀스택 어플리케이션을 매력적으로 만든다는 것\u003c/li\u003e\n\u003cli\u003e예전 \"Rails로 Blog로 만들기 튜토리얼\"이 작성되었던 시절엔 이 옵션을 간과했지만, 요즘의 SQLite는 대부분의 어플리케이션 쓰기 부하를 견딜수 있으며, 복제본을 통해서 수많은 인스턴스에서 읽어갈수 있도록 로드밸런싱이 가능\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eLitestream에도 제약이 있음\n\u003cul\u003e\n\u003cli\u003e싱글 노드 어플리케이션을 위해 만들었기 때문에, 서버리스 플랫폼이나 롤링 배포에는 잘 동작하지 않음\u003c/li\u003e\n\u003cli\u003e모든 변경사항을 순차적으로 복원해야 하므로 DB 리스토어에 몇분가량 걸릴수 있음\u003c/li\u003e\n\u003cli\u003e우리는 실시간 복제 기능을 준비하고 있지만, 별도 프로세스 모델은 복제 보장에 대한 세부제어 부분에서 제약이 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e더 잘할 수 있음\n\u003cul\u003e\n\u003cli\u003e지난 1년간 내가 해온 일은 Litestream의 핵심을 정하고 정확성에 초점을 맞추는 것\u003c/li\u003e\n\u003cli\u003e현재 도착한 위치에 만족함\u003c/li\u003e\n\u003cli\u003e단순한 스트리밍 백업 도구로 시작했지만, 점차 안정적이고 분산된 데이터베이스로 발전 중\u003c/li\u003e\n\u003cli\u003e나의 Fly.io에서의 일은 이걸 더 빠르고 심리스하게 만드는 것\u003c/li\u003e\n\u003cli\u003eFly.io 와 상관없이 Litestream에 더 많은 개선들이 추가 될 것\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eLitestream 은 Fly.io에서 새 집을 꾸렸지만, 계속 오픈소스 프로젝트 일 것\u003c/li\u003e\n\u003cli\u003e차후 몇년간 내 계획은 어플리케이션이 어디서 실행되는 지와 상관없이, 더 유용하게 만들고, SQLite 모델이 어디까지 나아갈수 있을지 확인하는 것\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"51vp6g9mkchaqv0h92xmvs7"},"buildId":"vOE8u-mg___OsOsz4tjEg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>