<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Why Functional Programming Should Be the Future of Software Development</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Why Functional Programming Should Be the Future of Software Development"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/0bqed1lx0c7hfr0txl97vrz/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="11/2/2022"/><meta property="article:modified_time" content="11/2/2022"/><link rel="canonical" href="https://luke-snaw.github.io//notes/0bqed1lx0c7hfr0txl97vrz/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_buildManifest.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="why-functional-programming-should-be-the-future-of-software-development">Why Functional Programming Should Be the Future of Software Development<a aria-hidden="true" class="anchor-heading icon-link" href="#why-functional-programming-should-be-the-future-of-software-development"></a></h1>
<blockquote>
<p>It’s hard to learn, but your code will produce fewer nasty surprises<br>
BY <a href="https://spectrum.ieee.org/u/charles_scalfani">Charles Scalfani</a> 23 Oct 2022<br>
<a href="https://spectrum.ieee.org/functional-programming">https://spectrum.ieee.org/functional-programming</a></p>
</blockquote>
<p><strong>You’d expect</strong> the longest and most costly phase in the lifecycle of a software product to be the initial development of the system, when all those great features are first imagined and then created. In fact, the hardest part comes later, during the maintenance phase. That’s when programmers pay the price for the shortcuts they took during development.</p>
<p>So why did they take shortcuts? Maybe they didn’t realize that they were cutting any corners. Only when their code was deployed and exercised by a lot of users did its hidden flaws come to light. And maybe the developers were rushed. Time-to-market pressures would almost guarantee that their software will contain more bugs than it would otherwise.</p>
<hr>
<p>The struggle that most companies have maintaining code causes a second problem: fragility. Every new feature that gets added to the code increases its complexity, which then increases the chance that something will break. It’s common for software to grow so complex that the developers avoid changing it more than is absolutely necessary for fear of breaking something. In many companies, whole teams of developers are employed not to develop anything new but just to keep existing systems going. You might say that they run a software version of the <a href="https://en.wikipedia.org/wiki/Red_Queen%27s_race">Red Queen’s race</a>, running as fast as they can just to stay in the same place.</p>
<p>It’s a sorry situation. Yet the current trajectory of the software industry is toward increasing complexity, longer product-development times, and greater fragility of production systems. To address such issues, companies usually just throw more people at the problem: more developers, more testers, and more technicians who intervene when systems fail.</p>
<p>Surely there must be a better way. I’m part of a growing group of developers who think the answer could be functional programming. Here I describe what functional programming is, why using it helps, and why I’m so enthusiastic about it.</p>
<h2 id="with-functional-programming-less-is-more">With functional programming, less is more<a aria-hidden="true" class="anchor-heading icon-link" href="#with-functional-programming-less-is-more"></a></h2>
<p>A good way to understand the rationale for functional programming is by considering something that happened more than a half century ago. In the late 1960s, a programming paradigm emerged that aimed to improve the quality of code while reducing the development time needed. It was called <a href="https://en.wikipedia.org/wiki/Structured_programming">structured programming</a>.</p>
<p>Various languages emerged to foster structured programming, and some existing languages were modified to better support it. One of the most notable features of these structured-programming languages was not a feature at all: It was the absence of something that had been around a long time— <a href="https://en.wikipedia.org/wiki/Goto">the GOTO statement</a>.</p>
<p>The GOTO statement is used to redirect program execution. Instead of carrying out the next statement in sequence, the flow of the program is redirected to some other statement, the one specified in the GOTO line, typically when some condition is met.</p>
<p>The elimination of the GOTO was based on what programmers had learned from using it—that it made the program very hard to understand. Programs with GOTOs were often referred to as spaghetti code because the sequence of instructions that got executed could be as hard to follow as a single strand in a bowl of spaghetti.</p>
<p>The inability of these developers to understand how their code worked, or why it sometimes didn’t work, was a complexity problem. Software experts of that era believed that those GOTO statements <a href="https://dl.acm.org/doi/10.1145/362929.362947">were creating unnecessary complexity</a> and that the GOTO had to, well, go.</p>
<p>Back then, this was a radical idea, and many programmers resisted the loss of a statement that they had grown to rely on. The debate went on for more than a decade, but in the end, the GOTO went extinct, and no one today would argue for its return. That’s because its elimination from higher-level programming languages greatly reduced complexity and boosted the reliability of the software being produced. It did this by limiting what programmers could do, which ended up making it easier for them to reason about the code they were writing.</p>
<p>Although the software industry has eliminated GOTO from modern higher-level languages, software nevertheless continues to grow in complexity and fragility. Looking for how else such programming languages could be modified to avoid some common pitfalls, software designers can find inspiration, curiously enough, from their counterparts on the hardware side.</p>
<h2 id="nullifying-problems-with-null-references">Nullifying problems with null references<a aria-hidden="true" class="anchor-heading icon-link" href="#nullifying-problems-with-null-references"></a></h2>
<p>In designing hardware for a computer, you can’t have a resistor shared by, say, both the keyboard and the monitor’s circuitry. But programmers do this kind of sharing all the time in their software. It’s called shared global state: Variables are owned by no one process but can be changed by any number of processes, even simultaneously.</p>
<p>Now, imagine that every time you ran your microwave, your dishwasher’s settings changed from Normal Cycle to Pots and Pans. That, of course, doesn’t happen in the real world, but in software, this kind of thing goes on all the time. Programmers write code that calls a function, expecting it to perform a single task. But many functions have side effects that change the shared global state, <a href="https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil">giving rise to unexpected consequences</a>.</p>
<p>In hardware, that doesn’t happen because the laws of physics curtail what’s possible. Of course, hardware engineers can mess up, but not like you can with software, where just too many things are possible, for better or worse.</p>
<p>Another complexity monster lurking in the software quagmire is called a <a href="https://en.wikipedia.org/wiki/Null_pointer">null reference</a>, meaning that a reference to a place in memory points to nothing at all. If you try to use this reference, an error ensues. So programmers have to remember to check whether something is null before trying to read or change what it references.</p>
<p>Nearly every popular language today has this flaw. The pioneering computer scientist <a href="http://www.cs.ox.ac.uk/people/tony.hoare/">Tony Hoare</a> introduced null references in the <a href="https://en.wikipedia.org/wiki/ALGOL">ALGOL</a> language back in 1965, and it was later incorporated into numerous other languages. Hoare explained that he did this “simply because it was so easy to implement,” but today he considers it to be a “billion-dollar mistake.” That’s because it has caused countless bugs when a reference that the programmer expects to be valid is really a null reference.</p>
<p>Software developers need to be extremely disciplined to avoid such pitfalls, and sometimes they don’t take adequate precautions. The architects of structured programming knew this to be true for GOTO statements and left developers no escape hatch. To guarantee the improvements in clarity that GOTO-free code promised, they knew that they’d have to eliminate it entirely from their structured-programming languages.</p>
<p>History is proof that removing a dangerous feature can greatly improve the quality of code. Today, we have a slew of dangerous practices that compromise the robustness and maintainability of software. Nearly all modern programming languages have some form of null references, shared global state, and functions with side effects—things that are far worse than the GOTO ever was.</p>
<p>How can those flaws be eliminated? It turns out that the answer <a href="https://www.math-cs.gordon.edu/courses/cps323/LISP/lisp.html">has been around for decades</a>: purely functional programming languages.</p>
<p>Of the top dozen functional-programming languages, Haskell is by far the most popular, judging by the number of GitHub repositories that use these languages.</p>
<p>The first purely functional language to become popular, called <a href="https://www.haskell.org/">Haskell</a>, was created in 1990. So by the mid-1990s, the world of software development really had the solution to the vexing problems it still faces. Sadly, the hardware of the time often wasn’t powerful enough to make use of the solution. But today’s processors can easily manage the demands of Haskell and other purely functional languages.</p>
<p>Indeed, software based on pure functions is particularly well suited to modern <a href="https://spectrum.ieee.org/the-trouble-with-multicore">multicore CPUs</a>. That’s because pure functions operate only on their input parameters, making it impossible to have any interactions between different functions. This allows the compiler to be optimized to produce code that runs on multiple cores efficiently and easily.</p>
<p>As the name suggests, with purely functional programming, the developer can write only pure functions, which, by definition, cannot have side effects. With this one restriction, you increase stability, open the door to compiler optimizations, and end up with code that’s far easier to reason about.</p>
<p>But what if a function needs to know or needs to manipulate the state of the system? In that case, the state is passed through a long chain of what are called composed functions—functions that pass their outputs to the inputs of the next function in the chain. By passing the state from function to function, each function has access to it and there’s no chance of another concurrent programming thread modifying that state—another common and costly fragility found in far too many programs.</p>
<hr>
<h3 id="avoiding-null-reference-surprises">Avoiding Null-Reference Surprises<a aria-hidden="true" class="anchor-heading icon-link" href="#avoiding-null-reference-surprises"></a></h3>
<p><strong>A comparison of Javascript and Purescript shows how the latter can help programmers avoid bugs.</strong></p>
<p><img src="/assets/images/a-comparison-of-javascript-and-purescript-shows-how-the-latter-can-help-programmers-avoid-bugs.webp"></p>
<hr>
<p>Functional programming also has a solution to Hoare’s “billion-dollar mistake,” null references. It addresses that problem by disallowing nulls. Instead, there is a construct usually called <em>Maybe</em> (or <em>Option</em> in some languages). A <em>Maybe</em> can be <em>Nothing</em> or <em>Just</em> some value. Working with <em>Maybe__s</em> forces developers to always consider both cases. They have no choice in the matter. They must handle the <em>Nothing</em> case every single time they encounter a <em>Maybe</em>. Doing so eliminates the many bugs that null references can spawn.</p>
<p>Functional programming also requires that data be immutable, meaning that once you set a variable to some value, it is forever that value. Variables are more like variables in math. For example, to compute a formula, <em>y</em> = <em>x_2 + 2_x</em> – 11, you pick a value for <em>x</em> and at no time during the computation of <em>y</em> does <em>x</em> take on a different value. So, the same value for <em>x</em> is used when computing <em>x_2 as is used when computing 2_x</em>. In most programming languages, there is no such restriction. You can compute <em>x_2 with one value, then change the value of _x</em> before computing 2<em>x</em>. By disallowing developers from changing (mutating) values, they can use the same reasoning they did in middle-school algebra class.</p>
<p>Unlike most languages, functional programming languages are deeply rooted in mathematics. It’s this lineage in the highly disciplined field of mathematics that gives functional languages their biggest advantages.</p>
<p>Why is that? It’s because people have been working on mathematics for thousands of years. It’s pretty solid. Most programming paradigms, such as object-oriented programming, have at most half a dozen decades of work behind them. They are crude and immature by comparison.</p>
<blockquote>
<p>Imagine if every time you ran your microwave, your dishwasher’s settings changed from Normal Cycle to Pots and Pans. In software, this kind of thing goes on all the time.</p>
</blockquote>
<p>Let me share an example of how programming is sloppy compared with mathematics. We typically teach new programmers to forget what they learned in math class when they first encounter the statement <em>x = x + 1</em>. In math, this equation has zero solutions. But in most of today’s programming languages, <em>x = x + 1</em> is not an equation. It is a <em>statement</em> that commands the computer to take the value of <em>x</em>, add one to it, and put it back into a variable called <em>x</em>.</p>
<p><strong>In functional programming, there are no statements, only <em>expressions</em>.</strong> Mathematical thinking that we learned in middle school can now be employed when writing code in a functional language.</p>
<p>Thanks to functional purity, you can reason about code using algebraic substitution to help reduce code complexity in the same way you reduced the complexity of equations back in algebra class. In non-functional languages (imperative languages), there is no equivalent mechanism for reasoning about how the code works.</p>
<h2 id="functional-programming-has-a-steep-learning-curve">Functional programming has a steep learning curve<a aria-hidden="true" class="anchor-heading icon-link" href="#functional-programming-has-a-steep-learning-curve"></a></h2>
<p>Pure functional programming solves many of our industry’s biggest problems by removing dangerous features from the language, making it harder for developers to shoot themselves in the foot. At first, these limitations may seem drastic, as I’m sure the 1960s developers felt regarding the removal of GOTO. But the fact of the matter is that it’s both liberating and empowering to work in these languages—so much so that nearly all of today’s most popular languages have incorporated functional features, although they remain fundamentally imperative languages.</p>
<p>The biggest problem with this hybrid approach is that it still allows developers to ignore the functional aspects of the language. Had we left GOTO as an option 50 years ago, we might still be struggling with spaghetti code today.</p>
<p>To reap the full benefits of pure functional programming languages, you can’t compromise. You need to use languages that were designed with these principles from the start. Only by adopting them will you get the many benefits that I’ve outlined here.</p>
<p>But functional programming isn’t a bed of roses. It comes at a cost. Learning to program according to this functional paradigm is almost like learning to program again from the beginning. In many cases, developers must familiarize themselves with math that they didn’t learn in school. The required math isn’t difficult—it’s just new and, to the math phobic, scary.</p>
<p>More important, developers need to learn a new way of thinking. At first this will be a burden, because they are not used to it. But with time, this new way of thinking becomes second nature and ends up reducing cognitive overhead compared with the old ways of thinking. The result is a massive gain in efficiency.</p>
<p>But making the transition to functional programming can be difficult. My own journey doing so a few years back is illustrative.</p>
<p>I decided to learn Haskell—and needed to do that on a business timeline. This was the most difficult learning experience of my 40-year career, in large part because there was no definitive source for helping developers make the transition to functional programming. Indeed, no one had written anything very comprehensive about functional programming in the prior three decades.</p>
<blockquote>
<p>To reap the full benefits of pure functional programming languages, you can’t compromise. You need to use languages that were designed with these principles from the start.</p>
</blockquote>
<p>I was left to pick up bits and pieces from here, there, and everywhere. And I can attest to the gross inefficiencies of that process. It took me three months of days, nights, and weekends living and breathing Haskell. But finally, I got to the point that I could write better code with it than with anything else.</p>
<p>When I decided that our company should switch to using functional languages, I didn’t want to put my developers through the same nightmare. So, I started building a curriculum for them to use, which became the basis for a book intended to help developers transition into functional programmers. In <a href="https://leanpub.com/fp-made-easier">my book</a>, I provide guidance for obtaining proficiency in a functional language called <a href="https://www.purescript.org/">PureScript</a>, which stole all the great aspects of Haskell and improved on many of its shortcomings. In addition, it’s able to operate in both the browser and in a back-end server, making it a great solution for many of today’s software demands.</p>
<p>While such learning resources can only help, for this transition to take place broadly, software-based businesses must invest more in their biggest asset: their developers. At my company, <a href="http://www.panosoft.com/">Panoramic Software</a>, where I’m the chief technical officer, we’ve made this investment, and all new work is being done in either PureScript or Haskell.</p>
<p>We started down the road of adopting functional languages three years ago, beginning with another pure functional language called <a href="https://elm-lang.org/">Elm</a> because it is a simpler language. (Little did we know we would eventually outgrow it.) It took us about a year to start reaping the benefits. But since we got over the hump, it’s been wonderful. We have had no production runtime bugs, which were so common in what we were formerly using, <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a> on the front end and Java on the back. This improvement allowed the team to spend far more time adding new features to the system. Now, we spend almost no time debugging production issues.</p>
<p>But there are still challenges when working with a language that relatively few others use—in particular, the lack of online help, documentation, and example code. And it’s hard to hire developers with experience in these languages. Because of that, my company uses recruiters who specialize in finding functional programmers. And when we hire someone with no background in functional programming, we put them through a training process for the first few months to bring them up to speed.</p>
<h2 id="functional-programmings-future">Functional programming’s future<a aria-hidden="true" class="anchor-heading icon-link" href="#functional-programmings-future"></a></h2>
<p>My company is small. It delivers software to governmental agencies to enable them to help veterans receive benefits from the <a href="https://www.va.gov/">U.S. Department of Veteran’s Affairs</a>. It’s extremely rewarding work, but it’s not a lucrative field. With razor-slim margins, we must use every tool available to us to do more with fewer developers. And for that, functional programming is just the ticket.</p>
<p>It’s very common for unglamorous businesses like ours to have difficulty attracting developers. But we are now able to hire top-tier people because they want to work on a functional codebase. Being ahead of the curve on this trend, we can get talent that most companies our size could only dream of.</p>
<p>I anticipate that the adoption of pure functional languages will improve the quality and robustness of the whole software industry while greatly reducing time wasted on bugs that are simply impossible to generate with functional programming. It’s not magic, but sometimes it feels like that, and I’m reminded of how good I have it every time I’m forced to work with a non-functional codebase.</p>
<p>One sign that the software industry is preparing for a paradigm shift is that functional features are showing up in more and more mainstream languages. It will take much more work for the industry to make the transition fully, but the benefits of doing so are clear, and that is no doubt where things are headed.</p></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#with-functional-programming-less-is-more" title="With functional programming, less is more">With functional programming, less is more</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#nullifying-problems-with-null-references" title="Nullifying problems with null references">Nullifying problems with null references</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#avoiding-null-reference-surprises" title="Avoiding Null-Reference Surprises">Avoiding Null-Reference Surprises</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#functional-programming-has-a-steep-learning-curve" title="Functional programming has a steep learning curve">Functional programming has a steep learning curve</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#functional-programmings-future" title="Functional programming’s future">Functional programming’s future</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"0bqed1lx0c7hfr0txl97vrz","title":"Why Functional Programming Should Be the Future of Software Development","desc":"","updated":1667433307539,"created":1667433066928,"custom":{},"fname":"dev.functional-programming.spectrum-ieee__functional-programming","type":"note","vault":{"fsPath":"vault"},"contentHash":"720f071a044703a689559c5b931fb082","links":[],"anchors":{"with-functional-programming-less-is-more":{"type":"header","text":"With functional programming, less is more","value":"with-functional-programming-less-is-more","line":24,"column":0,"depth":2},"nullifying-problems-with-null-references":{"type":"header","text":"Nullifying problems with null references","value":"nullifying-problems-with-null-references","line":40,"column":0,"depth":2},"avoiding-null-reference-surprises":{"type":"header","text":"Avoiding Null-Reference Surprises","value":"avoiding-null-reference-surprises","line":70,"column":0,"depth":3},"functional-programming-has-a-steep-learning-curve":{"type":"header","text":"Functional programming has a steep learning curve","value":"functional-programming-has-a-steep-learning-curve","line":94,"column":0,"depth":2},"functional-programmings-future":{"type":"header","text":"Functional programming’s future","value":"functional-programmings-future","line":122,"column":0,"depth":2}},"children":[],"parent":"HtVLXiN97I2jTm8h2NEVQ","data":{}},"body":"\u003ch1 id=\"why-functional-programming-should-be-the-future-of-software-development\"\u003eWhy Functional Programming Should Be the Future of Software Development\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#why-functional-programming-should-be-the-future-of-software-development\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIt’s hard to learn, but your code will produce fewer nasty surprises\u003cbr\u003e\nBY \u003ca href=\"https://spectrum.ieee.org/u/charles_scalfani\"\u003eCharles Scalfani\u003c/a\u003e 23 Oct 2022\u003cbr\u003e\n\u003ca href=\"https://spectrum.ieee.org/functional-programming\"\u003ehttps://spectrum.ieee.org/functional-programming\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003eYou’d expect\u003c/strong\u003e the longest and most costly phase in the lifecycle of a software product to be the initial development of the system, when all those great features are first imagined and then created. In fact, the hardest part comes later, during the maintenance phase. That’s when programmers pay the price for the shortcuts they took during development.\u003c/p\u003e\n\u003cp\u003eSo why did they take shortcuts? Maybe they didn’t realize that they were cutting any corners. Only when their code was deployed and exercised by a lot of users did its hidden flaws come to light. And maybe the developers were rushed. Time-to-market pressures would almost guarantee that their software will contain more bugs than it would otherwise.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eThe struggle that most companies have maintaining code causes a second problem: fragility. Every new feature that gets added to the code increases its complexity, which then increases the chance that something will break. It’s common for software to grow so complex that the developers avoid changing it more than is absolutely necessary for fear of breaking something. In many companies, whole teams of developers are employed not to develop anything new but just to keep existing systems going. You might say that they run a software version of the \u003ca href=\"https://en.wikipedia.org/wiki/Red_Queen%27s_race\"\u003eRed Queen’s race\u003c/a\u003e, running as fast as they can just to stay in the same place.\u003c/p\u003e\n\u003cp\u003eIt’s a sorry situation. Yet the current trajectory of the software industry is toward increasing complexity, longer product-development times, and greater fragility of production systems. To address such issues, companies usually just throw more people at the problem: more developers, more testers, and more technicians who intervene when systems fail.\u003c/p\u003e\n\u003cp\u003eSurely there must be a better way. I’m part of a growing group of developers who think the answer could be functional programming. Here I describe what functional programming is, why using it helps, and why I’m so enthusiastic about it.\u003c/p\u003e\n\u003ch2 id=\"with-functional-programming-less-is-more\"\u003eWith functional programming, less is more\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#with-functional-programming-less-is-more\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eA good way to understand the rationale for functional programming is by considering something that happened more than a half century ago. In the late 1960s, a programming paradigm emerged that aimed to improve the quality of code while reducing the development time needed. It was called \u003ca href=\"https://en.wikipedia.org/wiki/Structured_programming\"\u003estructured programming\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eVarious languages emerged to foster structured programming, and some existing languages were modified to better support it. One of the most notable features of these structured-programming languages was not a feature at all: It was the absence of something that had been around a long time— \u003ca href=\"https://en.wikipedia.org/wiki/Goto\"\u003ethe GOTO statement\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe GOTO statement is used to redirect program execution. Instead of carrying out the next statement in sequence, the flow of the program is redirected to some other statement, the one specified in the GOTO line, typically when some condition is met.\u003c/p\u003e\n\u003cp\u003eThe elimination of the GOTO was based on what programmers had learned from using it—that it made the program very hard to understand. Programs with GOTOs were often referred to as spaghetti code because the sequence of instructions that got executed could be as hard to follow as a single strand in a bowl of spaghetti.\u003c/p\u003e\n\u003cp\u003eThe inability of these developers to understand how their code worked, or why it sometimes didn’t work, was a complexity problem. Software experts of that era believed that those GOTO statements \u003ca href=\"https://dl.acm.org/doi/10.1145/362929.362947\"\u003ewere creating unnecessary complexity\u003c/a\u003e and that the GOTO had to, well, go.\u003c/p\u003e\n\u003cp\u003eBack then, this was a radical idea, and many programmers resisted the loss of a statement that they had grown to rely on. The debate went on for more than a decade, but in the end, the GOTO went extinct, and no one today would argue for its return. That’s because its elimination from higher-level programming languages greatly reduced complexity and boosted the reliability of the software being produced. It did this by limiting what programmers could do, which ended up making it easier for them to reason about the code they were writing.\u003c/p\u003e\n\u003cp\u003eAlthough the software industry has eliminated GOTO from modern higher-level languages, software nevertheless continues to grow in complexity and fragility. Looking for how else such programming languages could be modified to avoid some common pitfalls, software designers can find inspiration, curiously enough, from their counterparts on the hardware side.\u003c/p\u003e\n\u003ch2 id=\"nullifying-problems-with-null-references\"\u003eNullifying problems with null references\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#nullifying-problems-with-null-references\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIn designing hardware for a computer, you can’t have a resistor shared by, say, both the keyboard and the monitor’s circuitry. But programmers do this kind of sharing all the time in their software. It’s called shared global state: Variables are owned by no one process but can be changed by any number of processes, even simultaneously.\u003c/p\u003e\n\u003cp\u003eNow, imagine that every time you ran your microwave, your dishwasher’s settings changed from Normal Cycle to Pots and Pans. That, of course, doesn’t happen in the real world, but in software, this kind of thing goes on all the time. Programmers write code that calls a function, expecting it to perform a single task. But many functions have side effects that change the shared global state, \u003ca href=\"https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil\"\u003egiving rise to unexpected consequences\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIn hardware, that doesn’t happen because the laws of physics curtail what’s possible. Of course, hardware engineers can mess up, but not like you can with software, where just too many things are possible, for better or worse.\u003c/p\u003e\n\u003cp\u003eAnother complexity monster lurking in the software quagmire is called a \u003ca href=\"https://en.wikipedia.org/wiki/Null_pointer\"\u003enull reference\u003c/a\u003e, meaning that a reference to a place in memory points to nothing at all. If you try to use this reference, an error ensues. So programmers have to remember to check whether something is null before trying to read or change what it references.\u003c/p\u003e\n\u003cp\u003eNearly every popular language today has this flaw. The pioneering computer scientist \u003ca href=\"http://www.cs.ox.ac.uk/people/tony.hoare/\"\u003eTony Hoare\u003c/a\u003e introduced null references in the \u003ca href=\"https://en.wikipedia.org/wiki/ALGOL\"\u003eALGOL\u003c/a\u003e language back in 1965, and it was later incorporated into numerous other languages. Hoare explained that he did this “simply because it was so easy to implement,” but today he considers it to be a “billion-dollar mistake.” That’s because it has caused countless bugs when a reference that the programmer expects to be valid is really a null reference.\u003c/p\u003e\n\u003cp\u003eSoftware developers need to be extremely disciplined to avoid such pitfalls, and sometimes they don’t take adequate precautions. The architects of structured programming knew this to be true for GOTO statements and left developers no escape hatch. To guarantee the improvements in clarity that GOTO-free code promised, they knew that they’d have to eliminate it entirely from their structured-programming languages.\u003c/p\u003e\n\u003cp\u003eHistory is proof that removing a dangerous feature can greatly improve the quality of code. Today, we have a slew of dangerous practices that compromise the robustness and maintainability of software. Nearly all modern programming languages have some form of null references, shared global state, and functions with side effects—things that are far worse than the GOTO ever was.\u003c/p\u003e\n\u003cp\u003eHow can those flaws be eliminated? It turns out that the answer \u003ca href=\"https://www.math-cs.gordon.edu/courses/cps323/LISP/lisp.html\"\u003ehas been around for decades\u003c/a\u003e: purely functional programming languages.\u003c/p\u003e\n\u003cp\u003eOf the top dozen functional-programming languages, Haskell is by far the most popular, judging by the number of GitHub repositories that use these languages.\u003c/p\u003e\n\u003cp\u003eThe first purely functional language to become popular, called \u003ca href=\"https://www.haskell.org/\"\u003eHaskell\u003c/a\u003e, was created in 1990. So by the mid-1990s, the world of software development really had the solution to the vexing problems it still faces. Sadly, the hardware of the time often wasn’t powerful enough to make use of the solution. But today’s processors can easily manage the demands of Haskell and other purely functional languages.\u003c/p\u003e\n\u003cp\u003eIndeed, software based on pure functions is particularly well suited to modern \u003ca href=\"https://spectrum.ieee.org/the-trouble-with-multicore\"\u003emulticore CPUs\u003c/a\u003e. That’s because pure functions operate only on their input parameters, making it impossible to have any interactions between different functions. This allows the compiler to be optimized to produce code that runs on multiple cores efficiently and easily.\u003c/p\u003e\n\u003cp\u003eAs the name suggests, with purely functional programming, the developer can write only pure functions, which, by definition, cannot have side effects. With this one restriction, you increase stability, open the door to compiler optimizations, and end up with code that’s far easier to reason about.\u003c/p\u003e\n\u003cp\u003eBut what if a function needs to know or needs to manipulate the state of the system? In that case, the state is passed through a long chain of what are called composed functions—functions that pass their outputs to the inputs of the next function in the chain. By passing the state from function to function, each function has access to it and there’s no chance of another concurrent programming thread modifying that state—another common and costly fragility found in far too many programs.\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"avoiding-null-reference-surprises\"\u003eAvoiding Null-Reference Surprises\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#avoiding-null-reference-surprises\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eA comparison of Javascript and Purescript shows how the latter can help programmers avoid bugs.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/images/a-comparison-of-javascript-and-purescript-shows-how-the-latter-can-help-programmers-avoid-bugs.webp\"\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eFunctional programming also has a solution to Hoare’s “billion-dollar mistake,” null references. It addresses that problem by disallowing nulls. Instead, there is a construct usually called \u003cem\u003eMaybe\u003c/em\u003e (or \u003cem\u003eOption\u003c/em\u003e in some languages). A \u003cem\u003eMaybe\u003c/em\u003e can be \u003cem\u003eNothing\u003c/em\u003e or \u003cem\u003eJust\u003c/em\u003e some value. Working with \u003cem\u003eMaybe__s\u003c/em\u003e forces developers to always consider both cases. They have no choice in the matter. They must handle the \u003cem\u003eNothing\u003c/em\u003e case every single time they encounter a \u003cem\u003eMaybe\u003c/em\u003e. Doing so eliminates the many bugs that null references can spawn.\u003c/p\u003e\n\u003cp\u003eFunctional programming also requires that data be immutable, meaning that once you set a variable to some value, it is forever that value. Variables are more like variables in math. For example, to compute a formula, \u003cem\u003ey\u003c/em\u003e = \u003cem\u003ex_2 + 2_x\u003c/em\u003e – 11, you pick a value for \u003cem\u003ex\u003c/em\u003e and at no time during the computation of \u003cem\u003ey\u003c/em\u003e does \u003cem\u003ex\u003c/em\u003e take on a different value. So, the same value for \u003cem\u003ex\u003c/em\u003e is used when computing \u003cem\u003ex_2 as is used when computing 2_x\u003c/em\u003e. In most programming languages, there is no such restriction. You can compute \u003cem\u003ex_2 with one value, then change the value of _x\u003c/em\u003e before computing 2\u003cem\u003ex\u003c/em\u003e. By disallowing developers from changing (mutating) values, they can use the same reasoning they did in middle-school algebra class.\u003c/p\u003e\n\u003cp\u003eUnlike most languages, functional programming languages are deeply rooted in mathematics. It’s this lineage in the highly disciplined field of mathematics that gives functional languages their biggest advantages.\u003c/p\u003e\n\u003cp\u003eWhy is that? It’s because people have been working on mathematics for thousands of years. It’s pretty solid. Most programming paradigms, such as object-oriented programming, have at most half a dozen decades of work behind them. They are crude and immature by comparison.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eImagine if every time you ran your microwave, your dishwasher’s settings changed from Normal Cycle to Pots and Pans. In software, this kind of thing goes on all the time.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eLet me share an example of how programming is sloppy compared with mathematics. We typically teach new programmers to forget what they learned in math class when they first encounter the statement \u003cem\u003ex = x + 1\u003c/em\u003e. In math, this equation has zero solutions. But in most of today’s programming languages, \u003cem\u003ex = x + 1\u003c/em\u003e is not an equation. It is a \u003cem\u003estatement\u003c/em\u003e that commands the computer to take the value of \u003cem\u003ex\u003c/em\u003e, add one to it, and put it back into a variable called \u003cem\u003ex\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIn functional programming, there are no statements, only \u003cem\u003eexpressions\u003c/em\u003e.\u003c/strong\u003e Mathematical thinking that we learned in middle school can now be employed when writing code in a functional language.\u003c/p\u003e\n\u003cp\u003eThanks to functional purity, you can reason about code using algebraic substitution to help reduce code complexity in the same way you reduced the complexity of equations back in algebra class. In non-functional languages (imperative languages), there is no equivalent mechanism for reasoning about how the code works.\u003c/p\u003e\n\u003ch2 id=\"functional-programming-has-a-steep-learning-curve\"\u003eFunctional programming has a steep learning curve\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#functional-programming-has-a-steep-learning-curve\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003ePure functional programming solves many of our industry’s biggest problems by removing dangerous features from the language, making it harder for developers to shoot themselves in the foot. At first, these limitations may seem drastic, as I’m sure the 1960s developers felt regarding the removal of GOTO. But the fact of the matter is that it’s both liberating and empowering to work in these languages—so much so that nearly all of today’s most popular languages have incorporated functional features, although they remain fundamentally imperative languages.\u003c/p\u003e\n\u003cp\u003eThe biggest problem with this hybrid approach is that it still allows developers to ignore the functional aspects of the language. Had we left GOTO as an option 50 years ago, we might still be struggling with spaghetti code today.\u003c/p\u003e\n\u003cp\u003eTo reap the full benefits of pure functional programming languages, you can’t compromise. You need to use languages that were designed with these principles from the start. Only by adopting them will you get the many benefits that I’ve outlined here.\u003c/p\u003e\n\u003cp\u003eBut functional programming isn’t a bed of roses. It comes at a cost. Learning to program according to this functional paradigm is almost like learning to program again from the beginning. In many cases, developers must familiarize themselves with math that they didn’t learn in school. The required math isn’t difficult—it’s just new and, to the math phobic, scary.\u003c/p\u003e\n\u003cp\u003eMore important, developers need to learn a new way of thinking. At first this will be a burden, because they are not used to it. But with time, this new way of thinking becomes second nature and ends up reducing cognitive overhead compared with the old ways of thinking. The result is a massive gain in efficiency.\u003c/p\u003e\n\u003cp\u003eBut making the transition to functional programming can be difficult. My own journey doing so a few years back is illustrative.\u003c/p\u003e\n\u003cp\u003eI decided to learn Haskell—and needed to do that on a business timeline. This was the most difficult learning experience of my 40-year career, in large part because there was no definitive source for helping developers make the transition to functional programming. Indeed, no one had written anything very comprehensive about functional programming in the prior three decades.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTo reap the full benefits of pure functional programming languages, you can’t compromise. You need to use languages that were designed with these principles from the start.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI was left to pick up bits and pieces from here, there, and everywhere. And I can attest to the gross inefficiencies of that process. It took me three months of days, nights, and weekends living and breathing Haskell. But finally, I got to the point that I could write better code with it than with anything else.\u003c/p\u003e\n\u003cp\u003eWhen I decided that our company should switch to using functional languages, I didn’t want to put my developers through the same nightmare. So, I started building a curriculum for them to use, which became the basis for a book intended to help developers transition into functional programmers. In \u003ca href=\"https://leanpub.com/fp-made-easier\"\u003emy book\u003c/a\u003e, I provide guidance for obtaining proficiency in a functional language called \u003ca href=\"https://www.purescript.org/\"\u003ePureScript\u003c/a\u003e, which stole all the great aspects of Haskell and improved on many of its shortcomings. In addition, it’s able to operate in both the browser and in a back-end server, making it a great solution for many of today’s software demands.\u003c/p\u003e\n\u003cp\u003eWhile such learning resources can only help, for this transition to take place broadly, software-based businesses must invest more in their biggest asset: their developers. At my company, \u003ca href=\"http://www.panosoft.com/\"\u003ePanoramic Software\u003c/a\u003e, where I’m the chief technical officer, we’ve made this investment, and all new work is being done in either PureScript or Haskell.\u003c/p\u003e\n\u003cp\u003eWe started down the road of adopting functional languages three years ago, beginning with another pure functional language called \u003ca href=\"https://elm-lang.org/\"\u003eElm\u003c/a\u003e because it is a simpler language. (Little did we know we would eventually outgrow it.) It took us about a year to start reaping the benefits. But since we got over the hump, it’s been wonderful. We have had no production runtime bugs, which were so common in what we were formerly using, \u003ca href=\"https://en.wikipedia.org/wiki/JavaScript\"\u003eJavaScript\u003c/a\u003e on the front end and Java on the back. This improvement allowed the team to spend far more time adding new features to the system. Now, we spend almost no time debugging production issues.\u003c/p\u003e\n\u003cp\u003eBut there are still challenges when working with a language that relatively few others use—in particular, the lack of online help, documentation, and example code. And it’s hard to hire developers with experience in these languages. Because of that, my company uses recruiters who specialize in finding functional programmers. And when we hire someone with no background in functional programming, we put them through a training process for the first few months to bring them up to speed.\u003c/p\u003e\n\u003ch2 id=\"functional-programmings-future\"\u003eFunctional programming’s future\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#functional-programmings-future\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eMy company is small. It delivers software to governmental agencies to enable them to help veterans receive benefits from the \u003ca href=\"https://www.va.gov/\"\u003eU.S. Department of Veteran’s Affairs\u003c/a\u003e. It’s extremely rewarding work, but it’s not a lucrative field. With razor-slim margins, we must use every tool available to us to do more with fewer developers. And for that, functional programming is just the ticket.\u003c/p\u003e\n\u003cp\u003eIt’s very common for unglamorous businesses like ours to have difficulty attracting developers. But we are now able to hire top-tier people because they want to work on a functional codebase. Being ahead of the curve on this trend, we can get talent that most companies our size could only dream of.\u003c/p\u003e\n\u003cp\u003eI anticipate that the adoption of pure functional languages will improve the quality and robustness of the whole software industry while greatly reducing time wasted on bugs that are simply impossible to generate with functional programming. It’s not magic, but sometimes it feels like that, and I’m reminded of how good I have it every time I’m forced to work with a non-functional codebase.\u003c/p\u003e\n\u003cp\u003eOne sign that the software industry is preparing for a paradigm shift is that functional features are showing up in more and more mainstream languages. It will take much more work for the industry to make the transition fully, but the benefits of doing so are clear, and that is no doubt where things are headed.\u003c/p\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"0bqed1lx0c7hfr0txl97vrz"},"buildId":"vOE8u-mg___OsOsz4tjEg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>