<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>LiveView is best with Svelte</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="LiveView is best with Svelte"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/tknc9dx7peg9918ncq7by75/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="4/4/2024"/><meta property="article:modified_time" content="4/4/2024"/><link rel="canonical" href="https://luke-snaw.github.io//notes/tknc9dx7peg9918ncq7by75/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/wirstT2ztC8OQsbzKjhvw/_buildManifest.js" defer=""></script><script src="/_next/static/wirstT2ztC8OQsbzKjhvw/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="liveview-is-best-with-svelte">LiveView is best with Svelte<a aria-hidden="true" class="anchor-heading icon-link" href="#liveview-is-best-with-svelte"></a></h1>
<blockquote>
<p><a href="https://blog.sequin.io/liveview-is-best-with-svelte/">https://blog.sequin.io/liveview-is-best-with-svelte/</a></p>
<p>LiveView is a unique approach to building web applications that combines the benefits of server-rendered and client-side frameworks. While LiveView offers many advantages, the authors found some limitations around handling complex client-side interactions and the blurry line between client and server state. To address these challenges, the authors describe using LiveView together with the Svelte frontend framework, which they found to be a powerful and productive combination. The LiveView backend handles data fetching, validation, and state management, while the Svelte frontend focuses on rendering and simple event handling. This "LiveSvelte" approach eliminates the need for a separate frontend microservice and allows for a clean separation of concerns between the client and server.</p>
<blockquote>
<p>One possible solution which I didn't investigate, but should work, is to write all game logic in gleam (<a href="https://gleam.run/">https://gleam.run/</a>). Gleam is compatible with Elixir, AND it also can compile to js, so you could in theory run the same code on the server and the client. — <a href="https://news.ycombinator.com/item?id=39919223">POiNTx</a></p>
</blockquote>
</blockquote>
<p>Phoenix's <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html">LiveView</a> has polarized our team. Compared to SPA, there are components and features that we’re able to build 2-3x faster. Conversely, there are components and features that are frustrating to build or feel very counterintuitive.</p>
<p>Said another way, LiveView makes a lot of things easy. But it also makes some easy things hard.</p>
<p>This created tension. Do we keep forging down this path? Or do we give in and convert our app to a SPA?</p>
<p>Fortunately, we found a companion library called <a href="https://github.com/woutdp/live_svelte">LiveSvelte</a>. LiveView enables a development experience with Svelte that’s unlike any other fullstack paradigm I’ve used.</p>
<p>The team agrees: this is a killer way to build.</p>
<p>To appreciate the LiveView+Svelte paradigm, I’ll start by explaining how LiveView works and what makes it different. Then, I’ll detail the friction we encountered with a pure LiveView approach. At that point, you’ll be able to appreciate what LiveSvelte offers.</p>
<h2 id="what-is-liveview">What is LiveView<a aria-hidden="true" class="anchor-heading icon-link" href="#what-is-liveview"></a></h2>
<p>LiveView offers a very unique way to build web applications.</p>
<p>In a traditional server-rendered web application, the server is stateless. The client requests a page and the server renders it. All client actions route back to the server, which re-renders the next page.</p>
<p>In a SPA, the client is in charge of building pages. It leverages a backend API to read and write data. Client apps are stateful (e.g. <code>useState</code> in React).</p>
<p>In LiveView, the server is in charge of rendering the page. But it’s stateful. Actions in the frontend are handled by the backend, but the server <em>incrementally</em> updates the DOM, much like in a SPA.</p>
<p>At a high-level, the reason a SPA is complex is because distributed systems are complex. Supporting a client JS app is supporting a microservice (and one that runs in a hostile, untrusted environment, no less!)</p>
<p>In <em>theory</em> your frontend app uses a backend REST API that <em>could</em> be used to support lots of different services and clients. In reality, the needs of your frontend app are unique. So your backend routes and controllers explode with functions that serve the needs of a single client.</p>
<p>If nothing else, this complexity just means shaving a lot of yaks. Each request requires a fair bit of plumbing on both the frontend and the backend. Callstacks can easily exceed half a dozen layers:</p>
<ul>
<li><code>onMount</code></li>
<li><code>await api.fetchUsers</code></li>
<li><code>parseResponse</code></li>
<li><code>Router.handle(/api/users)</code></li>
<li><code>AuthPlug.verify_cookie</code></li>
<li><code>UsersController.index</code></li>
<li><code>Users.list_for_org</code></li>
<li><code>ApiHelpers.prepare_response</code></li>
</ul>
<p>The promise of LiveView is that you get to create rich client-side experiences without the frontend microservice. You're back to the much simpler world where you can query the database in the function adjacent to the function that renders your table rows. If a new row comes in, you just need to push it to your table, and LiveView will update the client for you.</p>
<p>But in addition, you also get to enjoy building an app using the stateful paradigm of frontend frameworks. It's much easier and faster to build rich interaction patterns this way vs prior backend paradigms where you'd need to "rebuild the world" on each request.</p>
<h2 id="where-liveview-makes-easy-things-hard">Where LiveView makes easy things hard<a aria-hidden="true" class="anchor-heading icon-link" href="#where-liveview-makes-easy-things-hard"></a></h2>
<p>There's a lot of good stuff in LiveView. But there are also real thorns.</p>
<p>There are two primary areas that we struggled with LiveView:</p>
<h3 id="client-side-state-is-inevitable">Client-side state is inevitable<a aria-hidden="true" class="anchor-heading icon-link" href="#client-side-state-is-inevitable"></a></h3>
<p>There is a (literal) speed of light limitation with this approach: your server can only be <em>so close</em> to your users.</p>
<p>Invariably, you’re going to need to do some stuff client-side. Animations, tooltips, showing/hiding DOM elements, disabling form fields, etc.</p>
<p>For example, there’s a form in our app with two interdependent dropdowns. Selecting an option in the first dropdown allows our server to generate the list for the second dropdown. To get the best UX, you want to disable the second dropdown immediately after the first dropdown changes. Then, when it’s repopulated by the server, you can re-enable it:</p>
<p><a href="https://blog.sequin.io/content/images/2024/03/CleanShot-2024-03-28-at-10.58.11-1.gif">Two dropdowns, the second is disabled after the first changes</a></p>
<p><em>Simulating 1000ms of roundtrip latency between the client and the server.</em></p>
<p>To pull this off, as far as we could tell, you need to use two independent concepts in LiveView:</p>
<ul>
<li>Use the <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html">JS module</a> to disable the second dropdown when the first dropdown changes.</li>
<li>Use a <a href="https://hexdocs.pm/phoenix_live_view/js-interop.html#client-hooks-via-phx-hook">hook</a> to register an event listener on the second dropdown. Then, send an action to re-enable the second dropdown from the backend.</li>
</ul>
<p>And for slightly more complex interaction patterns, you’ll need to incorporate a <em>third</em> concept, LiveView state. For example, maybe you only want to re-enable the second dropdown in certain conditions.</p>
<p>The way these three concepts fit together is not obvious (we’re still not sure this is the right pattern!)</p>
<p>So, while the server is in charge of a lot of DOM changes, it can’t command all of them. You use JS and hooks to sprinkle in JavaScript where needed. These tools feel side-chained to core LiveView, and therefore their patterns of use are not obvious. And the more JS and hooks you use, the more of your DOM state now exists <em>outside</em> of LiveView.</p>
<p>This is a stark contrast to a paradigm like React. In React, it’s state and actions all the way down. With that core concept, you can do most anything. And there is no blurry line between DOM state and component state.</p>
<p>React can take that approach because there’s no latency between client-side actions and client-side state. This means you can let React’s state paradigm handle every action and transition. Because all of LiveView’s state is server-side, it has to contend with the latency between client-side actions and server-side state. This means that while LiveView state <em>looks like</em> other frontend frameworks, the model is actually quite different.</p>
<p>Take input fields, for example. In React, a character can’t be inserted into an input field without routing through state. This unlocks a powerful programming model, where your component re-renders – and therefore responds – to every keystroke. It gives the state and action paradigm a lot of reach, where you can use one core concept (<code>useState</code>) to solve a huge space of problems.</p>
<p>In LiveView, it’s more accurate to say that the input field is changed by the user, <em>and then</em> a short while later LiveView finds out about it and reacts to it. With no latency, <em>it looks a lot like React</em>. But with increased latency, it’s quite a different paradigm.</p>
<p>In frontend frameworks like React, you need to contend with server-side latency all the time. But <em>when</em> a high-latency action is going to take place is clear (i.e. you’re fetching from a server). In LiveView, the boundary is murkier.</p>
<h3 id="three-components">Three components<a aria-hidden="true" class="anchor-heading icon-link" href="#three-components"></a></h3>
<p>LiveView has three different types of components: LiveViews, LiveComponents, and Components.</p>
<p>LiveViews and LiveComponents are like stateful components in React, whereas Components are like functional components.</p>
<p>Importantly, a LiveView will always be the uppermost parent component. You render LiveComponents and Components as children underneath a LiveView.</p>
<p>In React, it's easy to switch between stateful and functional components–just add or remove <code>useState</code> hooks. The API for both are the same (they both accept props in the same way). And outside state, they have an identical feature set. For example, they can both register and respond to DOM events in the same way.</p>
<p>The ease of switching between component types is important. As an app matures, you’re constantly factoring out components. You’re figuring out which bits should be reused, what should be generalized, where state should live, etc.</p>
<p>In LiveView, all three components are very different. As a result, refactoring a LiveView into a LiveComponent is surprisingly cumbersome.</p>
<p>In particular:</p>
<ul>
<li>The syntax for rendering and passing props to LiveViews and LiveComponents is different.</li>
<li>The lifecycle of LiveViews and LiveComponents are different.</li>
<li>The <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveComponent.html#module-unifying-liveview-and-livecomponent-communication">communication options</a> between LiveViews and LiveComponents are different. For example, you <code>send</code> to LiveViews but <code>send_update</code> to LiveComponents.</li>
<li>LiveComponents are not processes, and so can't interact with the rest of the system like LiveViews can.</li>
</ul>
<p>That last point is what makes LiveComponents so different and so frustrating. The limitations <em>make sense</em>: A LiveView is a process. That's one of the best parts about a LiveView, they're "just processes" and so they can fit into your Elixir/OTP system like every other process. For example, you can use pub/sub in a LiveView to subscribe to system-wide changes.</p>
<p>A LiveComponent is <em>not</em> its own process, they are modules invoked by a LiveView. The parent LiveView process holds the state for all subcomponents. So, a LiveView has a <code>pid</code>, state, and an inbox; a LiveComponent does not. This means the LiveView also has to handle all message routing for its child LiveComponents.</p>
<p>This is in keeping with Elixir/OTP design principles: processes are the building blocks. To give LiveComponents the same powers of independent state management and action handling, they would each need to be their own process.</p>
<p>Still, for the life of me, I <em>really</em> struggled with LiveComponents. So often, I wanted to send my LiveComponent an event/action but didn't have a good way to do it. You end up using <code>send_update</code>, which is an awkward API. We couldn't decide: do we send <em>actions</em> via <code>send_update</code>, or do we use it to patch state? If we use it to patch state, how do we tell in our <code>update</code> clause whether we're mounting or updating?</p>
<h2 id="the-elusive-liveview-way">The elusive “LiveView way”<a aria-hidden="true" class="anchor-heading icon-link" href="#the-elusive-liveview-way"></a></h2>
<p>LiveView often made us feel like we were “missing something.” The “LiveView way” feels elusive.</p>
<p>Perhaps LiveView is in an uncanny valley. It shares a lot in common with contemporary frontend frameworks. So, our “React brains” and intuitions would kick in, driving us to use old patterns–but those would often lead to a dead end. More alienness would have forced us to recognize the differences and to approach problems differently.</p>
<p>You can do a lot with just LiveView state and actions. But there are limits, and when you hit them you need to switch paradigms.</p>
<p>It has components to help you organize and reuse code. But due to differences between JavaScript and Elixir, LiveView can’t really offer the same isomorphic component trees without a ton of abstraction, and so has LiveViews and LiveComponents.</p>
<p><strong>This is what makes LiveSvelte so promising</strong>. As you’ll see, it shifts more responsibility to the frontend. It embraces the fact that the frontend will have its own state. And it lets you take advantage of all the maturity of contemporary JavaScript component frameworks.</p>
<h2 id="liveview--svelte">LiveView + Svelte<a aria-hidden="true" class="anchor-heading icon-link" href="#liveview--svelte"></a></h2>
<p>LiveSvelte lets you render Svelte components from LiveView. It's an awesome paradigm.</p>
<p>There’s a couple different ways to render Svelte from your LiveViews, but the most basic way looks like this:</p>
<pre class="language-elixir"><code class="language-elixir"><span class="token comment"># LiveView component</span>
<span class="token keyword">defmodule</span> <span class="token module class-name">Web</span><span class="token punctuation">.</span><span class="token module class-name">SyncLive</span><span class="token punctuation">.</span><span class="token module class-name">Form</span> <span class="token keyword">do</span>
  <span class="token keyword">def</span> <span class="token function">render</span><span class="token punctuation">(</span>assigns<span class="token punctuation">)</span> <span class="token keyword">do</span>
    assigns <span class="token operator">=</span>
      assigns
      <span class="token operator">|></span> <span class="token module class-name">Map</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token atom symbol">:encoded_collections</span><span class="token punctuation">,</span> <span class="token module class-name">Enum</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>assigns<span class="token punctuation">.</span>collections<span class="token punctuation">,</span> <span class="token operator">&#x26;</span><span class="token function">encode_collection</span><span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token operator">|></span> <span class="token module class-name">Map</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token atom symbol">:encoded_errors</span><span class="token punctuation">,</span> <span class="token function">encode_errors</span><span class="token punctuation">(</span>assigns<span class="token punctuation">.</span>changeset<span class="token punctuation">)</span><span class="token punctuation">)</span>

    ~<span class="token module class-name">H</span><span class="token string">"""
      &#x3C;.svelte
        name="MyForm"
        props={
          %{
            collections: @encoded_collections,
            credential_options: @credential_options,
            errors: @encoded_errors,
          }
        }
        socket={@socket}
      />
    """</span>
  <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre>
<p>This is an Elixir module, the LiveView. Inside the render, we first take our Elixir data structures and encode them for the frontend. We like the pattern of explicitly encoding Elixir structs and such as plain maps before passing to Svelte, like this:</p>
<pre class="language-elixir"><code class="language-elixir">  <span class="token keyword">defp</span> <span class="token function">encode_collection</span><span class="token punctuation">(</span><span class="token punctuation">%</span><span class="token module class-name">Collection</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> collection<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token punctuation">%</span><span class="token punctuation">{</span>
      <span class="token string">"id"</span> <span class="token operator">=></span> collection<span class="token punctuation">.</span>id<span class="token punctuation">,</span>
      <span class="token string">"slug"</span> <span class="token operator">=></span> collection<span class="token punctuation">.</span>slug<span class="token punctuation">,</span>
      <span class="token string">"name"</span> <span class="token operator">=></span> collection<span class="token punctuation">.</span>name
    <span class="token punctuation">}</span>
  <span class="token keyword">end</span>
</code></pre>
<p>We’re able to set props on the Svelte component. Those are passed down as you’d expect to the component:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">// Svelte component</span>
<span class="token operator">&#x3C;</span>script<span class="token operator">></span>
  <span class="token keyword module">export</span> <span class="token keyword">let</span> resource<span class="token punctuation">;</span> <span class="token keyword module">export</span> <span class="token keyword">let</span> credential_options <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword module">export</span> <span class="token keyword">let</span> errors <span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword module">export</span> <span class="token keyword">let</span> live<span class="token punctuation">;</span>
<span class="token operator">&#x3C;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>One of the props that LiveSvelte sets for us is the <code>live</code> prop. To communicate from the Svelte component back up to the LiveView, we can call <code>live.pushEvent</code>. For example, check how easy it is to send the server changes to the form:</p>
<pre class="language-js"><code class="language-js"><span class="token operator">&#x3C;</span>script<span class="token operator">></span>
  <span class="token comment">// ...</span>
  $<span class="token operator">:</span> <span class="token punctuation">{</span>
    live<span class="token punctuation">.</span><span class="token method function property-access">pushEvent</span><span class="token punctuation">(</span><span class="token string">"form_updated"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> form <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token operator">&#x3C;</span><span class="token operator">/</span>script<span class="token operator">></span>
</code></pre>
<p>This is a reactive block in Svelte. It will be executed whenever the variable <code>form</code> is changed. (Kind of like a <code>useEffect</code>, where <code>form</code> is the dependency.)</p>
<p>The LiveView can handle and respond to the <code>pushEvent</code> using typical Elixir message handling semantics:</p>
<pre class="language-elixir"><code class="language-elixir"><span class="token comment"># In the LiveView</span>
<span class="token comment"># ...</span>
  <span class="token attribute variable">@impl</span> <span class="token module class-name">LiveView</span>
  <span class="token keyword">def</span> <span class="token function">handle_event</span><span class="token punctuation">(</span><span class="token string">"form_updated"</span><span class="token punctuation">,</span> <span class="token punctuation">%</span><span class="token punctuation">{</span><span class="token string">"form"</span> <span class="token operator">=></span> form<span class="token punctuation">}</span><span class="token punctuation">,</span> socket<span class="token punctuation">)</span> <span class="token keyword">do</span>
    params <span class="token operator">=</span> <span class="token function">decode_params</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> form<span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token atom symbol">:noreply</span><span class="token punctuation">,</span> <span class="token function">merge_changeset</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">}</span>
  <span class="token keyword">end</span>

  <span class="token keyword">defp</span> <span class="token function">merge_changeset</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> params<span class="token punctuation">)</span> <span class="token keyword">do</span>
    changeset <span class="token operator">=</span> <span class="token module class-name">Collection</span><span class="token punctuation">.</span><span class="token function">create_changeset</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span>assigns<span class="token punctuation">.</span>resource<span class="token punctuation">,</span> params<span class="token punctuation">)</span>

    <span class="token function">assign</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> <span class="token atom symbol">:changeset</span><span class="token punctuation">,</span> changeset<span class="token punctuation">)</span>
  <span class="token keyword">end</span>
</code></pre>
<p>We first decode the params from the frontend, reversing any encoding/mapping we did on the way out. Then, <code>merge_changeset/2</code> updates our changeset. If there are any validation errors in the changeset, those will make their way back to the frontend via the <code>errors</code> prop.</p>
<p>So, you have data flow from Elixir down to the component via props. The LiveView process can update props at any time to cause the Svelte component to re-render. Any other communication can happen via the websocket.</p>
<p>The boundary between the two is very clear–just as clear as in any SPA.</p>
<p>What's most game-changing, though, is that you have a <em>backend, stateful process</em> that is collaborating with a <em>frontend, stateful process</em>.</p>
<p>And it's <em>so</em> fun and productive.</p>
<p>The three powerhouse properties:</p>
<ol>
<li>The backend controls the props on the frontend component.</li>
<li>The frontend <em>and</em> the backend are stateful.</li>
<li>You have a private, bi-directional communication channel between the two <em>where either side can initiate a message to the other</em>.</li>
</ol>
<p>#1 is made possible thanks to LiveView’s rendering paradigm: re-renders on the server are automatically pushed and applied to the client. This lets the server update props on the component just like a JS parent component can!</p>
<p>#2 is possible because a LiveView is a process. Processes are how Elixir encapsulates and reduces state.</p>
<p>#3 is made possible by the persistent websocket that LiveView gives you, wired to the frontend.</p>
<p>Consider the differences between this paradigm and a SPA:</p>
<p>First, all browser routing happens via the backend. This is a great simplifier. (In a regular SPA you have to maintain <em>two</em> sets of routes, one for the browser and one for your API.)</p>
<p>Second, the backend is stateful. It knows what route you’re on. Which resource you’re working with. Each action it handles can be far more incremental, as it’s applying a state change to itself vs rebuilding state from scratch.</p>
<p>Third, communication between the frontend and backend is private and coupled, as it should be. You’re not “polluting” your server’s public routes with a bunch of RPC calls that support a single component. When you see a <code>pushEvent</code> in the client, you know exactly where the handler for that is – in the collaborating Elixir module.</p>
<p>Fourth, functionality is split across just two files. Sure, the backend module will call out to your backend functions (e.g. fetch data from database) and the frontend will import components and styles. But roundtrips between the two aren’t routing through a stack of API modules, routers, and controllers.</p>
<p>Fifth, communication between frontend and backend is far less ceremonious. The backend can simply update props to inform frontend changes. And the frontend can <code>pushEvent</code> without needing handlers for expired tokens, timeouts, or outages. It’s binary: either the websocket is open which means the server is open for business, or it’s not in which case LiveView helpfully shows the user a global “disconnected” banner.</p>
<p>In the simplest terms, the frontend microservice is eliminated.</p>
<p>What you end up with feels like such a great split of responsibilities with very little boilerplate. All your business logic is on the backend – how you load data, <em>which</em> data to load, how to sort and filter the data, your validators, etc. Your frontend code is stupid simple. In Svelte, it’s all (1) <code>if/end</code> blocks to conditionally render stuff (2) animations and (3) a few dead simple <code>pushEvent</code> functions back to the server.</p>
<p>That last part has been blowing my mind. The typical SPA frontend is full of so much logic, usually <code>map</code>, <code>reduce</code>, and <code>filter</code> in order to process server data, prepare data for display, or prepare data for the server. In a LiveSvelte app, all this can just happen server-side. The LiveView can prepare data exactly as the Svelte component needs it. This keeps complexity in your server language, in your server's data structures, and in your server's test suite.</p>
<p>The backend LiveView and the frontend Svelte component aren't so much coupled as they are two halves: the LiveView only renders that Svelte component, and that Svelte component is only ever rendered by that LiveView.</p>
<p>In contrast to a “regular” LiveView, this paradigm:</p>
<ul>
<li>Embraces state and state transitions in the frontend.</li>
<li>Creates a clear boundary layer between the frontend and backend.</li>
<li>Leverages Svelte’s component paradigm, which like other contemporary JS frameworks is very mature and familiar.</li>
<li>In general, lets great frontend frameworks do what they do best! A pure LiveView approach doesn’t let you tap into this huge ecosystem. (For example, Svelte comes with great animation primitives.)</li>
</ul>
<p>By moving more into the frontend, we no longer felt like we were straddling an awkward middleground.</p>
<p>We chose LiveSvelte because React didn't have a similarly complete LiveView library. The joy of working with Svelte has been a very happy bonus. Because LiveView does the heavy lifting with state management, our state management in Svelte is very simple. For basic state and reactivity, Svelte is the lightest and fastest frontend framework I've worked with. We also prefer its templating features to React's, namely getting to use <code>if/else</code> instead of ternary operators and its conditional property setting.</p>
<p>Further, Svelte 5 is around the corner, and we're bullish on its <a href="https://svelte.dev/blog/runes">runes</a>. We think it makes Svelte even easier to pick up and reason about, meaning everyone on the team is empowered to traverse the stack.</p>
<p>I’m now convinced LiveView shines brightest as a backend-for-frontend. By rendering frontend components, incrementally updating them, maintaining a stateful backend process, and providing a websocket API, it creates a tremendously productive platform for frontend applications.</p>
<p>If you’re using LiveView and resonated with any of the friction I highlighted, you need to give this a try. If you’ve never used LiveView, you’ll find that this paradigm <em>lowers</em> the learning curve. This is because you’re able to use a lot of the JavaScript framework primitives you’re used to.</p>
<hr>
<h2 id="q">Q<a aria-hidden="true" class="anchor-heading icon-link" href="#q"></a></h2>
<p><a href="https://news.ycombinator.com/item?id=39917878">So instead of managing state on the client, you manage state on the client and the server? That doesn't seem like an improvement, even if it saves you from having to build yet another API.</a></p>
<h3 id="a">A<a aria-hidden="true" class="anchor-heading icon-link" href="#a"></a></h3>
<blockquote>
<p><a href="https://news.ycombinator.com/item?id=39918962">https://news.ycombinator.com/item?id=39918962</a></p>
</blockquote>
<p>It's never that simple. In web applications there's always these types of states:</p>
<pre><code>    * States that the client needs to keep track of
    * States that the server needs to keep track of
</code></pre>
<p>Then on top of those there's two more kinds of states that overlap but they're not quite the same thing:</p>
<pre><code>    * States that only need to exist in memory (i.e. transient)
    * States that need to persist between sessions
</code></pre>
<p>There's a seemingly infinite number of ways to manage these things and because "there's no correct way to do anything in JavaScript" you either use a framework's chosen way to deal with them or you do it on an ad-hoc basis (aka "chaos" haha).</p>
<p>In the last sophisticated SPA I wrote I had it perform a sync whenever the client loaded the page. Every local state or asset had a datetime-based hash associated with it and if it didn't match what was on the server the server would send down an updated version (of whatever that thing was; whether it be simple variables, a huge JSON object, or whole images/audio blobs).</p>
<p>Whenever the client did something that required a change in state on the server it would send an update of that state over a WebSocket (99% of the app was WebSocket stuff). I didn't use any sort of sophisticated framework or pattern: If I was writing the code and thought, "the server needs to keep track of this" I'd have it send a message to the server with the new state and it would be up to the server whether or not that state should be synchronized on page load.</p>
<p>IMHO, that's about as simple a mechanism as you can get for managing this sort of thing. WebSockets are a godsend for managing state.</p></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#what-is-liveview" title="What is LiveView">What is LiveView</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#where-liveview-makes-easy-things-hard" title="Where LiveView makes easy things hard">Where LiveView makes easy things hard</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#client-side-state-is-inevitable" title="Client-side state is inevitable">Client-side state is inevitable</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#three-components" title="Three components">Three components</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-elusive-liveview-way" title="The elusive “LiveView way”">The elusive “LiveView way”</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#liveview--svelte" title="LiveView + Svelte">LiveView + Svelte</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#q" title="Q">Q</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#a" title="A">A</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"tknc9dx7peg9918ncq7by75","title":"LiveView is best with Svelte","desc":"","updated":1712213318441,"created":1712213040611,"custom":{},"fname":"javascript.tools.liveview-is-best-with-svelte","type":"note","vault":{"fsPath":"vault"},"contentHash":"b6113131b5487089b9019d4f9df8d3a7","links":[],"anchors":{"what-is-liveview":{"type":"header","text":"What is LiveView","value":"what-is-liveview","line":26,"column":0,"depth":2},"where-liveview-makes-easy-things-hard":{"type":"header","text":"Where LiveView makes easy things hard","value":"where-liveview-makes-easy-things-hard","line":55,"column":0,"depth":2},"client-side-state-is-inevitable":{"type":"header","text":"Client-side state is inevitable","value":"client-side-state-is-inevitable","line":61,"column":0,"depth":3},"three-components":{"type":"header","text":"Three components","value":"three-components","line":94,"column":0,"depth":3},"the-elusive-liveview-way":{"type":"header","text":"The elusive “LiveView way”","value":"the-elusive-liveview-way","line":123,"column":0,"depth":2},"liveview--svelte":{"type":"header","text":"LiveView + Svelte","value":"liveview--svelte","line":135,"column":0,"depth":2},"q":{"type":"header","text":"Q","value":"q","line":281,"column":0,"depth":2},"a":{"type":"header","text":"A","value":"a","line":285,"column":0,"depth":3}},"children":[],"parent":"tllrjmr18kywydgaov3qlyw","data":{}},"body":"\u003ch1 id=\"liveview-is-best-with-svelte\"\u003eLiveView is best with Svelte\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#liveview-is-best-with-svelte\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://blog.sequin.io/liveview-is-best-with-svelte/\"\u003ehttps://blog.sequin.io/liveview-is-best-with-svelte/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eLiveView is a unique approach to building web applications that combines the benefits of server-rendered and client-side frameworks. While LiveView offers many advantages, the authors found some limitations around handling complex client-side interactions and the blurry line between client and server state. To address these challenges, the authors describe using LiveView together with the Svelte frontend framework, which they found to be a powerful and productive combination. The LiveView backend handles data fetching, validation, and state management, while the Svelte frontend focuses on rendering and simple event handling. This \"LiveSvelte\" approach eliminates the need for a separate frontend microservice and allows for a clean separation of concerns between the client and server.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eOne possible solution which I didn't investigate, but should work, is to write all game logic in gleam (\u003ca href=\"https://gleam.run/\"\u003ehttps://gleam.run/\u003c/a\u003e). Gleam is compatible with Elixir, AND it also can compile to js, so you could in theory run the same code on the server and the client. — \u003ca href=\"https://news.ycombinator.com/item?id=39919223\"\u003ePOiNTx\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePhoenix's \u003ca href=\"https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html\"\u003eLiveView\u003c/a\u003e has polarized our team. Compared to SPA, there are components and features that we’re able to build 2-3x faster. Conversely, there are components and features that are frustrating to build or feel very counterintuitive.\u003c/p\u003e\n\u003cp\u003eSaid another way, LiveView makes a lot of things easy. But it also makes some easy things hard.\u003c/p\u003e\n\u003cp\u003eThis created tension. Do we keep forging down this path? Or do we give in and convert our app to a SPA?\u003c/p\u003e\n\u003cp\u003eFortunately, we found a companion library called \u003ca href=\"https://github.com/woutdp/live_svelte\"\u003eLiveSvelte\u003c/a\u003e. LiveView enables a development experience with Svelte that’s unlike any other fullstack paradigm I’ve used.\u003c/p\u003e\n\u003cp\u003eThe team agrees: this is a killer way to build.\u003c/p\u003e\n\u003cp\u003eTo appreciate the LiveView+Svelte paradigm, I’ll start by explaining how LiveView works and what makes it different. Then, I’ll detail the friction we encountered with a pure LiveView approach. At that point, you’ll be able to appreciate what LiveSvelte offers.\u003c/p\u003e\n\u003ch2 id=\"what-is-liveview\"\u003eWhat is LiveView\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#what-is-liveview\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLiveView offers a very unique way to build web applications.\u003c/p\u003e\n\u003cp\u003eIn a traditional server-rendered web application, the server is stateless. The client requests a page and the server renders it. All client actions route back to the server, which re-renders the next page.\u003c/p\u003e\n\u003cp\u003eIn a SPA, the client is in charge of building pages. It leverages a backend API to read and write data. Client apps are stateful (e.g. \u003ccode\u003euseState\u003c/code\u003e in React).\u003c/p\u003e\n\u003cp\u003eIn LiveView, the server is in charge of rendering the page. But it’s stateful. Actions in the frontend are handled by the backend, but the server \u003cem\u003eincrementally\u003c/em\u003e updates the DOM, much like in a SPA.\u003c/p\u003e\n\u003cp\u003eAt a high-level, the reason a SPA is complex is because distributed systems are complex. Supporting a client JS app is supporting a microservice (and one that runs in a hostile, untrusted environment, no less!)\u003c/p\u003e\n\u003cp\u003eIn \u003cem\u003etheory\u003c/em\u003e your frontend app uses a backend REST API that \u003cem\u003ecould\u003c/em\u003e be used to support lots of different services and clients. In reality, the needs of your frontend app are unique. So your backend routes and controllers explode with functions that serve the needs of a single client.\u003c/p\u003e\n\u003cp\u003eIf nothing else, this complexity just means shaving a lot of yaks. Each request requires a fair bit of plumbing on both the frontend and the backend. Callstacks can easily exceed half a dozen layers:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eonMount\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eawait api.fetchUsers\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparseResponse\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRouter.handle(/api/users)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAuthPlug.verify_cookie\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUsersController.index\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUsers.list_for_org\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eApiHelpers.prepare_response\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe promise of LiveView is that you get to create rich client-side experiences without the frontend microservice. You're back to the much simpler world where you can query the database in the function adjacent to the function that renders your table rows. If a new row comes in, you just need to push it to your table, and LiveView will update the client for you.\u003c/p\u003e\n\u003cp\u003eBut in addition, you also get to enjoy building an app using the stateful paradigm of frontend frameworks. It's much easier and faster to build rich interaction patterns this way vs prior backend paradigms where you'd need to \"rebuild the world\" on each request.\u003c/p\u003e\n\u003ch2 id=\"where-liveview-makes-easy-things-hard\"\u003eWhere LiveView makes easy things hard\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#where-liveview-makes-easy-things-hard\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThere's a lot of good stuff in LiveView. But there are also real thorns.\u003c/p\u003e\n\u003cp\u003eThere are two primary areas that we struggled with LiveView:\u003c/p\u003e\n\u003ch3 id=\"client-side-state-is-inevitable\"\u003eClient-side state is inevitable\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#client-side-state-is-inevitable\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eThere is a (literal) speed of light limitation with this approach: your server can only be \u003cem\u003eso close\u003c/em\u003e to your users.\u003c/p\u003e\n\u003cp\u003eInvariably, you’re going to need to do some stuff client-side. Animations, tooltips, showing/hiding DOM elements, disabling form fields, etc.\u003c/p\u003e\n\u003cp\u003eFor example, there’s a form in our app with two interdependent dropdowns. Selecting an option in the first dropdown allows our server to generate the list for the second dropdown. To get the best UX, you want to disable the second dropdown immediately after the first dropdown changes. Then, when it’s repopulated by the server, you can re-enable it:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://blog.sequin.io/content/images/2024/03/CleanShot-2024-03-28-at-10.58.11-1.gif\"\u003eTwo dropdowns, the second is disabled after the first changes\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSimulating 1000ms of roundtrip latency between the client and the server.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eTo pull this off, as far as we could tell, you need to use two independent concepts in LiveView:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUse the \u003ca href=\"https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html\"\u003eJS module\u003c/a\u003e to disable the second dropdown when the first dropdown changes.\u003c/li\u003e\n\u003cli\u003eUse a \u003ca href=\"https://hexdocs.pm/phoenix_live_view/js-interop.html#client-hooks-via-phx-hook\"\u003ehook\u003c/a\u003e to register an event listener on the second dropdown. Then, send an action to re-enable the second dropdown from the backend.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd for slightly more complex interaction patterns, you’ll need to incorporate a \u003cem\u003ethird\u003c/em\u003e concept, LiveView state. For example, maybe you only want to re-enable the second dropdown in certain conditions.\u003c/p\u003e\n\u003cp\u003eThe way these three concepts fit together is not obvious (we’re still not sure this is the right pattern!)\u003c/p\u003e\n\u003cp\u003eSo, while the server is in charge of a lot of DOM changes, it can’t command all of them. You use JS and hooks to sprinkle in JavaScript where needed. These tools feel side-chained to core LiveView, and therefore their patterns of use are not obvious. And the more JS and hooks you use, the more of your DOM state now exists \u003cem\u003eoutside\u003c/em\u003e of LiveView.\u003c/p\u003e\n\u003cp\u003eThis is a stark contrast to a paradigm like React. In React, it’s state and actions all the way down. With that core concept, you can do most anything. And there is no blurry line between DOM state and component state.\u003c/p\u003e\n\u003cp\u003eReact can take that approach because there’s no latency between client-side actions and client-side state. This means you can let React’s state paradigm handle every action and transition. Because all of LiveView’s state is server-side, it has to contend with the latency between client-side actions and server-side state. This means that while LiveView state \u003cem\u003elooks like\u003c/em\u003e other frontend frameworks, the model is actually quite different.\u003c/p\u003e\n\u003cp\u003eTake input fields, for example. In React, a character can’t be inserted into an input field without routing through state. This unlocks a powerful programming model, where your component re-renders – and therefore responds – to every keystroke. It gives the state and action paradigm a lot of reach, where you can use one core concept (\u003ccode\u003euseState\u003c/code\u003e) to solve a huge space of problems.\u003c/p\u003e\n\u003cp\u003eIn LiveView, it’s more accurate to say that the input field is changed by the user, \u003cem\u003eand then\u003c/em\u003e a short while later LiveView finds out about it and reacts to it. With no latency, \u003cem\u003eit looks a lot like React\u003c/em\u003e. But with increased latency, it’s quite a different paradigm.\u003c/p\u003e\n\u003cp\u003eIn frontend frameworks like React, you need to contend with server-side latency all the time. But \u003cem\u003ewhen\u003c/em\u003e a high-latency action is going to take place is clear (i.e. you’re fetching from a server). In LiveView, the boundary is murkier.\u003c/p\u003e\n\u003ch3 id=\"three-components\"\u003eThree components\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#three-components\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eLiveView has three different types of components: LiveViews, LiveComponents, and Components.\u003c/p\u003e\n\u003cp\u003eLiveViews and LiveComponents are like stateful components in React, whereas Components are like functional components.\u003c/p\u003e\n\u003cp\u003eImportantly, a LiveView will always be the uppermost parent component. You render LiveComponents and Components as children underneath a LiveView.\u003c/p\u003e\n\u003cp\u003eIn React, it's easy to switch between stateful and functional components–just add or remove \u003ccode\u003euseState\u003c/code\u003e hooks. The API for both are the same (they both accept props in the same way). And outside state, they have an identical feature set. For example, they can both register and respond to DOM events in the same way.\u003c/p\u003e\n\u003cp\u003eThe ease of switching between component types is important. As an app matures, you’re constantly factoring out components. You’re figuring out which bits should be reused, what should be generalized, where state should live, etc.\u003c/p\u003e\n\u003cp\u003eIn LiveView, all three components are very different. As a result, refactoring a LiveView into a LiveComponent is surprisingly cumbersome.\u003c/p\u003e\n\u003cp\u003eIn particular:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe syntax for rendering and passing props to LiveViews and LiveComponents is different.\u003c/li\u003e\n\u003cli\u003eThe lifecycle of LiveViews and LiveComponents are different.\u003c/li\u003e\n\u003cli\u003eThe \u003ca href=\"https://hexdocs.pm/phoenix_live_view/Phoenix.LiveComponent.html#module-unifying-liveview-and-livecomponent-communication\"\u003ecommunication options\u003c/a\u003e between LiveViews and LiveComponents are different. For example, you \u003ccode\u003esend\u003c/code\u003e to LiveViews but \u003ccode\u003esend_update\u003c/code\u003e to LiveComponents.\u003c/li\u003e\n\u003cli\u003eLiveComponents are not processes, and so can't interact with the rest of the system like LiveViews can.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat last point is what makes LiveComponents so different and so frustrating. The limitations \u003cem\u003emake sense\u003c/em\u003e: A LiveView is a process. That's one of the best parts about a LiveView, they're \"just processes\" and so they can fit into your Elixir/OTP system like every other process. For example, you can use pub/sub in a LiveView to subscribe to system-wide changes.\u003c/p\u003e\n\u003cp\u003eA LiveComponent is \u003cem\u003enot\u003c/em\u003e its own process, they are modules invoked by a LiveView. The parent LiveView process holds the state for all subcomponents. So, a LiveView has a \u003ccode\u003epid\u003c/code\u003e, state, and an inbox; a LiveComponent does not. This means the LiveView also has to handle all message routing for its child LiveComponents.\u003c/p\u003e\n\u003cp\u003eThis is in keeping with Elixir/OTP design principles: processes are the building blocks. To give LiveComponents the same powers of independent state management and action handling, they would each need to be their own process.\u003c/p\u003e\n\u003cp\u003eStill, for the life of me, I \u003cem\u003ereally\u003c/em\u003e struggled with LiveComponents. So often, I wanted to send my LiveComponent an event/action but didn't have a good way to do it. You end up using \u003ccode\u003esend_update\u003c/code\u003e, which is an awkward API. We couldn't decide: do we send \u003cem\u003eactions\u003c/em\u003e via \u003ccode\u003esend_update\u003c/code\u003e, or do we use it to patch state? If we use it to patch state, how do we tell in our \u003ccode\u003eupdate\u003c/code\u003e clause whether we're mounting or updating?\u003c/p\u003e\n\u003ch2 id=\"the-elusive-liveview-way\"\u003eThe elusive “LiveView way”\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-elusive-liveview-way\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLiveView often made us feel like we were “missing something.” The “LiveView way” feels elusive.\u003c/p\u003e\n\u003cp\u003ePerhaps LiveView is in an uncanny valley. It shares a lot in common with contemporary frontend frameworks. So, our “React brains” and intuitions would kick in, driving us to use old patterns–but those would often lead to a dead end. More alienness would have forced us to recognize the differences and to approach problems differently.\u003c/p\u003e\n\u003cp\u003eYou can do a lot with just LiveView state and actions. But there are limits, and when you hit them you need to switch paradigms.\u003c/p\u003e\n\u003cp\u003eIt has components to help you organize and reuse code. But due to differences between JavaScript and Elixir, LiveView can’t really offer the same isomorphic component trees without a ton of abstraction, and so has LiveViews and LiveComponents.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThis is what makes LiveSvelte so promising\u003c/strong\u003e. As you’ll see, it shifts more responsibility to the frontend. It embraces the fact that the frontend will have its own state. And it lets you take advantage of all the maturity of contemporary JavaScript component frameworks.\u003c/p\u003e\n\u003ch2 id=\"liveview--svelte\"\u003eLiveView + Svelte\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#liveview--svelte\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eLiveSvelte lets you render Svelte components from LiveView. It's an awesome paradigm.\u003c/p\u003e\n\u003cp\u003eThere’s a couple different ways to render Svelte from your LiveViews, but the most basic way looks like this:\u003c/p\u003e\n\u003cpre class=\"language-elixir\"\u003e\u003ccode class=\"language-elixir\"\u003e\u003cspan class=\"token comment\"\u003e# LiveView component\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003edefmodule\u003c/span\u003e \u003cspan class=\"token module class-name\"\u003eWeb\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token module class-name\"\u003eSyncLive\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token module class-name\"\u003eForm\u003c/span\u003e \u003cspan class=\"token keyword\"\u003edo\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"token function\"\u003erender\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eassigns\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003edo\u003c/span\u003e\n    assigns \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\n      assigns\n      \u003cspan class=\"token operator\"\u003e|\u003e\u003c/span\u003e \u003cspan class=\"token module class-name\"\u003eMap\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eput\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token atom symbol\"\u003e:encoded_collections\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token module class-name\"\u003eEnum\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003emap\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eassigns\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003ecollections\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token operator\"\u003e\u0026#x26;\u003c/span\u003e\u003cspan class=\"token function\"\u003eencode_collection\u003c/span\u003e\u003cspan class=\"token operator\"\u003e/\u003c/span\u003e\u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n      \u003cspan class=\"token operator\"\u003e|\u003e\u003c/span\u003e \u003cspan class=\"token module class-name\"\u003eMap\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eput\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token atom symbol\"\u003e:encoded_errors\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token function\"\u003eencode_errors\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eassigns\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003echangeset\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\n    ~\u003cspan class=\"token module class-name\"\u003eH\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"\"\"\n      \u0026#x3C;.svelte\n        name=\"MyForm\"\n        props={\n          %{\n            collections: @encoded_collections,\n            credential_options: @credential_options,\n            errors: @encoded_errors,\n          }\n        }\n        socket={@socket}\n      /\u003e\n    \"\"\"\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003eend\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is an Elixir module, the LiveView. Inside the render, we first take our Elixir data structures and encode them for the frontend. We like the pattern of explicitly encoding Elixir structs and such as plain maps before passing to Svelte, like this:\u003c/p\u003e\n\u003cpre class=\"language-elixir\"\u003e\u003ccode class=\"language-elixir\"\u003e  \u003cspan class=\"token keyword\"\u003edefp\u003c/span\u003e \u003cspan class=\"token function\"\u003eencode_collection\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e%\u003c/span\u003e\u003cspan class=\"token module class-name\"\u003eCollection\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e collection\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003edo\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e%\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e\"id\"\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003e\u003c/span\u003e collection\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eid\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e\"slug\"\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003e\u003c/span\u003e collection\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eslug\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token string\"\u003e\"name\"\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003e\u003c/span\u003e collection\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003ename\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe’re able to set props on the Svelte component. Those are passed down as you’d expect to the component:\u003c/p\u003e\n\u003cpre class=\"language-js\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"token comment\"\u003e// Svelte component\u003c/span\u003e\n\u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003escript\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"token keyword module\"\u003eexport\u003c/span\u003e \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e resource\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e \u003cspan class=\"token keyword module\"\u003eexport\u003c/span\u003e \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e credential_options \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e \u003cspan class=\"token keyword module\"\u003eexport\u003c/span\u003e \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e errors \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"token keyword module\"\u003eexport\u003c/span\u003e \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e live\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token operator\"\u003e/\u003c/span\u003escript\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne of the props that LiveSvelte sets for us is the \u003ccode\u003elive\u003c/code\u003e prop. To communicate from the Svelte component back up to the LiveView, we can call \u003ccode\u003elive.pushEvent\u003c/code\u003e. For example, check how easy it is to send the server changes to the form:\u003c/p\u003e\n\u003cpre class=\"language-js\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003escript\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// ...\u003c/span\u003e\n  $\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    live\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token method function property-access\"\u003epushEvent\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"form_updated\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e form \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token arrow operator\"\u003e=\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token operator\"\u003e/\u003c/span\u003escript\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is a reactive block in Svelte. It will be executed whenever the variable \u003ccode\u003eform\u003c/code\u003e is changed. (Kind of like a \u003ccode\u003euseEffect\u003c/code\u003e, where \u003ccode\u003eform\u003c/code\u003e is the dependency.)\u003c/p\u003e\n\u003cp\u003eThe LiveView can handle and respond to the \u003ccode\u003epushEvent\u003c/code\u003e using typical Elixir message handling semantics:\u003c/p\u003e\n\u003cpre class=\"language-elixir\"\u003e\u003ccode class=\"language-elixir\"\u003e\u003cspan class=\"token comment\"\u003e# In the LiveView\u003c/span\u003e\n\u003cspan class=\"token comment\"\u003e# ...\u003c/span\u003e\n  \u003cspan class=\"token attribute variable\"\u003e@impl\u003c/span\u003e \u003cspan class=\"token module class-name\"\u003eLiveView\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"token function\"\u003ehandle_event\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"form_updated\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e%\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"form\"\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003e\u003c/span\u003e form\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e socket\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003edo\u003c/span\u003e\n    params \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003edecode_params\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esocket\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e form\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token atom symbol\"\u003e:noreply\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token function\"\u003emerge_changeset\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esocket\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e params\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003eend\u003c/span\u003e\n\n  \u003cspan class=\"token keyword\"\u003edefp\u003c/span\u003e \u003cspan class=\"token function\"\u003emerge_changeset\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esocket\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e params\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003edo\u003c/span\u003e\n    changeset \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token module class-name\"\u003eCollection\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ecreate_changeset\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esocket\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eassigns\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eresource\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e params\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\n    \u003cspan class=\"token function\"\u003eassign\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esocket\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token atom symbol\"\u003e:changeset\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e changeset\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe first decode the params from the frontend, reversing any encoding/mapping we did on the way out. Then, \u003ccode\u003emerge_changeset/2\u003c/code\u003e updates our changeset. If there are any validation errors in the changeset, those will make their way back to the frontend via the \u003ccode\u003eerrors\u003c/code\u003e prop.\u003c/p\u003e\n\u003cp\u003eSo, you have data flow from Elixir down to the component via props. The LiveView process can update props at any time to cause the Svelte component to re-render. Any other communication can happen via the websocket.\u003c/p\u003e\n\u003cp\u003eThe boundary between the two is very clear–just as clear as in any SPA.\u003c/p\u003e\n\u003cp\u003eWhat's most game-changing, though, is that you have a \u003cem\u003ebackend, stateful process\u003c/em\u003e that is collaborating with a \u003cem\u003efrontend, stateful process\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAnd it's \u003cem\u003eso\u003c/em\u003e fun and productive.\u003c/p\u003e\n\u003cp\u003eThe three powerhouse properties:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe backend controls the props on the frontend component.\u003c/li\u003e\n\u003cli\u003eThe frontend \u003cem\u003eand\u003c/em\u003e the backend are stateful.\u003c/li\u003e\n\u003cli\u003eYou have a private, bi-directional communication channel between the two \u003cem\u003ewhere either side can initiate a message to the other\u003c/em\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e#1 is made possible thanks to LiveView’s rendering paradigm: re-renders on the server are automatically pushed and applied to the client. This lets the server update props on the component just like a JS parent component can!\u003c/p\u003e\n\u003cp\u003e#2 is possible because a LiveView is a process. Processes are how Elixir encapsulates and reduces state.\u003c/p\u003e\n\u003cp\u003e#3 is made possible by the persistent websocket that LiveView gives you, wired to the frontend.\u003c/p\u003e\n\u003cp\u003eConsider the differences between this paradigm and a SPA:\u003c/p\u003e\n\u003cp\u003eFirst, all browser routing happens via the backend. This is a great simplifier. (In a regular SPA you have to maintain \u003cem\u003etwo\u003c/em\u003e sets of routes, one for the browser and one for your API.)\u003c/p\u003e\n\u003cp\u003eSecond, the backend is stateful. It knows what route you’re on. Which resource you’re working with. Each action it handles can be far more incremental, as it’s applying a state change to itself vs rebuilding state from scratch.\u003c/p\u003e\n\u003cp\u003eThird, communication between the frontend and backend is private and coupled, as it should be. You’re not “polluting” your server’s public routes with a bunch of RPC calls that support a single component. When you see a \u003ccode\u003epushEvent\u003c/code\u003e in the client, you know exactly where the handler for that is – in the collaborating Elixir module.\u003c/p\u003e\n\u003cp\u003eFourth, functionality is split across just two files. Sure, the backend module will call out to your backend functions (e.g. fetch data from database) and the frontend will import components and styles. But roundtrips between the two aren’t routing through a stack of API modules, routers, and controllers.\u003c/p\u003e\n\u003cp\u003eFifth, communication between frontend and backend is far less ceremonious. The backend can simply update props to inform frontend changes. And the frontend can \u003ccode\u003epushEvent\u003c/code\u003e without needing handlers for expired tokens, timeouts, or outages. It’s binary: either the websocket is open which means the server is open for business, or it’s not in which case LiveView helpfully shows the user a global “disconnected” banner.\u003c/p\u003e\n\u003cp\u003eIn the simplest terms, the frontend microservice is eliminated.\u003c/p\u003e\n\u003cp\u003eWhat you end up with feels like such a great split of responsibilities with very little boilerplate. All your business logic is on the backend – how you load data, \u003cem\u003ewhich\u003c/em\u003e data to load, how to sort and filter the data, your validators, etc. Your frontend code is stupid simple. In Svelte, it’s all (1) \u003ccode\u003eif/end\u003c/code\u003e blocks to conditionally render stuff (2) animations and (3) a few dead simple \u003ccode\u003epushEvent\u003c/code\u003e functions back to the server.\u003c/p\u003e\n\u003cp\u003eThat last part has been blowing my mind. The typical SPA frontend is full of so much logic, usually \u003ccode\u003emap\u003c/code\u003e, \u003ccode\u003ereduce\u003c/code\u003e, and \u003ccode\u003efilter\u003c/code\u003e in order to process server data, prepare data for display, or prepare data for the server. In a LiveSvelte app, all this can just happen server-side. The LiveView can prepare data exactly as the Svelte component needs it. This keeps complexity in your server language, in your server's data structures, and in your server's test suite.\u003c/p\u003e\n\u003cp\u003eThe backend LiveView and the frontend Svelte component aren't so much coupled as they are two halves: the LiveView only renders that Svelte component, and that Svelte component is only ever rendered by that LiveView.\u003c/p\u003e\n\u003cp\u003eIn contrast to a “regular” LiveView, this paradigm:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEmbraces state and state transitions in the frontend.\u003c/li\u003e\n\u003cli\u003eCreates a clear boundary layer between the frontend and backend.\u003c/li\u003e\n\u003cli\u003eLeverages Svelte’s component paradigm, which like other contemporary JS frameworks is very mature and familiar.\u003c/li\u003e\n\u003cli\u003eIn general, lets great frontend frameworks do what they do best! A pure LiveView approach doesn’t let you tap into this huge ecosystem. (For example, Svelte comes with great animation primitives.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBy moving more into the frontend, we no longer felt like we were straddling an awkward middleground.\u003c/p\u003e\n\u003cp\u003eWe chose LiveSvelte because React didn't have a similarly complete LiveView library. The joy of working with Svelte has been a very happy bonus. Because LiveView does the heavy lifting with state management, our state management in Svelte is very simple. For basic state and reactivity, Svelte is the lightest and fastest frontend framework I've worked with. We also prefer its templating features to React's, namely getting to use \u003ccode\u003eif/else\u003c/code\u003e instead of ternary operators and its conditional property setting.\u003c/p\u003e\n\u003cp\u003eFurther, Svelte 5 is around the corner, and we're bullish on its \u003ca href=\"https://svelte.dev/blog/runes\"\u003erunes\u003c/a\u003e. We think it makes Svelte even easier to pick up and reason about, meaning everyone on the team is empowered to traverse the stack.\u003c/p\u003e\n\u003cp\u003eI’m now convinced LiveView shines brightest as a backend-for-frontend. By rendering frontend components, incrementally updating them, maintaining a stateful backend process, and providing a websocket API, it creates a tremendously productive platform for frontend applications.\u003c/p\u003e\n\u003cp\u003eIf you’re using LiveView and resonated with any of the friction I highlighted, you need to give this a try. If you’ve never used LiveView, you’ll find that this paradigm \u003cem\u003elowers\u003c/em\u003e the learning curve. This is because you’re able to use a lot of the JavaScript framework primitives you’re used to.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"q\"\u003eQ\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#q\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://news.ycombinator.com/item?id=39917878\"\u003eSo instead of managing state on the client, you manage state on the client and the server? That doesn't seem like an improvement, even if it saves you from having to build yet another API.\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"a\"\u003eA\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#a\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://news.ycombinator.com/item?id=39918962\"\u003ehttps://news.ycombinator.com/item?id=39918962\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIt's never that simple. In web applications there's always these types of states:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    * States that the client needs to keep track of\n    * States that the server needs to keep track of\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen on top of those there's two more kinds of states that overlap but they're not quite the same thing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    * States that only need to exist in memory (i.e. transient)\n    * States that need to persist between sessions\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere's a seemingly infinite number of ways to manage these things and because \"there's no correct way to do anything in JavaScript\" you either use a framework's chosen way to deal with them or you do it on an ad-hoc basis (aka \"chaos\" haha).\u003c/p\u003e\n\u003cp\u003eIn the last sophisticated SPA I wrote I had it perform a sync whenever the client loaded the page. Every local state or asset had a datetime-based hash associated with it and if it didn't match what was on the server the server would send down an updated version (of whatever that thing was; whether it be simple variables, a huge JSON object, or whole images/audio blobs).\u003c/p\u003e\n\u003cp\u003eWhenever the client did something that required a change in state on the server it would send an update of that state over a WebSocket (99% of the app was WebSocket stuff). I didn't use any sort of sophisticated framework or pattern: If I was writing the code and thought, \"the server needs to keep track of this\" I'd have it send a message to the server with the new state and it would be up to the server whether or not that state should be synchronized on page load.\u003c/p\u003e\n\u003cp\u003eIMHO, that's about as simple a mechanism as you can get for managing this sort of thing. WebSockets are a godsend for managing state.\u003c/p\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1766965759366,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"a724de3efd251cf89fe82a5860d9008b","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":43,"column":5,"offset":2710},"end":{"line":43,"column":29,"offset":2734},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2026.articles","alias":"What I read in 2026","position":{"start":{"line":72,"column":3,"offset":4440},"end":{"line":72,"column":45,"offset":4482},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2026.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2025.articles","alias":"2025","position":{"start":{"line":73,"column":5,"offset":4487},"end":{"line":73,"column":32,"offset":4514},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2025.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2024.articles","alias":"2024","position":{"start":{"line":74,"column":5,"offset":4519},"end":{"line":74,"column":32,"offset":4546},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2024.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2023.articles","alias":"2023","position":{"start":{"line":75,"column":5,"offset":4551},"end":{"line":75,"column":32,"offset":4578},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2023.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2022.articles","alias":"2022","position":{"start":{"line":76,"column":5,"offset":4583},"end":{"line":76,"column":32,"offset":4610},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2022.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":82,"column":3,"offset":4746},"end":{"line":82,"column":39,"offset":4782},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":76,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","o7xruzrah5wzqetottecss7","z1zo2mp6ddji5p317i4x9xw","v06c2tjelh341x4resa50fh","0yqesk4rcffwgyuab5x8rfa","sy2vkbtyu671chkvgn1yt8j","ufixpmxoydiccoh59kphrib","alswadkx4wb05y1z9iwfzfv","1daut9dpw70xd0zh5a7j5p4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 현실은 인간의 연산으로 완전히 파악할 수 없는 복잡계. 주어진 상황과 능력으로 할 수 있는 최선의 적응은 단순함과 꾸준함.\n\n  - 파산을 면하는 선에서 여러가지를 해보고 자신에게 맞는 걸 위주로 꾸준히. 그를 위해 단순, 편안, 쾌적함이 필요.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2026|read.2026.articles]]\n  - [[2025|read.2025.articles]]\n  - [[2024|read.2024.articles]]\n  - [[2023|read.2023.articles]]\n  - [[2022|read.2022.articles]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"tknc9dx7peg9918ncq7by75"},"buildId":"wirstT2ztC8OQsbzKjhvw","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>