<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Coroutines and effects</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Coroutines and effects"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/wjsyv41pykk19dxjviwj6rm/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="4/22/2024"/><meta property="article:modified_time" content="4/22/2024"/><link rel="canonical" href="https://luke-snaw.github.io//notes/wjsyv41pykk19dxjviwj6rm/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_buildManifest.js" defer=""></script><script src="/_next/static/vOE8u-mg___OsOsz4tjEg/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="coroutines-and-effects">Coroutines and effects<a aria-hidden="true" class="anchor-heading icon-link" href="#coroutines-and-effects"></a></h1>
<blockquote>
<p><a href="https://without.boats/blog/coroutines-and-effects/">https://without.boats/blog/coroutines-and-effects/</a></p>
<p>The passage discusses the relationship between effect systems and coroutines. It explains that effect systems, like those found in languages like Koka, and coroutines, like Rust's async functions, are in some ways isomorphic to each other. The key difference is that coroutines yield control to their caller, while effectful expressions in effect systems yield control to their handler. The author argues that coroutines strike a good balance, as they are statically typed, lexically scoped, and unlayered, making them a promising approach for handling effectful functions. The passage also contrasts effect systems with Rust's use of the Result type and async/await syntax to model effects.</p>
</blockquote>
<p>For the past few months I’ve been mulling over some things that Russell Johnston made me realize about the relationship between effect systems and coroutines. You can read more of his thoughts on this subject <a href="https://www.abubalay.com/blog/2024/01/14/rust-effect-lowering">here</a>, but he made me realize that effect systems (like that found in Koka) and coroutines (like Rust’s async functions or generators) are in some ways isomorphic to one another. I’ve been pondering the differences between them, trying to figuring out the advantages and disadvantages of each.</p>
<p>A few weeks ago, Will Crichton posted something on <a href="https://twitter.com/tonofcrates/status/1770560175835058573">Twitter</a> that helped bring the contrast into sharper focus for me:</p>
<blockquote>
<p>The entire field of PL right now: what if it was dynamically scoped…. but statically typed…………..? (effects, capabilities, contexts, metavariables…)</p>
</blockquote>
<p>I’m just a humble language designer (and not a theorist of anything, especially not PL), so my focus is the difference in user experience and affordance. But this seems like a cutting insight and this property of effect handlers - static typing but dynamic scoping - seems to me to be a good jumping off point for understanding the difference between effect handlers and coroutines from a user perspective.</p>
<h2 id="background">Background<a aria-hidden="true" class="anchor-heading icon-link" href="#background"></a></h2>
<h3 id="what-is-a-coroutine">What is a coroutine?<a aria-hidden="true" class="anchor-heading icon-link" href="#what-is-a-coroutine"></a></h3>
<p>A coroutine is a function which can yield control back to its caller before finishing. The caller then has a reference to the state of the coroutine when it yielded, so it can resume the coroutine again if it so chooses. It’s possible to model many meaningful “effects” using coroutines by having the coroutine yield. For example:</p>
<ul>
<li>A coroutine can perform IO “asynchronously,” by yielding a value like <code>Pending</code> when IO is being performed.</li>
<li>A coroutine can be iterable by yielding values as it traverses some collection.</li>
<li>A coroutine can model exceptions by yielding an exception value (in this case, resuming the coroutine would have no effect).</li>
</ul>
<p>Rust, for example, models both asynchrony and iteration using coroutines. On the other hand, exceptions are not modeled this way; instead they are modeled with the <code>Result</code> type. Specifically, Rust uses “stackless” coroutines, but this distinction is not very important to the concepts in this post.</p>
<h3 id="what-is-an-effect-handler">What is an effect handler?<a aria-hidden="true" class="anchor-heading icon-link" href="#what-is-an-effect-handler"></a></h3>
<p>I need to be clear, because terminology has become muddied in the Rust community: this post has nothing in particular to do with “effects generics” as conceptualized by the Rust project, which is a different set semantic features related to how Rust handles effects from “effects systems” as they appear in the literature. In this post, I am focused on effect systems as proposed in languages like <a href="https://koka-lang.github.io/koka/doc/index.html">Koka</a> and <a href="https://effekt-lang.org/">Effekt</a>. And my understanding of these systems may be imperfect or wrong, but this is how they operate as I understand them.</p>
<p>In an effect system, in addition to a type, an expression will have an <em>effect</em>. An effect is an additional “kind” in the formal, type system sense of the word (in the same way that lifetimes are another “kind” in Rust). In general, expressions inherit the effects of other expressions they contain. Functions inherit the effects of their body.</p>
<p>For example, Koka has a “diverging” effect, which means that an expression may diverge (that is to say, it may not finish evaluating). An expression containing a diverging expression is also diverging. So you can distinguish in the type system between a function that is guaranteed to finish and a function that may not finish (this is imperfect, of course, because of the undecidability of the halting problem; some functions that do not diverge will be marked diverging).</p>
<p>However, these languages also have a concept of <em>effect handlers</em>, which take an expression with an effect and “handle” it, producing an expression without that effect. Not all effects can be handled (for example, as far as I understand it is not possible to meaningfully handle the diverging effect), but some can. The semantics of what it means to handle an effect are where effect systems become similar to coroutines.</p>
<p>When a handleable effect occurs, an effectful expression yields control to the nearest-most handler of that effect, which may or may not yield control back. This can be used to model all of the same sorts of effects as coroutines. For example:</p>
<ul>
<li>An IO effect can yield control to the IO handler, which will yield back to the expression when IO is complete.</li>
<li>An iterable effect can yield control to the loop consumer for each value, which yields back to the iterable to continue iteration.</li>
<li>An exception effect can yield control to an exception handler, which will not yield control back.</li>
</ul>
<h2 id="the-difference-is-between-static-and-dynamic-scope">The difference is between static and dynamic scope<a aria-hidden="true" class="anchor-heading icon-link" href="#the-difference-is-between-static-and-dynamic-scope"></a></h2>
<p>The key difference between coroutines and effect handlers is that coroutines yield control to their caller, but effectful expressions yield control to their handler. The difference of affordance this implies is the materially significant advantage of coroutines over effect handlers.</p>
<p>Let’s imagine a programming language in which every function is a coroutine which can yield <code>Pending</code> or an exception (to model both IO and exceptions) and there are multiple kind of call operators that “handle effects” differently:</p>
<ul>
<li>There is an ordinary call operator that can only be used on coroutines that never yield (these coroutines are effectively pure functions)</li>
<li>There is an asynchronous <code>().await</code> call operator that can be called on coroutines that yield <code>Pending</code>, which yields <code>Pending</code> and then calls them again (so it can only be called from within another coroutine that yields <code>Pending</code>)</li>
<li>There is an exception-throwing <code>()?</code> call operator that can be called on coroutines that yield an exception, which yields the exception outward.</li>
<li>There is a combined <code>().await?</code> call operator that can be called on coroutines that yield <code>Pending</code> and exceptions, to forward both effects.</li>
</ul>
<p>Let’s suppose you wanted to do an HTTP request in this language (which performs IO and can also raise an exception representing some sort of IO error):</p>
<pre class="language-fallback"><code class="language-fallback">fn get_blog() -> HttpResponse yields (Pending | Exception) {
    http::get("https://without.boats").await?
}
</code></pre>
<p>Now, let’s contrast this to a similar language which models IO and exceptions using effects. In this language, there is no need for special call operators: a function which has an IO or exception effect can call functions which also have IO or exception effects:</p>
<pre class="language-fallback"><code class="language-fallback">fn get_blog() -> HttpResponse effect (IO | Exception) {
    http::get("https://without.boats")
}
</code></pre>
<p>The difference between these features is that the call to <code>http::get</code> must be annotated with the <code>await</code> and <code>?</code> syntax to forward its effects, whereas with effect handlers the forwarding of effects by a callee is implicit.</p>
<p>I want to take one more step back and then I promise I will reach a conclusion. There are definitions of coroutines other than the one I gave, especially older ones. If you were to closely read <a href="https://en.wikipedia.org/wiki/Coroutine">Wikipedia</a>, you would find a slightly different definition, and what I’ve called coroutines are addressed instead as “generators” or “semicoroutines.” In the older definition, a coroutine can specify where it yields control. This is actually based on a model of program execution in which there is no program stack: instead, every coroutine is a global singleton, and yielding control to it means continuing it wherever it last left off. For semicoroutines, in contrast, calling a coroutine produces a new stack frame which can only be resumed by code with a reference to that stack frame.</p>
<p>The program stack is such a universal model of program execution today that we treat it as inevitable, but like everything else it had to be invented. It was invented to support recursive function definition, but it has other advantages in the way that it enables local reasoning: from the body of a function, there is exactly one dynamic jump point - wherever it returns to. From the point of view of the caller, this is now statically known: the function will jump back to the point at which it is called.</p>
<p>This rule can only be violated when a language introduces new features that allow additional dynamic jump points. One that has long been popular is the notion of exceptions, which unwind the call stack to the point at which they are being handled. There are two kinds of exceptions: unchecked exceptions, which are totally untyped, and checked exceptions, which require an annotations on any function which could throw them.</p>
<p><strong>Effect handlers are a generalization of checked exceptions</strong>, with all of the pros and cons of that feature. They require you to annotate functions that have an effect, but they do not require you to annotate <em>calls</em> at which the effect can occur. Therefore, when examining the body of a function, to understand when the effect occurs requires examining the type signature of every function that is called. Since this is meaningful control flow, it seems very valuable to be able to identify points at which an error occurs without examining the signatures of each function call. This is why Rust features <code>Result</code> and the <code>?</code> operator instead of checked exceptions.</p>
<p>There’s an axis of evaluation here with three points: a language could model an effect in a way which is totally unchecked at compile time: both dynamically typed and dynamically scoped. Unchecked exceptions (including panics) are an example of this; so is blocking IO. And a language could model the effect in the type system, but with a dynamic scope. Checked exceptions and effect handlers are both examples of this. And a language could model the effect in a way which is both statically typed and lexically scoped. This is what Rust does for these effects with both <code>Result</code> and <code>async/await</code>.</p>
<p>(You may notice that there’s a fourth spot in the design space not covered here: dynamically typed and lexically scoped. An example in this category would be the async/await feature in dynamically typed languages like Python and JavaScript; you must annotate asynchronous calls with <code>await</code> to get their result, but if you fail to do so it is not a compile-time error.)</p>
<pre class="language-fallback"><code class="language-fallback">                                          │   EXCEPTIONS          │   IO
──────────────────────────────────────────┼───────────────────────┼───────────────
                                          │                       │
  DYNAMICALLY TYPED &#x26; DYNAMICALLY SCOPED  │   panicking           │   blocking
                                          │                       │
   STATICALLY TYPED &#x26; DYNAMICALLY SCOPED  │   checked exceptions  │   IO effect
                                          │                       │
     STATICALLY TYPED &#x26; LEXICALLY SCOPED  │   Result              │   async/await
                                          │                       │
</code></pre>
<p>These are not the only language features that can be used to model effects, and other features also fall into one of these buckets. For example, monads are also statically typed and lexically scoped. However, a major objection to monads is that they model effects in a specifically layered way, so that for example there is a distinction between an <code>IO&#x3C;Result&#x3C;T, E>></code> and a <code>Result&#x3C;IO&#x3C;T>, E></code>. Coroutines on the other hand are order-independent: all coroutine that yield <code>Pending</code> and <code>Exception</code> have the same type, there is no distinction of order. The same is true of effect handlers.</p>
<p>This has appeared in Rust for example with the debate about the design of <a href="https://without.boats/blog/poll-next">async iterators</a>. Designs based on <code>async fn next</code> introduce an arbitrary ordering by introducing multiple coroutines, whereas designed based on a single coroutine do not make a distinction; the coroutine just yields items as well as <code>Pending</code>. This was the crux of Russell Johnston’s argument in the post I linked earlier: this unlayered property is shared by coroutines and effect handlers, and is an advantage of these features.</p>
<p>On the other hand, by modeling errors with <code>Result</code> instead of some sort of coroutine, Rust <em>does</em> introduce an ordering. This is mostly fine because of the fact that a function which “throws an exception” (by evaluating to an <code>Err</code>) is not supposed to be resumed, though it introduces some quirks where for example there’s no way to distinguish between an iterator of <code>Result</code>s (which may continue after one is an <code>Err</code>) and an iterator which throws an error (which will not continue). If instead a generator could “yield an exception,” it would be a different type from a generator that yields a sequence of <code>Result</code>s. But I don’t find this inadequacy to come up in practice that often, so I’m content to leave it as theoretical work for a future language to solve.</p>
<p>Overall, coroutines strike me as the most promising way to handle many kinds of effectful functions because they seem to be in the design sweet spot: They are statically typed, lexically scoped, and unlayered. This is why my starting point for handling effects in any language would be a coroutine feature (though if the language were not under Rust’s constraints, I would prefer if it were a stackful coroutine feature so they could be recursive).</p></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#background" title="Background">Background</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#what-is-a-coroutine" title="What is a coroutine?">What is a coroutine?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#what-is-an-effect-handler" title="What is an effect handler?">What is an effect handler?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#the-difference-is-between-static-and-dynamic-scope" title="The difference is between static and dynamic scope">The difference is between static and dynamic scope</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"wjsyv41pykk19dxjviwj6rm","title":"Coroutines and effects","desc":"","updated":1713771160739,"created":1713771107487,"custom":{},"fname":"dev.program-languages.coroutines-and-effects","type":"note","vault":{"fsPath":"vault"},"contentHash":"c18bb6d13837dbc50f984ee479b9e138","links":[],"anchors":{"background":{"type":"header","text":"Background","value":"background","line":20,"column":0,"depth":2},"what-is-a-coroutine":{"type":"header","text":"What is a coroutine?","value":"what-is-a-coroutine","line":22,"column":0,"depth":3},"what-is-an-effect-handler":{"type":"header","text":"What is an effect handler?","value":"what-is-an-effect-handler","line":32,"column":0,"depth":3},"the-difference-is-between-static-and-dynamic-scope":{"type":"header","text":"The difference is between static and dynamic scope","value":"the-difference-is-between-static-and-dynamic-scope","line":48,"column":0,"depth":2}},"children":[],"parent":"cnzc1i8ojequt9lhg3zpkgo","data":{}},"body":"\u003ch1 id=\"coroutines-and-effects\"\u003eCoroutines and effects\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#coroutines-and-effects\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://without.boats/blog/coroutines-and-effects/\"\u003ehttps://without.boats/blog/coroutines-and-effects/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eThe passage discusses the relationship between effect systems and coroutines. It explains that effect systems, like those found in languages like Koka, and coroutines, like Rust's async functions, are in some ways isomorphic to each other. The key difference is that coroutines yield control to their caller, while effectful expressions in effect systems yield control to their handler. The author argues that coroutines strike a good balance, as they are statically typed, lexically scoped, and unlayered, making them a promising approach for handling effectful functions. The passage also contrasts effect systems with Rust's use of the Result type and async/await syntax to model effects.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eFor the past few months I’ve been mulling over some things that Russell Johnston made me realize about the relationship between effect systems and coroutines. You can read more of his thoughts on this subject \u003ca href=\"https://www.abubalay.com/blog/2024/01/14/rust-effect-lowering\"\u003ehere\u003c/a\u003e, but he made me realize that effect systems (like that found in Koka) and coroutines (like Rust’s async functions or generators) are in some ways isomorphic to one another. I’ve been pondering the differences between them, trying to figuring out the advantages and disadvantages of each.\u003c/p\u003e\n\u003cp\u003eA few weeks ago, Will Crichton posted something on \u003ca href=\"https://twitter.com/tonofcrates/status/1770560175835058573\"\u003eTwitter\u003c/a\u003e that helped bring the contrast into sharper focus for me:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe entire field of PL right now: what if it was dynamically scoped…. but statically typed…………..? (effects, capabilities, contexts, metavariables…)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eI’m just a humble language designer (and not a theorist of anything, especially not PL), so my focus is the difference in user experience and affordance. But this seems like a cutting insight and this property of effect handlers - static typing but dynamic scoping - seems to me to be a good jumping off point for understanding the difference between effect handlers and coroutines from a user perspective.\u003c/p\u003e\n\u003ch2 id=\"background\"\u003eBackground\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#background\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003ch3 id=\"what-is-a-coroutine\"\u003eWhat is a coroutine?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#what-is-a-coroutine\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eA coroutine is a function which can yield control back to its caller before finishing. The caller then has a reference to the state of the coroutine when it yielded, so it can resume the coroutine again if it so chooses. It’s possible to model many meaningful “effects” using coroutines by having the coroutine yield. For example:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA coroutine can perform IO “asynchronously,” by yielding a value like \u003ccode\u003ePending\u003c/code\u003e when IO is being performed.\u003c/li\u003e\n\u003cli\u003eA coroutine can be iterable by yielding values as it traverses some collection.\u003c/li\u003e\n\u003cli\u003eA coroutine can model exceptions by yielding an exception value (in this case, resuming the coroutine would have no effect).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRust, for example, models both asynchrony and iteration using coroutines. On the other hand, exceptions are not modeled this way; instead they are modeled with the \u003ccode\u003eResult\u003c/code\u003e type. Specifically, Rust uses “stackless” coroutines, but this distinction is not very important to the concepts in this post.\u003c/p\u003e\n\u003ch3 id=\"what-is-an-effect-handler\"\u003eWhat is an effect handler?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#what-is-an-effect-handler\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eI need to be clear, because terminology has become muddied in the Rust community: this post has nothing in particular to do with “effects generics” as conceptualized by the Rust project, which is a different set semantic features related to how Rust handles effects from “effects systems” as they appear in the literature. In this post, I am focused on effect systems as proposed in languages like \u003ca href=\"https://koka-lang.github.io/koka/doc/index.html\"\u003eKoka\u003c/a\u003e and \u003ca href=\"https://effekt-lang.org/\"\u003eEffekt\u003c/a\u003e. And my understanding of these systems may be imperfect or wrong, but this is how they operate as I understand them.\u003c/p\u003e\n\u003cp\u003eIn an effect system, in addition to a type, an expression will have an \u003cem\u003eeffect\u003c/em\u003e. An effect is an additional “kind” in the formal, type system sense of the word (in the same way that lifetimes are another “kind” in Rust). In general, expressions inherit the effects of other expressions they contain. Functions inherit the effects of their body.\u003c/p\u003e\n\u003cp\u003eFor example, Koka has a “diverging” effect, which means that an expression may diverge (that is to say, it may not finish evaluating). An expression containing a diverging expression is also diverging. So you can distinguish in the type system between a function that is guaranteed to finish and a function that may not finish (this is imperfect, of course, because of the undecidability of the halting problem; some functions that do not diverge will be marked diverging).\u003c/p\u003e\n\u003cp\u003eHowever, these languages also have a concept of \u003cem\u003eeffect handlers\u003c/em\u003e, which take an expression with an effect and “handle” it, producing an expression without that effect. Not all effects can be handled (for example, as far as I understand it is not possible to meaningfully handle the diverging effect), but some can. The semantics of what it means to handle an effect are where effect systems become similar to coroutines.\u003c/p\u003e\n\u003cp\u003eWhen a handleable effect occurs, an effectful expression yields control to the nearest-most handler of that effect, which may or may not yield control back. This can be used to model all of the same sorts of effects as coroutines. For example:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAn IO effect can yield control to the IO handler, which will yield back to the expression when IO is complete.\u003c/li\u003e\n\u003cli\u003eAn iterable effect can yield control to the loop consumer for each value, which yields back to the iterable to continue iteration.\u003c/li\u003e\n\u003cli\u003eAn exception effect can yield control to an exception handler, which will not yield control back.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"the-difference-is-between-static-and-dynamic-scope\"\u003eThe difference is between static and dynamic scope\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-difference-is-between-static-and-dynamic-scope\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eThe key difference between coroutines and effect handlers is that coroutines yield control to their caller, but effectful expressions yield control to their handler. The difference of affordance this implies is the materially significant advantage of coroutines over effect handlers.\u003c/p\u003e\n\u003cp\u003eLet’s imagine a programming language in which every function is a coroutine which can yield \u003ccode\u003ePending\u003c/code\u003e or an exception (to model both IO and exceptions) and there are multiple kind of call operators that “handle effects” differently:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThere is an ordinary call operator that can only be used on coroutines that never yield (these coroutines are effectively pure functions)\u003c/li\u003e\n\u003cli\u003eThere is an asynchronous \u003ccode\u003e().await\u003c/code\u003e call operator that can be called on coroutines that yield \u003ccode\u003ePending\u003c/code\u003e, which yields \u003ccode\u003ePending\u003c/code\u003e and then calls them again (so it can only be called from within another coroutine that yields \u003ccode\u003ePending\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eThere is an exception-throwing \u003ccode\u003e()?\u003c/code\u003e call operator that can be called on coroutines that yield an exception, which yields the exception outward.\u003c/li\u003e\n\u003cli\u003eThere is a combined \u003ccode\u003e().await?\u003c/code\u003e call operator that can be called on coroutines that yield \u003ccode\u003ePending\u003c/code\u003e and exceptions, to forward both effects.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet’s suppose you wanted to do an HTTP request in this language (which performs IO and can also raise an exception representing some sort of IO error):\u003c/p\u003e\n\u003cpre class=\"language-fallback\"\u003e\u003ccode class=\"language-fallback\"\u003efn get_blog() -\u003e HttpResponse yields (Pending | Exception) {\n    http::get(\"https://without.boats\").await?\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, let’s contrast this to a similar language which models IO and exceptions using effects. In this language, there is no need for special call operators: a function which has an IO or exception effect can call functions which also have IO or exception effects:\u003c/p\u003e\n\u003cpre class=\"language-fallback\"\u003e\u003ccode class=\"language-fallback\"\u003efn get_blog() -\u003e HttpResponse effect (IO | Exception) {\n    http::get(\"https://without.boats\")\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe difference between these features is that the call to \u003ccode\u003ehttp::get\u003c/code\u003e must be annotated with the \u003ccode\u003eawait\u003c/code\u003e and \u003ccode\u003e?\u003c/code\u003e syntax to forward its effects, whereas with effect handlers the forwarding of effects by a callee is implicit.\u003c/p\u003e\n\u003cp\u003eI want to take one more step back and then I promise I will reach a conclusion. There are definitions of coroutines other than the one I gave, especially older ones. If you were to closely read \u003ca href=\"https://en.wikipedia.org/wiki/Coroutine\"\u003eWikipedia\u003c/a\u003e, you would find a slightly different definition, and what I’ve called coroutines are addressed instead as “generators” or “semicoroutines.” In the older definition, a coroutine can specify where it yields control. This is actually based on a model of program execution in which there is no program stack: instead, every coroutine is a global singleton, and yielding control to it means continuing it wherever it last left off. For semicoroutines, in contrast, calling a coroutine produces a new stack frame which can only be resumed by code with a reference to that stack frame.\u003c/p\u003e\n\u003cp\u003eThe program stack is such a universal model of program execution today that we treat it as inevitable, but like everything else it had to be invented. It was invented to support recursive function definition, but it has other advantages in the way that it enables local reasoning: from the body of a function, there is exactly one dynamic jump point - wherever it returns to. From the point of view of the caller, this is now statically known: the function will jump back to the point at which it is called.\u003c/p\u003e\n\u003cp\u003eThis rule can only be violated when a language introduces new features that allow additional dynamic jump points. One that has long been popular is the notion of exceptions, which unwind the call stack to the point at which they are being handled. There are two kinds of exceptions: unchecked exceptions, which are totally untyped, and checked exceptions, which require an annotations on any function which could throw them.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eEffect handlers are a generalization of checked exceptions\u003c/strong\u003e, with all of the pros and cons of that feature. They require you to annotate functions that have an effect, but they do not require you to annotate \u003cem\u003ecalls\u003c/em\u003e at which the effect can occur. Therefore, when examining the body of a function, to understand when the effect occurs requires examining the type signature of every function that is called. Since this is meaningful control flow, it seems very valuable to be able to identify points at which an error occurs without examining the signatures of each function call. This is why Rust features \u003ccode\u003eResult\u003c/code\u003e and the \u003ccode\u003e?\u003c/code\u003e operator instead of checked exceptions.\u003c/p\u003e\n\u003cp\u003eThere’s an axis of evaluation here with three points: a language could model an effect in a way which is totally unchecked at compile time: both dynamically typed and dynamically scoped. Unchecked exceptions (including panics) are an example of this; so is blocking IO. And a language could model the effect in the type system, but with a dynamic scope. Checked exceptions and effect handlers are both examples of this. And a language could model the effect in a way which is both statically typed and lexically scoped. This is what Rust does for these effects with both \u003ccode\u003eResult\u003c/code\u003e and \u003ccode\u003easync/await\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e(You may notice that there’s a fourth spot in the design space not covered here: dynamically typed and lexically scoped. An example in this category would be the async/await feature in dynamically typed languages like Python and JavaScript; you must annotate asynchronous calls with \u003ccode\u003eawait\u003c/code\u003e to get their result, but if you fail to do so it is not a compile-time error.)\u003c/p\u003e\n\u003cpre class=\"language-fallback\"\u003e\u003ccode class=\"language-fallback\"\u003e                                          │   EXCEPTIONS          │   IO\n──────────────────────────────────────────┼───────────────────────┼───────────────\n                                          │                       │\n  DYNAMICALLY TYPED \u0026#x26; DYNAMICALLY SCOPED  │   panicking           │   blocking\n                                          │                       │\n   STATICALLY TYPED \u0026#x26; DYNAMICALLY SCOPED  │   checked exceptions  │   IO effect\n                                          │                       │\n     STATICALLY TYPED \u0026#x26; LEXICALLY SCOPED  │   Result              │   async/await\n                                          │                       │\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese are not the only language features that can be used to model effects, and other features also fall into one of these buckets. For example, monads are also statically typed and lexically scoped. However, a major objection to monads is that they model effects in a specifically layered way, so that for example there is a distinction between an \u003ccode\u003eIO\u0026#x3C;Result\u0026#x3C;T, E\u003e\u003e\u003c/code\u003e and a \u003ccode\u003eResult\u0026#x3C;IO\u0026#x3C;T\u003e, E\u003e\u003c/code\u003e. Coroutines on the other hand are order-independent: all coroutine that yield \u003ccode\u003ePending\u003c/code\u003e and \u003ccode\u003eException\u003c/code\u003e have the same type, there is no distinction of order. The same is true of effect handlers.\u003c/p\u003e\n\u003cp\u003eThis has appeared in Rust for example with the debate about the design of \u003ca href=\"https://without.boats/blog/poll-next\"\u003easync iterators\u003c/a\u003e. Designs based on \u003ccode\u003easync fn next\u003c/code\u003e introduce an arbitrary ordering by introducing multiple coroutines, whereas designed based on a single coroutine do not make a distinction; the coroutine just yields items as well as \u003ccode\u003ePending\u003c/code\u003e. This was the crux of Russell Johnston’s argument in the post I linked earlier: this unlayered property is shared by coroutines and effect handlers, and is an advantage of these features.\u003c/p\u003e\n\u003cp\u003eOn the other hand, by modeling errors with \u003ccode\u003eResult\u003c/code\u003e instead of some sort of coroutine, Rust \u003cem\u003edoes\u003c/em\u003e introduce an ordering. This is mostly fine because of the fact that a function which “throws an exception” (by evaluating to an \u003ccode\u003eErr\u003c/code\u003e) is not supposed to be resumed, though it introduces some quirks where for example there’s no way to distinguish between an iterator of \u003ccode\u003eResult\u003c/code\u003es (which may continue after one is an \u003ccode\u003eErr\u003c/code\u003e) and an iterator which throws an error (which will not continue). If instead a generator could “yield an exception,” it would be a different type from a generator that yields a sequence of \u003ccode\u003eResult\u003c/code\u003es. But I don’t find this inadequacy to come up in practice that often, so I’m content to leave it as theoretical work for a future language to solve.\u003c/p\u003e\n\u003cp\u003eOverall, coroutines strike me as the most promising way to handle many kinds of effectful functions because they seem to be in the design sweet spot: They are statically typed, lexically scoped, and unlayered. This is why my starting point for handling effects in any language would be a coroutine feature (though if the language were not under Rust’s constraints, I would prefer if it were a stackful coroutine feature so they could be recursive).\u003c/p\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -\u003e 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e “Motivation often comes after starting, not before. Action produces momentum.”\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n\u003e\n\u003e 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n\u003e\n\u003e - 막막한 독서. 시로군. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"wjsyv41pykk19dxjviwj6rm"},"buildId":"vOE8u-mg___OsOsz4tjEg","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>