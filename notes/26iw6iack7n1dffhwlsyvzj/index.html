<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Redis Explained</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Redis Explained"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://luke-snaw.github.io//notes/26iw6iack7n1dffhwlsyvzj/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="8/11/2022"/><meta property="article:modified_time" content="8/12/2022"/><link rel="canonical" href="https://luke-snaw.github.io//notes/26iw6iack7n1dffhwlsyvzj/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/wirstT2ztC8OQsbzKjhvw/_buildManifest.js" defer=""></script><script src="/_next/static/wirstT2ztC8OQsbzKjhvw/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="redis-explained">Redis Explained<a aria-hidden="true" class="anchor-heading icon-link" href="#redis-explained"></a></h1>
<blockquote>
<p><a href="https://architecturenotes.co/redis/">https://architecturenotes.co/redis/</a><br>
<a href="https://news.ycombinator.com/item?id=32426879">https://news.ycombinator.com/item?id=32426879</a></p>
</blockquote>
<p>A deep technical dive into all things Redis. Covering various Redis topologies, data persistence and process forking.</p>
<hr>
<p>Redis Explained</p>
<ol>
<li>
<p><a href="https://architecturenotes.co/redis/#what-is-redis">What is Redis?</a></p>
</li>
<li>
<p><a href="https://architecturenotes.co/redis/#redis-architectures">Redis Architectures</a></p>
<ol>
<li>
<p><a href="https://architecturenotes.co/redis/#single-redis-instance">Single Redis Instance</a></p>
</li>
<li>
<p><a href="https://architecturenotes.co/redis/#redis-ha">Redis HA</a></p>
</li>
<li>
<p><a href="https://architecturenotes.co/redis/#redis-replication">Redis Replication</a></p>
</li>
<li>
<p><a href="https://architecturenotes.co/redis/#redis-sentinel">Redis Sentinel</a></p>
</li>
<li>
<p><a href="https://architecturenotes.co/redis/#redis-cluster">Redis Cluster</a></p>
</li>
<li>
<p><a href="https://architecturenotes.co/redis/#gossiping">Gossiping</a></p>
</li>
</ol>
</li>
<li>
<p><a href="https://architecturenotes.co/redis/#redis-persistence-models">Redis Persistence Models</a></p>
<ol>
<li><a href="https://architecturenotes.co/redis/#no-persistence">No persistence</a></li>
<li><a href="https://architecturenotes.co/redis/#rdb-files">RDB Files</a></li>
<li><a href="https://architecturenotes.co/redis/#aof">AOF</a></li>
<li><a href="https://architecturenotes.co/redis/#why-not-both">Why not both?</a></li>
</ol>
</li>
<li>
<p><a href="https://architecturenotes.co/redis/#forking">Forking</a></p>
</li>
<li>
<p><a href="https://architecturenotes.co/redis/#references">References</a></p>
</li>
</ol>
<p><img src="https://architecturenotes.co/content/images/2022/08/Redis-v2-01-1.jpg" alt="Redis Explained Infographic"></p>
<p>Redis Explained</p>
<h2 id="what-is-redis">What is Redis?<a aria-hidden="true" class="anchor-heading icon-link" href="#what-is-redis"></a></h2>
<p><a href="http://redis.io/">Redis</a> (‚Äú<strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>ervice‚Äù) is an open-source key-value database server.</p>
<p>The most accurate description of Redis is that it's a data structure server. This specific nature of Redis has led to much of its popularity and adoption amongst developers.</p>
<p>Rather than iterating over, sorting, and ordering rows, what if the data was in data structures you wanted from the ground up? Early on, it was used much like Memcached, but as Redis improved, it became viable for many other use cases, including publish-subscribe mechanisms, streaming, and queues.</p>
<p><img src="https://architecturenotes.co/content/images/2022/07/Redis-v2-separate-08.jpg"></p>
<p>Primarily, Redis is an in-memory database used as a cache in front of another "real" database like MySQL or PostgreSQL to help improve application performance. It leverages the speed of memory and alleviates load off the central application database for:</p>
<ul>
<li>Data that changes infrequently ¬†and is requested often</li>
<li>Data that is less mission-critical and is frequently evolving.</li>
</ul>
<p>Examples of above data ¬†can include session or data caches and leaderboard or roll-up analytics for dashboards.</p>
<p><img src="https://architecturenotes.co/content/images/2022/07/Redis-v2-separate-05.jpg"></p>
<p>However, for many use cases, Redis offers enough guarantees that it can be used as a full-fledged primary database. Coupled with Redis plug-ins and its various High Availability (HA) setups, Redis as a database ¬†has become incredibly useful for certain scenarios and workloads.</p>
<p>Another important aspect is that Redis blurred the lines between a cache and datastore. Important note to understand here is that reading and manipulating data in memory is much faster than anything possible in traditional datastores using SSDs or HDDs.</p>
<p><img src="https://architecturenotes.co/content/images/2022/08/FXZjqMPVUAAqUfs-1.jpeg" alt="System Latencies "></p>
<p>Important latency and bandwidth numbers every software engineer to should be aware of. Credit: Jeff Dean for the original post!</p>
<p>Originally Redis was most commonly compared to Memcached, which lacked any nonvolatile persistence at the time.</p>
<h4 id="memcached">Memcached<a aria-hidden="true" class="anchor-heading icon-link" href="#memcached"></a></h4>
<p>Memcached was created by Brad Fitzpatrick in 2003, predating Redis by six years. It originally started as a Perl project and was later rewritten in C. It was the de facto caching tool of its day. The main differentiating point between it and Redis is its lack of data types and its limited eviction policy of just LRU (least recently used).</p>
<p>Another difference is that Redis is single-threaded while Memcached is multithreaded. Memcached might be performant in a strictly caching environment but requires some setup in a distributed cluster, while Redis has support for this out of the box.</p>
<p>Here is a current breakdown of capabilities between these two caches.</p>
<div class="table-responsive">





































































<table><thead><tr><th></th><th>Memcached</th><th>Redis</th></tr></thead><tbody><tr><td>Sub-millisecond latency</td><td>Yes</td><td>Yes</td></tr><tr><td>Developer ease of use</td><td>Yes</td><td>Yes</td></tr><tr><td>Data partitioning</td><td>Yes</td><td>Yes</td></tr><tr><td>Support for a broad set of programming languages</td><td>Yes</td><td>Yes</td></tr><tr><td>Advanced data structures</td><td>-</td><td>Yes</td></tr><tr><td>Multithreaded architecture</td><td>Yes</td><td>-</td></tr><tr><td>Snapshots</td><td>-</td><td>Yes</td></tr><tr><td>Replication</td><td>-</td><td>Yes</td></tr><tr><td>Transactions</td><td>-</td><td>Yes</td></tr><tr><td>Pub/Sub</td><td>-</td><td>Yes</td></tr><tr><td>Lua scripting</td><td>-</td><td>Yes</td></tr><tr><td>Geospatial support</td><td>-</td><td>Yes</td></tr></tbody></table></div>
<p>Although now configurable in how it persists data to disk, when it was first introduced, Redis used snapshots where asynchronous copies of the data in memory were persisted to disk for long-term storage. Unfortunately, this mechanism has the downside of potentially losing your data between snapshots.</p>
<p>Redis has matured since its inception in 2009. We will cover most of its architecture and topologies so you can add Redis to your data storage system arsenal.</p>
<h2 id="redis-architectures">Redis Architectures<a aria-hidden="true" class="anchor-heading icon-link" href="#redis-architectures"></a></h2>
<p>Before we start discussing Redis internals, let's discuss the various Redis deployments and their trade-offs.</p>
<p>We will be focusing mainly on these configurations:</p>
<ol>
<li>Single Redis Instance</li>
<li>Redis HA</li>
<li>Redis Sentinel</li>
<li>Redis Cluster</li>
</ol>
<p>Depending on your use case and scale, you can decide to use one setup or another.</p>
<h3 id="single-redis-instance">Single Redis Instance<a aria-hidden="true" class="anchor-heading icon-link" href="#single-redis-instance"></a></h3>
<p><img src="https://architecturenotes.co/content/images/2022/08/CleanShot-2022-08-01-at-11.59.06.png"></p>
<p>Simple Redis deployment.</p>
<p>Single Redis instance is the most straightforward deployment of Redis. It allows users to set up and run small instances that can help them grow and speed up their services. However, this deployment isn't without shortcomings. For example, if this instance fails or is unavailable, all client calls to Redis will fail and therefore degrade the system's overall performance and speed.</p>
<p>Given enough memory and server resources, this instance can be powerful. A scenario primarily used for caching could result in a significant performance boost with minimal setup. Given enough system resources, you could deploy this Redis service on the same box the application is running.</p>
<p>Understanding a few Redis concepts on managing data within the system is essential. Commands sent to Redis are first processed in memory. Then, if persistence is set up on these instances, there is a forked process on some interval that facilitates data persistence RDB (very compact point-in-time representation of Redis data) snapshots or AOF (append-only files).</p>
<p>These two flows allow Redis to have long-term storage, support various replication strategies, and enable more complicated topologies. If Redis isn't set up to persist data, data is lost in case of a restart or failover. If the persistence is enabled on a restart, it loads all of the data in the RDB snapshot or AOF back into memory, and then the instance can support new client requests.</p>
<p>With that said, let us look into more distributed Redis setups you might want to use.</p>
<h3 id="redis-ha">Redis HA<a aria-hidden="true" class="anchor-heading icon-link" href="#redis-ha"></a></h3>
<p><img src="https://architecturenotes.co/content/images/2022/08/CleanShot-2022-08-01-at-12.00.06.png"></p>
<p>Redis with secondary failover.</p>
<p>Another popular setup with Redis is the main deployment with a secondary deployment that is kept in sync with replication. ¬†As data is written to the main instance it sends copies of those commands, to a replica client output buffer for secondary instances which facilitates replication. The secondary instances can be one or more instances in your deployment. These instances can help scale reads from Redis or provide failover in case the main is lost.</p>
<h4 id="high-availability">High Availability<a aria-hidden="true" class="anchor-heading icon-link" href="#high-availability"></a></h4>
<p><strong>High availability</strong> (<strong>HA</strong>) is a characteristic of a system that aims to ensure an agreed level of operational performance, usually uptime, for a higher than average period.</p>
<p>In these HA systems, it is essential to not have a single point of failure so systems can recover gracefully and quickly. This results in reliable crossover, so data isn't lost during the transition from primary to secondary, in addition to automatically detecting failure and recovery from it.</p>
<p>There are several new things to consider in this topology since we have now entered a distributed system that has many <a href="https://architecturenotes.co/fallacies-of-distributed-systems/">fallacies</a> you need to consider. Things that were previously straightforward are now more complex.</p>
<h3 id="redis-replication">Redis Replication<a aria-hidden="true" class="anchor-heading icon-link" href="#redis-replication"></a></h3>
<p>Every main instance of Redis has a replication ID and an offset. These two pieces of data are critical to figure out a point in time where a replica can continue its replication process or to determine if it needs to do a complete sync. This offset is incremented for every action that happens on the main Redis deployment.</p>
<pre><code>Replication ID, offset
</code></pre>
<p>More explicitly, when the Redis replica instance is just a few offsets behind the main instance, it receives the remaining commands from the primary, which is then replayed on its dataset until it is in sync. If the two instances cannot agree on a replication ID or the offset is unknown to the main instance, the replica will then request a full synchronization. This involves a primary instance creating a new RDB snapshot and sending it over to the replica. While this transfer is happening, the main instance is buffering all the intermediate updates between the snapshot cut-off and current offset to send to the secondary once it is in sync with the snapshot. Once complete, replication can continue as normal.</p>
<p>If an instance has the same replication ID and offset, they have precisely the same data. Now you may be wondering why a replication ID is required. When a Redis instance is promoted to primary or restarts from scratch as a primary, it is given a new replication ID. This is used to infer the prior primary instance from which this newly promoted secondary was replicating. This allows for the ability to perform a partial synchronization (with other secondaries) since the new primary instance remembers its old replication ID.</p>
<p>For example, two instances, primary and secondary, have the identical replication ID but offsets that differ by a few hundred commands, meaning that if those were replayed on the instance that is just behind in offset, they would have the same dataset. Now if the replication IDs differ entirely, and when we are unaware of the previous replication ID (no common ancestor) of the newly demoted (and rejoining) secondary. We will need to perform an expensive full sync.</p>
<p>Alternatively if we are aware of previous replication ID we can then reason about how to get the data in sync since we are able to reason about common ancestor they both shared and the offset is again meaningful for a partial sync.</p>
<h3 id="redis-sentinel">Redis Sentinel<a aria-hidden="true" class="anchor-heading icon-link" href="#redis-sentinel"></a></h3>
<p><img src="https://architecturenotes.co/content/images/2022/08/CleanShot-2022-08-01-at-13.38.41.png" alt="Redis Sentinel Deployment"></p>
<p>Redis Sentinel deployment (extra monitoring/dashed lines from other sentinel nodes are left out for clarity).</p>
<p>Sentinel is a distributed system. As with all ¬†distributed systems, Sentinel comes with several advantages and disadvantages. Sentinel is designed in a way where there is a cluster of sentinel processes working together to coordinate state to provide high availability for Redis. Afterall you wouldn't want the system protecting you from failure to have its own single point of failure.</p>
<p>üê¶</p>
<p>We are hoping to build the largest system design community on the internet! We would love for you to join us. You can find us here on <a href="https://twitter.com/arcnotes">Twitter</a>. You can reach the author <a href="https://twitter.com/myusuf3">here</a> too for feedback.</p>
<p>Sentinel is responsible for a few things. First, it ensures that the current main and secondary instances are functional and responding. This is necessary because sentinel (with other sentinel processes) can alert and act on situations where the main and/or secondary nodes are lost. Second, it serves a role in service discovery much like Zookeeper and Consul in other systems. So when a new client attempts to write something to Redis, ¬†Sentinel will tell the client what current main instance is.</p>
<p>So sentinels are constantly monitoring availability and sending out that information to clients so they are able to react to them if they indeed do failover.</p>
<p>Here are its responsibilities:</p>
<ol>
<li>Monitoring <strong>‚Äî</strong> ensuring main and secondary instances are working as expected.</li>
<li>Notification <strong>‚Äî</strong> notify system admins about occurrences in the Redis instances.</li>
<li>Failover management ‚Äî Sentinel nodes can start a failover process if the primary instance isn't available and enough (quorum of) nodes agree that is true.</li>
<li>Configuration management ‚Äî Sentinel nodes also serve as a point of discovery of the current main Redis instance.</li>
</ol>
<p>Using Redis Sentinel in this way allows for failure detection. This detection involves multiple sentinel processes agreeing that current main instance is no longer available. This agreement process is called Quorum. This allows for increased robustness and protection against one machine misbehaving and being unable to reach the main Redis node.</p>
<h4 id="quorum">Quorum<a aria-hidden="true" class="anchor-heading icon-link" href="#quorum"></a></h4>
<p>A <strong>quorum</strong> is the minimum number of votes that a distributed system has to obtain in order to be allowed to perform an operations like failover. This number is configurable, but should be reflective of the number of nodes in said distributed system. Most distributed systems have sizes of three or five with quorums of two and three respectively. Odd number of nodes is preffered in cases the system is required to break ties.</p>
<p>This setup isn't without its disadvantages so we are going to run through a few ¬†recommendations and best practices when using Redis Sentinel.</p>
<p>You can deploy Redis Sentinel in several ways. Honestly to make any sane recommendation I would need more context than I currently have about your system. As general guidance I would recommend running a sentinel node along aside each of your application servers (if possible) so you also don't need to factor in network reachability differences between sentinel nodes and clients who are actually using Redis.</p>
<p>You can run Sentinel alongside the Redis instances or even on independent nodes, but that complicates things in different ways. I recommend at least running three nodes with a quorum of at least two. Here is a simple chart breaking down numbers of servers in a cluster and associated quorum and tolerated failures that are sustainable.</p>
<div class="table-responsive">












































<table><thead><tr><th>Number of Servers</th><th>Quorum</th><th>Number Of Tolerated Failures</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>2</td><td>2</td><td>0</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>3</td><td>1</td></tr><tr><td>5</td><td>3</td><td>2</td></tr><tr><td>6</td><td>4</td><td>2</td></tr><tr><td>7</td><td>4</td><td>3</td></tr></tbody></table></div>
<p>Table of number of servers and quorum with number of tolerated failures.</p>
<p>This will vary from system to system but general idea stands.</p>
<p>Let's take a moment to think through what could go wrong in such a setup. ¬†If you ¬†run this system long enough, you will run into all of them.</p>
<ol>
<li>What if the sentinel nodes fall out of quorum?</li>
<li>What if there is a network split which puts the old main instance in the minority group? What happens to those writes? (Spoiler: they are lost when the system recovers fully)</li>
<li>What happens if the network topologies of sentinel nodes and client nodes (application nodes) are misaligned? üò¨</li>
</ol>
<p>There are no durability guarantees, especially since persistence (see below) to disk is asynchronous. There is also the nagging problem of <em>when</em> clients find out about new primaries, how many writes did we lose to an unaware primary? Redis recommends that when new connections are established that they should query for the new primary. Depending on the system configuration, that could mean a significant data loss.</p>
<p>There are a few ways to mitigate the level of losses if you force the main instance to replicate writes to a minimum of one secondary instance. Remember, all Redis replication is asynchronous and has its trade-offs. So it will need to independently track acknowledgement and if they aren't confirmed by at least one secondary, the main instance will stop accepting writes.</p>
<h3 id="redis-cluster">Redis Cluster<a aria-hidden="true" class="anchor-heading icon-link" href="#redis-cluster"></a></h3>
<p><img src="https://architecturenotes.co/content/images/2022/07/Redis-v2-separate-03.jpg"></p>
<p>I am sure many have thought about what happens when you can't store all your data in memory on one machine. Currently, the maximum RAM available in a single server is 24TIB, presently listed online at AWS. Granted, that's a lot, but for some systems, that isn't enough, even for a caching layer.</p>
<p>Redis Cluster allows for the horizontal scaling of Redis.</p>
<h4 id="vertical-and-horizontal-scaling">Vertical and Horizontal Scaling<a aria-hidden="true" class="anchor-heading icon-link" href="#vertical-and-horizontal-scaling"></a></h4>
<p>As your systems grow, you have three options.</p>
<ol>
<li>Do less (No one does this entirely because we are insatiable monsters).</li>
<li>Scale up.</li>
<li>Scale out.</li>
</ol>
<p>Taking the latter two seriously, scaling up and scaling out are known as vertical and horizontal scaling, respectively. Vertical scaling is a technique where you get bigger and better machines to do the work faster and hope all your problems scale well with your hardware. Even if this is possible, you will eventually be limited by the hardware you use.</p>
<p>Once you reach that point (more likely and hopefully way before), you will need to scale your system horizontally by spreading the workload across multiple smaller machines responsible for smaller parts of the whole.</p>
<p>So let's get some terminology out of the way; once we decide to use Redis Cluster, we have decided to spread the data we are storing across multiple machines, known as sharding. So each Redis instance in the cluster is considered a shard of the data as a whole.</p>
<p>This brings about a new problem. If we push a key to the cluster, how do we know which Redis instance (shard) is holding that data? There are several ways to do this, but Redis Cluster uses <strong>algorithmic sharding</strong>.</p>
<p>To find the shard for a given key, we hash the key and mod the total result by the number of shards. Then, using a <strong>deterministic hash function</strong>, meaning that a given key will always map to the same shard, we can reason about where a particular key will be when we read it in the future.</p>
<p>What happens when we later want to add a new shard into the system? This process is called resharding.</p>
<p>Assuming the key 'foo' was mapped to shard zero after introducing a new shard, it may map to shard five. However, moving data around to reflect the new shard mapping would be slow and unrealistic if we need to grow the system quickly. It also has adverse effects on the availability of the Redis Cluster.</p>
<p>Redis Cluster has devised a solution to this problem called Hashslot, to which all data is mapped. There are 16K hashslot. This gives us a reasonable way to spread data across the cluster, and when we add new shards, we simply move hashslots across the systems. By doing this, we just need to move hashlots from shard to shard and simplify the process of adding new primary instances into the cluster.</p>
<p>This is possible without any downtime, and minimal performance hit. Let's talk through an example.</p>
<p>M1 contains hashslots from 0 to 8191.</p>
<p>M2 contains hashslots from 8192 to 16383.</p>
<p>So to map `foo', we take a deterministic hash of the key (foo) and mod it by the number of hash slots(16K), leading to a mapping of M2. Now let's say we add a new instance, M3. The new mappings would be</p>
<p>M1 contains hashslots from 0 to 5460.</p>
<p>M2 contains hashslots from 5461 to 10922.</p>
<p>M3 contains hashslots from 10923 to 16383.</p>
<p>All the keys that mapped the hashslots in M1 that are now mapped to M2 would need to move. But the hashing for the individual keys to hashslots wouldn't need to move because they have already been divided up across hashslots. So this one level of misdirection solves the resharding issue with algorithmic sharding.</p>
<h3 id="gossiping">Gossiping<a aria-hidden="true" class="anchor-heading icon-link" href="#gossiping"></a></h3>
<p>Redis Cluster uses gossiping to determine the entire cluster's health. In the illustration above, we have 3 M nodes and 3 S nodes. All these nodes constantly communicate to know which shards are available and ready to serve requests. If enough shards agree that M1 isn't responsive, they can decide to promote M1's secondary S1 into a primary to keep the cluster healthy. The number of nodes needed to trigger this is configurable, and it is essential to get this right. If you do it improperly, you can end up in situations where the cluster is split if it cannot break the tie when both sides of a partition are equal. This phenomenon is called split brain. As a general rule, it is essential to have an odd number of primary nodes and two replicas each for the most robust setup.</p>
<h2 id="redis-persistence-models">Redis Persistence Models<a aria-hidden="true" class="anchor-heading icon-link" href="#redis-persistence-models"></a></h2>
<p>If we are going to use Redis to store any kind of data for safe keeping, it's important to understand how Redis is doing it. There are many usecases where if you were to lose the data Redis is storing is not the end of the world. Using it as a cache or in situations where its powering real-time analytics where if data loss occurs its no the end of the world.</p>
<p>In other scenarios, we want to have some guarantees around data persistence and recovery.</p>
<p>‚è©</p>
<p>Redis is fast and all consistency guarantees, come second to speed. This maybe a controversial topic, but it is true.</p>
<p><img src="https://architecturenotes.co/content/images/2022/07/Redis-v2-separate-06.jpg"></p>
<p>Redis persistence models</p>
<h3 id="no-persistence">No persistence<a aria-hidden="true" class="anchor-heading icon-link" href="#no-persistence"></a></h3>
<p><strong>No persistence</strong>: If you wish, you can disable persistence altogether. This is the fastest way to run Redis and has no durability guarantees.</p>
<h3 id="rdb-files">RDB Files<a aria-hidden="true" class="anchor-heading icon-link" href="#rdb-files"></a></h3>
<p><strong>RDB</strong> (Redis Database): The RDB persistence performs point-in-time snapshots of your dataset at specified intervals.</p>
<p>The main downside to this mechanism is that data between snapshots will be lost. In addition, this storage mechanism also relies on forking the main process, and in a larger dataset, this may lead to a momentary delay in serving requests. That being said, RDB files are much faster being loaded in memory than AOF.</p>
<h3 id="aof">AOF<a aria-hidden="true" class="anchor-heading icon-link" href="#aof"></a></h3>
<p><strong>AOF</strong> (Append Only File): The AOF persistence logs every write operation the server receives that will be played again at server startup, reconstructing the original dataset.</p>
<p>This way of ensuring persistence is much more durable than RDB snapshots since it is an append-only file. As operations happen, we buffer them to the log, but they aren't persisted yet. This log consistents of the actual commands we ran in order for replay when needed.</p>
<p>Then when possible, we flush it to disk with fsync (when this runs is configurable), it will be persisted. The downside is that the format isn't compact and uses more disk than RDB files.</p>
<h4 id="fsync">fsync<a aria-hidden="true" class="anchor-heading icon-link" href="#fsync"></a></h4>
<p><strong>fsync</strong>() transfers ("flushes") all modified in-core data of (i.e., modified buffer cache pages for) the file referred to by the file descriptor <em>fd</em> to the disk device (or other permanent storage device) so that all changed information can be retrieved even if the system crashes or is rebooted.</p>
<p>For various, reasons when changes are made to file they are done to caches and calls to fsync() ensure they are persisted to disk and accessible later.</p>
<h3 id="why-not-both">Why not both?<a aria-hidden="true" class="anchor-heading icon-link" href="#why-not-both"></a></h3>
<p><strong>RDB + AOF</strong>: It is possible to combine AOF and RDB in the same Redis instance. If durability in exchange for some speed is a tradeoff, you are willing to make it. I think this is an acceptable way to set up Redis. In the case of a restart, remember that if both are enabled, Redis will use AOF to reconstruct the data since it's the most complete.</p>
<h2 id="forking">Forking<a aria-hidden="true" class="anchor-heading icon-link" href="#forking"></a></h2>
<p>Now that we understand the types of persistence, let‚Äôs discuss how we actually go about doing it in a single threaded application like Redis.</p>
<p><img src="https://architecturenotes.co/content/images/2022/07/Redis-v2-separate-04.jpg"></p>
<p>This coolest part of Redis in my opinion is how it leverages forking and copy-on-write to facilitate data persistence performantly.</p>
<p><a href="https://en.wikipedia.org/wiki/Fork_(system_call)">Forking</a> is a way for operating systems to create new processes by creating copies of themselves. With this, you get a new process ID and a few other bits of information and handles, so the newly forked process (child) can talk to the original process parent.</p>
<p>Now here is where things get interesting. Redis is a process with tons of memory allocated to it, so how does it make a copy without running out of memory?</p>
<p>When you fork a process, the parent and child share memory, and in that child process Redis begins the snapshotting (Redis) process. This is made possible by a memory sharing technique called <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> <strong>‚Äî</strong>which passses references to the memory at the time the fork was created. If no changes occur while the child process is persisting to disk, no new allocations are made.</p>
<p>In the case where there are changes, the kernel keeps track of references to each page, and if there are more than one to specific page the changes are written to new pages. The child process is fully unaware of the change and has consistent memory snapshot. Therefore only fraction of the memory is used and we are able to achieve a point in time snapshot of potentially gigabytes of memory extremely quickly and efficiently!</p>
<p>If you enjoyed this, we have a ton more content like this on the way! We strive to make all these detailed and nuanced topics understandable and highlight where you would run into them!</p>
<p>Signing up or sharing it with someone who you think could benefit from this write up would be really appreciated.</p>
<p>I hope you learned something useful about how Redis operates in our systems! Feedback is encouraged and you can hit me up @<a href="https://twitter.com/myusuf3">myusuf3</a> on Twitter!</p>
<p>Subscribe</p>
<p>Processing your application Please check your inbox and click the link to confirm your subscription. There was an error sending the email</p>
<h2 id="references">References<a aria-hidden="true" class="anchor-heading icon-link" href="#references"></a></h2>
<ul>
<li><a href="http://antirez.com/news/55">Reply to Aphyr attack to Sentinel - &#x3C;antirez></a></li>
<li><a href="https://aphyr.com/posts/283-jepsen-redis">Jepsen: Redis</a></li>
<li><a href="https://en.wikipedia.org/wiki/Copy-on-write">Copy-on-write - Wikipedia</a></li>
<li><a href="https://redis.io/docs/">Documentation - Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fork_(system_call)">fork (system call) - Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Quorum_(distributed_computing)">Quorum (distributed computing) - Wikipedia</a></li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#what-is-redis" title="What is Redis?">What is Redis?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#memcached" title="Memcached">Memcached</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#redis-architectures" title="Redis Architectures">Redis Architectures</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#single-redis-instance" title="Single Redis Instance">Single Redis Instance</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#redis-ha" title="Redis HA">Redis HA</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#high-availability" title="High Availability">High Availability</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#redis-replication" title="Redis Replication">Redis Replication</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#redis-sentinel" title="Redis Sentinel">Redis Sentinel</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#quorum" title="Quorum">Quorum</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#redis-cluster" title="Redis Cluster">Redis Cluster</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#vertical-and-horizontal-scaling" title="Vertical and Horizontal Scaling">Vertical and Horizontal Scaling</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#gossiping" title="Gossiping">Gossiping</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#redis-persistence-models" title="Redis Persistence Models">Redis Persistence Models</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#no-persistence" title="No persistence">No persistence</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#rdb-files" title="RDB Files">RDB Files</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#aof" title="AOF">AOF</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#fsync" title="fsync">fsync</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#why-not-both" title="Why not both?">Why not both?</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#forking" title="Forking">Forking</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#references" title="References">References</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"26iw6iack7n1dffhwlsyvzj","title":"Redis Explained","desc":"","updated":1660262814851,"created":1660262239674,"custom":{},"fname":"dev.DB.tools.Redis Explained","type":"note","vault":{"fsPath":"vault"},"contentHash":"9928afc82592d4e49da48a5aee20ba23","links":[],"anchors":{"what-is-redis":{"type":"header","text":"What is Redis?","value":"what-is-redis","line":40,"column":0,"depth":2},"memcached":{"type":"header","text":"Memcached","value":"memcached","line":69,"column":0,"depth":4},"redis-architectures":{"type":"header","text":"Redis Architectures","value":"redis-architectures","line":96,"column":0,"depth":2},"single-redis-instance":{"type":"header","text":"Single Redis Instance","value":"single-redis-instance","line":109,"column":0,"depth":3},"redis-ha":{"type":"header","text":"Redis HA","value":"redis-ha","line":125,"column":0,"depth":3},"high-availability":{"type":"header","text":"High Availability","value":"high-availability","line":133,"column":0,"depth":4},"redis-replication":{"type":"header","text":"Redis Replication","value":"redis-replication","line":141,"column":0,"depth":3},"redis-sentinel":{"type":"header","text":"Redis Sentinel","value":"redis-sentinel","line":157,"column":0,"depth":3},"quorum":{"type":"header","text":"Quorum","value":"quorum","line":182,"column":0,"depth":4},"redis-cluster":{"type":"header","text":"Redis Cluster","value":"redis-cluster","line":216,"column":0,"depth":3},"vertical-and-horizontal-scaling":{"type":"header","text":"Vertical and Horizontal Scaling","value":"vertical-and-horizontal-scaling","line":224,"column":0,"depth":4},"gossiping":{"type":"header","text":"Gossiping","value":"gossiping","line":264,"column":0,"depth":3},"redis-persistence-models":{"type":"header","text":"Redis Persistence Models","value":"redis-persistence-models","line":268,"column":0,"depth":2},"no-persistence":{"type":"header","text":"No persistence","value":"no-persistence","line":282,"column":0,"depth":3},"rdb-files":{"type":"header","text":"RDB Files","value":"rdb-files","line":286,"column":0,"depth":3},"aof":{"type":"header","text":"AOF","value":"aof","line":292,"column":0,"depth":3},"fsync":{"type":"header","text":"fsync","value":"fsync","line":300,"column":0,"depth":4},"why-not-both":{"type":"header","text":"Why not both?","value":"why-not-both","line":306,"column":0,"depth":3},"forking":{"type":"header","text":"Forking","value":"forking","line":310,"column":0,"depth":2},"references":{"type":"header","text":"References","value":"references","line":336,"column":0,"depth":2}},"children":[],"parent":"gyry0ci0rohsl5gvjpsvws1","data":{}},"body":"\u003ch1 id=\"redis-explained\"\u003eRedis Explained\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#redis-explained\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/\"\u003ehttps://architecturenotes.co/redis/\u003c/a\u003e\u003cbr\u003e\n\u003ca href=\"https://news.ycombinator.com/item?id=32426879\"\u003ehttps://news.ycombinator.com/item?id=32426879\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eA deep technical dive into all things Redis. Covering various Redis topologies, data persistence and process forking.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eRedis Explained\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#what-is-redis\"\u003eWhat is Redis?\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#redis-architectures\"\u003eRedis Architectures\u003c/a\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#single-redis-instance\"\u003eSingle Redis Instance\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#redis-ha\"\u003eRedis HA\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#redis-replication\"\u003eRedis Replication\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#redis-sentinel\"\u003eRedis Sentinel\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#redis-cluster\"\u003eRedis Cluster\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#gossiping\"\u003eGossiping\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#redis-persistence-models\"\u003eRedis Persistence Models\u003c/a\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://architecturenotes.co/redis/#no-persistence\"\u003eNo persistence\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://architecturenotes.co/redis/#rdb-files\"\u003eRDB Files\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://architecturenotes.co/redis/#aof\"\u003eAOF\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://architecturenotes.co/redis/#why-not-both\"\u003eWhy not both?\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#forking\"\u003eForking\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://architecturenotes.co/redis/#references\"\u003eReferences\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"https://architecturenotes.co/content/images/2022/08/Redis-v2-01-1.jpg\" alt=\"Redis Explained Infographic\"\u003e\u003c/p\u003e\n\u003cp\u003eRedis Explained\u003c/p\u003e\n\u003ch2 id=\"what-is-redis\"\u003eWhat is Redis?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#what-is-redis\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://redis.io/\"\u003eRedis\u003c/a\u003e (‚Äú\u003cstrong\u003eRE\u003c/strong\u003emote \u003cstrong\u003eDI\u003c/strong\u003ectionary \u003cstrong\u003eS\u003c/strong\u003eervice‚Äù) is an open-source key-value database server.\u003c/p\u003e\n\u003cp\u003eThe most accurate description of Redis is that it's a data structure server. This specific nature of Redis has led to much of its popularity and adoption amongst developers.\u003c/p\u003e\n\u003cp\u003eRather than iterating over, sorting, and ordering rows, what if the data was in data structures you wanted from the ground up? Early on, it was used much like Memcached, but as Redis improved, it became viable for many other use cases, including publish-subscribe mechanisms, streaming, and queues.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://architecturenotes.co/content/images/2022/07/Redis-v2-separate-08.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003ePrimarily, Redis is an in-memory database used as a cache in front of another \"real\" database like MySQL or PostgreSQL to help improve application performance. It leverages the speed of memory and alleviates load off the central application database for:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eData that changes infrequently ¬†and is requested often\u003c/li\u003e\n\u003cli\u003eData that is less mission-critical and is frequently evolving.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eExamples of above data ¬†can include session or data caches and leaderboard or roll-up analytics for dashboards.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://architecturenotes.co/content/images/2022/07/Redis-v2-separate-05.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eHowever, for many use cases, Redis offers enough guarantees that it can be used as a full-fledged primary database. Coupled with Redis plug-ins and its various High Availability (HA) setups, Redis as a database ¬†has become incredibly useful for certain scenarios and workloads.\u003c/p\u003e\n\u003cp\u003eAnother important aspect is that Redis blurred the lines between a cache and datastore. Important note to understand here is that reading and manipulating data in memory is much faster than anything possible in traditional datastores using SSDs or HDDs.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://architecturenotes.co/content/images/2022/08/FXZjqMPVUAAqUfs-1.jpeg\" alt=\"System Latencies \"\u003e\u003c/p\u003e\n\u003cp\u003eImportant latency and bandwidth numbers every software engineer to should be aware of. Credit: Jeff Dean for the original post!\u003c/p\u003e\n\u003cp\u003eOriginally Redis was most commonly compared to Memcached, which lacked any nonvolatile persistence at the time.\u003c/p\u003e\n\u003ch4 id=\"memcached\"\u003eMemcached\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#memcached\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eMemcached was created by Brad Fitzpatrick in 2003, predating Redis by six years. It originally started as a Perl project and was later rewritten in C. It was the de facto caching tool of its day. The main differentiating point between it and Redis is its lack of data types and its limited eviction policy of just LRU (least recently used).\u003c/p\u003e\n\u003cp\u003eAnother difference is that Redis is single-threaded while Memcached is multithreaded. Memcached might be performant in a strictly caching environment but requires some setup in a distributed cluster, while Redis has support for this out of the box.\u003c/p\u003e\n\u003cp\u003eHere is a current breakdown of capabilities between these two caches.\u003c/p\u003e\n\u003cdiv class=\"table-responsive\"\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003c/th\u003e\u003cth\u003eMemcached\u003c/th\u003e\u003cth\u003eRedis\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eSub-millisecond latency\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eDeveloper ease of use\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eData partitioning\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSupport for a broad set of programming languages\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eAdvanced data structures\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eMultithreaded architecture\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSnapshots\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eReplication\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eTransactions\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ePub/Sub\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eLua scripting\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eGeospatial support\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003ctd\u003eYes\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\n\u003cp\u003eAlthough now configurable in how it persists data to disk, when it was first introduced, Redis used snapshots where asynchronous copies of the data in memory were persisted to disk for long-term storage. Unfortunately, this mechanism has the downside of potentially losing your data between snapshots.\u003c/p\u003e\n\u003cp\u003eRedis has matured since its inception in 2009. We will cover most of its architecture and topologies so you can add Redis to your data storage system arsenal.\u003c/p\u003e\n\u003ch2 id=\"redis-architectures\"\u003eRedis Architectures\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#redis-architectures\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eBefore we start discussing Redis internals, let's discuss the various Redis deployments and their trade-offs.\u003c/p\u003e\n\u003cp\u003eWe will be focusing mainly on these configurations:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eSingle Redis Instance\u003c/li\u003e\n\u003cli\u003eRedis HA\u003c/li\u003e\n\u003cli\u003eRedis Sentinel\u003c/li\u003e\n\u003cli\u003eRedis Cluster\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eDepending on your use case and scale, you can decide to use one setup or another.\u003c/p\u003e\n\u003ch3 id=\"single-redis-instance\"\u003eSingle Redis Instance\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#single-redis-instance\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://architecturenotes.co/content/images/2022/08/CleanShot-2022-08-01-at-11.59.06.png\"\u003e\u003c/p\u003e\n\u003cp\u003eSimple Redis deployment.\u003c/p\u003e\n\u003cp\u003eSingle Redis instance is the most straightforward deployment of Redis. It allows users to set up and run small instances that can help them grow and speed up their services. However, this deployment isn't without shortcomings. For example, if this instance fails or is unavailable, all client calls to Redis will fail and therefore degrade the system's overall performance and speed.\u003c/p\u003e\n\u003cp\u003eGiven enough memory and server resources, this instance can be powerful. A scenario primarily used for caching could result in a significant performance boost with minimal setup. Given enough system resources, you could deploy this Redis service on the same box the application is running.\u003c/p\u003e\n\u003cp\u003eUnderstanding a few Redis concepts on managing data within the system is essential. Commands sent to Redis are first processed in memory. Then, if persistence is set up on these instances, there is a forked process on some interval that facilitates data persistence RDB (very compact point-in-time representation of Redis data) snapshots or AOF (append-only files).\u003c/p\u003e\n\u003cp\u003eThese two flows allow Redis to have long-term storage, support various replication strategies, and enable more complicated topologies. If Redis isn't set up to persist data, data is lost in case of a restart or failover. If the persistence is enabled on a restart, it loads all of the data in the RDB snapshot or AOF back into memory, and then the instance can support new client requests.\u003c/p\u003e\n\u003cp\u003eWith that said, let us look into more distributed Redis setups you might want to use.\u003c/p\u003e\n\u003ch3 id=\"redis-ha\"\u003eRedis HA\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#redis-ha\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://architecturenotes.co/content/images/2022/08/CleanShot-2022-08-01-at-12.00.06.png\"\u003e\u003c/p\u003e\n\u003cp\u003eRedis with secondary failover.\u003c/p\u003e\n\u003cp\u003eAnother popular setup with Redis is the main deployment with a secondary deployment that is kept in sync with replication. ¬†As data is written to the main instance it sends copies of those commands, to a replica client output buffer for secondary instances which facilitates replication. The secondary instances can be one or more instances in your deployment. These instances can help scale reads from Redis or provide failover in case the main is lost.\u003c/p\u003e\n\u003ch4 id=\"high-availability\"\u003eHigh Availability\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#high-availability\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eHigh availability\u003c/strong\u003e (\u003cstrong\u003eHA\u003c/strong\u003e) is a characteristic of a system that aims to ensure an agreed level of operational performance, usually uptime, for a higher than average period.\u003c/p\u003e\n\u003cp\u003eIn these HA systems, it is essential to not have a single point of failure so systems can recover gracefully and quickly. This results in reliable crossover, so data isn't lost during the transition from primary to secondary, in addition to automatically detecting failure and recovery from it.\u003c/p\u003e\n\u003cp\u003eThere are several new things to consider in this topology since we have now entered a distributed system that has many \u003ca href=\"https://architecturenotes.co/fallacies-of-distributed-systems/\"\u003efallacies\u003c/a\u003e you need to consider. Things that were previously straightforward are now more complex.\u003c/p\u003e\n\u003ch3 id=\"redis-replication\"\u003eRedis Replication\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#redis-replication\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eEvery main instance of Redis has a replication ID and an offset. These two pieces of data are critical to figure out a point in time where a replica can continue its replication process or to determine if it needs to do a complete sync. This offset is incremented for every action that happens on the main Redis deployment.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eReplication ID, offset\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMore explicitly, when the Redis replica instance is just a few offsets behind the main instance, it receives the remaining commands from the primary, which is then replayed on its dataset until it is in sync. If the two instances cannot agree on a replication ID or the offset is unknown to the main instance, the replica will then request a full synchronization. This involves a primary instance creating a new RDB snapshot and sending it over to the replica. While this transfer is happening, the main instance is buffering all the intermediate updates between the snapshot cut-off and current offset to send to the secondary once it is in sync with the snapshot. Once complete, replication can continue as normal.\u003c/p\u003e\n\u003cp\u003eIf an instance has the same replication ID and offset, they have precisely the same data. Now you may be wondering why a replication ID is required. When a Redis instance is promoted to primary or restarts from scratch as a primary, it is given a new replication ID. This is used to infer the prior primary instance from which this newly promoted secondary was replicating. This allows for the ability to perform a partial synchronization (with other secondaries) since the new primary instance remembers its old replication ID.\u003c/p\u003e\n\u003cp\u003eFor example, two instances, primary and secondary, have the identical replication ID but offsets that differ by a few hundred commands, meaning that if those were replayed on the instance that is just behind in offset, they would have the same dataset. Now if the replication IDs differ entirely, and when we are unaware of the previous replication ID (no common ancestor) of the newly demoted (and rejoining) secondary. We will need to perform an expensive full sync.\u003c/p\u003e\n\u003cp\u003eAlternatively if we are aware of previous replication ID we can then reason about how to get the data in sync since we are able to reason about common ancestor they both shared and the offset is again meaningful for a partial sync.\u003c/p\u003e\n\u003ch3 id=\"redis-sentinel\"\u003eRedis Sentinel\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#redis-sentinel\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://architecturenotes.co/content/images/2022/08/CleanShot-2022-08-01-at-13.38.41.png\" alt=\"Redis Sentinel Deployment\"\u003e\u003c/p\u003e\n\u003cp\u003eRedis Sentinel deployment (extra monitoring/dashed lines from other sentinel nodes are left out for clarity).\u003c/p\u003e\n\u003cp\u003eSentinel is a distributed system. As with all ¬†distributed systems, Sentinel comes with several advantages and disadvantages. Sentinel is designed in a way where there is a cluster of sentinel processes working together to coordinate state to provide high availability for Redis. Afterall you wouldn't want the system protecting you from failure to have its own single point of failure.\u003c/p\u003e\n\u003cp\u003eüê¶\u003c/p\u003e\n\u003cp\u003eWe are hoping to build the largest system design community on the internet! We would love for you to join us. You can find us here on \u003ca href=\"https://twitter.com/arcnotes\"\u003eTwitter\u003c/a\u003e. You can reach the author \u003ca href=\"https://twitter.com/myusuf3\"\u003ehere\u003c/a\u003e too for feedback.\u003c/p\u003e\n\u003cp\u003eSentinel is responsible for a few things. First, it ensures that the current main and secondary instances are functional and responding. This is necessary because sentinel (with other sentinel processes) can alert and act on situations where the main and/or secondary nodes are lost. Second, it serves a role in service discovery much like Zookeeper and Consul in other systems. So when a new client attempts to write something to Redis, ¬†Sentinel will tell the client what current main instance is.\u003c/p\u003e\n\u003cp\u003eSo sentinels are constantly monitoring availability and sending out that information to clients so they are able to react to them if they indeed do failover.\u003c/p\u003e\n\u003cp\u003eHere are its responsibilities:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eMonitoring \u003cstrong\u003e‚Äî\u003c/strong\u003e ensuring main and secondary instances are working as expected.\u003c/li\u003e\n\u003cli\u003eNotification \u003cstrong\u003e‚Äî\u003c/strong\u003e notify system admins about occurrences in the Redis instances.\u003c/li\u003e\n\u003cli\u003eFailover management ‚Äî Sentinel nodes can start a failover process if the primary instance isn't available and enough (quorum of) nodes agree that is true.\u003c/li\u003e\n\u003cli\u003eConfiguration management ‚Äî Sentinel nodes also serve as a point of discovery of the current main Redis instance.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eUsing Redis Sentinel in this way allows for failure detection. This detection involves multiple sentinel processes agreeing that current main instance is no longer available. This agreement process is called Quorum. This allows for increased robustness and protection against one machine misbehaving and being unable to reach the main Redis node.\u003c/p\u003e\n\u003ch4 id=\"quorum\"\u003eQuorum\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#quorum\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eA \u003cstrong\u003equorum\u003c/strong\u003e is the minimum number of votes that a distributed system has to obtain in order to be allowed to perform an operations like failover. This number is configurable, but should be reflective of the number of nodes in said distributed system. Most distributed systems have sizes of three or five with quorums of two and three respectively. Odd number of nodes is preffered in cases the system is required to break ties.\u003c/p\u003e\n\u003cp\u003eThis setup isn't without its disadvantages so we are going to run through a few ¬†recommendations and best practices when using Redis Sentinel.\u003c/p\u003e\n\u003cp\u003eYou can deploy Redis Sentinel in several ways. Honestly to make any sane recommendation I would need more context than I currently have about your system. As general guidance I would recommend running a sentinel node along aside each of your application servers (if possible) so you also don't need to factor in network reachability differences between sentinel nodes and clients who are actually using Redis.\u003c/p\u003e\n\u003cp\u003eYou can run Sentinel alongside the Redis instances or even on independent nodes, but that complicates things in different ways. I recommend at least running three nodes with a quorum of at least two. Here is a simple chart breaking down numbers of servers in a cluster and associated quorum and tolerated failures that are sustainable.\u003c/p\u003e\n\u003cdiv class=\"table-responsive\"\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eNumber of Servers\u003c/th\u003e\u003cth\u003eQuorum\u003c/th\u003e\u003cth\u003eNumber Of Tolerated Failures\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003e0\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003e0\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e3\u003c/td\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e4\u003c/td\u003e\u003ctd\u003e3\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e5\u003c/td\u003e\u003ctd\u003e3\u003c/td\u003e\u003ctd\u003e2\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e6\u003c/td\u003e\u003ctd\u003e4\u003c/td\u003e\u003ctd\u003e2\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e7\u003c/td\u003e\u003ctd\u003e4\u003c/td\u003e\u003ctd\u003e3\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/div\u003e\n\u003cp\u003eTable of number of servers and quorum with number of tolerated failures.\u003c/p\u003e\n\u003cp\u003eThis will vary from system to system but general idea stands.\u003c/p\u003e\n\u003cp\u003eLet's take a moment to think through what could go wrong in such a setup. ¬†If you ¬†run this system long enough, you will run into all of them.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWhat if the sentinel nodes fall out of quorum?\u003c/li\u003e\n\u003cli\u003eWhat if there is a network split which puts the old main instance in the minority group? What happens to those writes? (Spoiler: they are lost when the system recovers fully)\u003c/li\u003e\n\u003cli\u003eWhat happens if the network topologies of sentinel nodes and client nodes (application nodes) are misaligned? üò¨\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThere are no durability guarantees, especially since persistence (see below) to disk is asynchronous. There is also the nagging problem of \u003cem\u003ewhen\u003c/em\u003e clients find out about new primaries, how many writes did we lose to an unaware primary? Redis recommends that when new connections are established that they should query for the new primary. Depending on the system configuration, that could mean a significant data loss.\u003c/p\u003e\n\u003cp\u003eThere are a few ways to mitigate the level of losses if you force the main instance to replicate writes to a minimum of one secondary instance. Remember, all Redis replication is asynchronous and has its trade-offs. So it will need to independently track acknowledgement and if they aren't confirmed by at least one secondary, the main instance will stop accepting writes.\u003c/p\u003e\n\u003ch3 id=\"redis-cluster\"\u003eRedis Cluster\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#redis-cluster\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"https://architecturenotes.co/content/images/2022/07/Redis-v2-separate-03.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eI am sure many have thought about what happens when you can't store all your data in memory on one machine. Currently, the maximum RAM available in a single server is 24TIB, presently listed online at AWS. Granted, that's a lot, but for some systems, that isn't enough, even for a caching layer.\u003c/p\u003e\n\u003cp\u003eRedis Cluster allows for the horizontal scaling of Redis.\u003c/p\u003e\n\u003ch4 id=\"vertical-and-horizontal-scaling\"\u003eVertical and Horizontal Scaling\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#vertical-and-horizontal-scaling\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003eAs your systems grow, you have three options.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDo less (No one does this entirely because we are insatiable monsters).\u003c/li\u003e\n\u003cli\u003eScale up.\u003c/li\u003e\n\u003cli\u003eScale out.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eTaking the latter two seriously, scaling up and scaling out are known as vertical and horizontal scaling, respectively. Vertical scaling is a technique where you get bigger and better machines to do the work faster and hope all your problems scale well with your hardware. Even if this is possible, you will eventually be limited by the hardware you use.\u003c/p\u003e\n\u003cp\u003eOnce you reach that point (more likely and hopefully way before), you will need to scale your system horizontally by spreading the workload across multiple smaller machines responsible for smaller parts of the whole.\u003c/p\u003e\n\u003cp\u003eSo let's get some terminology out of the way; once we decide to use Redis Cluster, we have decided to spread the data we are storing across multiple machines, known as sharding. So each Redis instance in the cluster is considered a shard of the data as a whole.\u003c/p\u003e\n\u003cp\u003eThis brings about a new problem. If we push a key to the cluster, how do we know which Redis instance (shard) is holding that data? There are several ways to do this, but Redis Cluster uses \u003cstrong\u003ealgorithmic sharding\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eTo find the shard for a given key, we hash the key and mod the total result by the number of shards. Then, using a \u003cstrong\u003edeterministic hash function\u003c/strong\u003e, meaning that a given key will always map to the same shard, we can reason about where a particular key will be when we read it in the future.\u003c/p\u003e\n\u003cp\u003eWhat happens when we later want to add a new shard into the system? This process is called resharding.\u003c/p\u003e\n\u003cp\u003eAssuming the key 'foo' was mapped to shard zero after introducing a new shard, it may map to shard five. However, moving data around to reflect the new shard mapping would be slow and unrealistic if we need to grow the system quickly. It also has adverse effects on the availability of the Redis Cluster.\u003c/p\u003e\n\u003cp\u003eRedis Cluster has devised a solution to this problem called Hashslot, to which all data is mapped. There are 16K hashslot. This gives us a reasonable way to spread data across the cluster, and when we add new shards, we simply move hashslots across the systems. By doing this, we just need to move hashlots from shard to shard and simplify the process of adding new primary instances into the cluster.\u003c/p\u003e\n\u003cp\u003eThis is possible without any downtime, and minimal performance hit. Let's talk through an example.\u003c/p\u003e\n\u003cp\u003eM1 contains hashslots from 0 to 8191.\u003c/p\u003e\n\u003cp\u003eM2 contains hashslots from 8192 to 16383.\u003c/p\u003e\n\u003cp\u003eSo to map `foo', we take a deterministic hash of the key (foo) and mod it by the number of hash slots(16K), leading to a mapping of M2. Now let's say we add a new instance, M3. The new mappings would be\u003c/p\u003e\n\u003cp\u003eM1 contains hashslots from 0 to 5460.\u003c/p\u003e\n\u003cp\u003eM2 contains hashslots from 5461 to 10922.\u003c/p\u003e\n\u003cp\u003eM3 contains hashslots from 10923 to 16383.\u003c/p\u003e\n\u003cp\u003eAll the keys that mapped the hashslots in M1 that are now mapped to M2 would need to move. But the hashing for the individual keys to hashslots wouldn't need to move because they have already been divided up across hashslots. So this one level of misdirection solves the resharding issue with algorithmic sharding.\u003c/p\u003e\n\u003ch3 id=\"gossiping\"\u003eGossiping\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#gossiping\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eRedis Cluster uses gossiping to determine the entire cluster's health. In the illustration above, we have 3 M nodes and 3 S nodes. All these nodes constantly communicate to know which shards are available and ready to serve requests. If enough shards agree that M1 isn't responsive, they can decide to promote M1's secondary S1 into a primary to keep the cluster healthy. The number of nodes needed to trigger this is configurable, and it is essential to get this right. If you do it improperly, you can end up in situations where the cluster is split if it cannot break the tie when both sides of a partition are equal. This phenomenon is called split brain. As a general rule, it is essential to have an odd number of primary nodes and two replicas each for the most robust setup.\u003c/p\u003e\n\u003ch2 id=\"redis-persistence-models\"\u003eRedis Persistence Models\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#redis-persistence-models\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eIf we are going to use Redis to store any kind of data for safe keeping, it's important to understand how Redis is doing it. There are many usecases where if you were to lose the data Redis is storing is not the end of the world. Using it as a cache or in situations where its powering real-time analytics where if data loss occurs its no the end of the world.\u003c/p\u003e\n\u003cp\u003eIn other scenarios, we want to have some guarantees around data persistence and recovery.\u003c/p\u003e\n\u003cp\u003e‚è©\u003c/p\u003e\n\u003cp\u003eRedis is fast and all consistency guarantees, come second to speed. This maybe a controversial topic, but it is true.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://architecturenotes.co/content/images/2022/07/Redis-v2-separate-06.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eRedis persistence models\u003c/p\u003e\n\u003ch3 id=\"no-persistence\"\u003eNo persistence\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#no-persistence\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eNo persistence\u003c/strong\u003e: If you wish, you can disable persistence altogether. This is the fastest way to run Redis and has no durability guarantees.\u003c/p\u003e\n\u003ch3 id=\"rdb-files\"\u003eRDB Files\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#rdb-files\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eRDB\u003c/strong\u003e (Redis Database): The RDB persistence performs point-in-time snapshots of your dataset at specified intervals.\u003c/p\u003e\n\u003cp\u003eThe main downside to this mechanism is that data between snapshots will be lost. In addition, this storage mechanism also relies on forking the main process, and in a larger dataset, this may lead to a momentary delay in serving requests. That being said, RDB files are much faster being loaded in memory than AOF.\u003c/p\u003e\n\u003ch3 id=\"aof\"\u003eAOF\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#aof\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eAOF\u003c/strong\u003e (Append Only File): The AOF persistence logs every write operation the server receives that will be played again at server startup, reconstructing the original dataset.\u003c/p\u003e\n\u003cp\u003eThis way of ensuring persistence is much more durable than RDB snapshots since it is an append-only file. As operations happen, we buffer them to the log, but they aren't persisted yet. This log consistents of the actual commands we ran in order for replay when needed.\u003c/p\u003e\n\u003cp\u003eThen when possible, we flush it to disk with fsync (when this runs is configurable), it will be persisted. The downside is that the format isn't compact and uses more disk than RDB files.\u003c/p\u003e\n\u003ch4 id=\"fsync\"\u003efsync\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#fsync\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003efsync\u003c/strong\u003e() transfers (\"flushes\") all modified in-core data of (i.e., modified buffer cache pages for) the file referred to by the file descriptor \u003cem\u003efd\u003c/em\u003e to the disk device (or other permanent storage device) so that all changed information can be retrieved even if the system crashes or is rebooted.\u003c/p\u003e\n\u003cp\u003eFor various, reasons when changes are made to file they are done to caches and calls to fsync() ensure they are persisted to disk and accessible later.\u003c/p\u003e\n\u003ch3 id=\"why-not-both\"\u003eWhy not both?\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#why-not-both\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eRDB + AOF\u003c/strong\u003e: It is possible to combine AOF and RDB in the same Redis instance. If durability in exchange for some speed is a tradeoff, you are willing to make it. I think this is an acceptable way to set up Redis. In the case of a restart, remember that if both are enabled, Redis will use AOF to reconstruct the data since it's the most complete.\u003c/p\u003e\n\u003ch2 id=\"forking\"\u003eForking\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#forking\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eNow that we understand the types of persistence, let‚Äôs discuss how we actually go about doing it in a single threaded application like Redis.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://architecturenotes.co/content/images/2022/07/Redis-v2-separate-04.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eThis coolest part of Redis in my opinion is how it leverages forking and copy-on-write to facilitate data persistence performantly.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Fork_(system_call)\"\u003eForking\u003c/a\u003e is a way for operating systems to create new processes by creating copies of themselves. With this, you get a new process ID and a few other bits of information and handles, so the newly forked process (child) can talk to the original process parent.\u003c/p\u003e\n\u003cp\u003eNow here is where things get interesting. Redis is a process with tons of memory allocated to it, so how does it make a copy without running out of memory?\u003c/p\u003e\n\u003cp\u003eWhen you fork a process, the parent and child share memory, and in that child process Redis begins the snapshotting (Redis) process. This is made possible by a memory sharing technique called \u003ca href=\"https://en.wikipedia.org/wiki/Copy-on-write\"\u003ecopy-on-write\u003c/a\u003e \u003cstrong\u003e‚Äî\u003c/strong\u003ewhich passses references to the memory at the time the fork was created. If no changes occur while the child process is persisting to disk, no new allocations are made.\u003c/p\u003e\n\u003cp\u003eIn the case where there are changes, the kernel keeps track of references to each page, and if there are more than one to specific page the changes are written to new pages. The child process is fully unaware of the change and has consistent memory snapshot. Therefore only fraction of the memory is used and we are able to achieve a point in time snapshot of potentially gigabytes of memory extremely quickly and efficiently!\u003c/p\u003e\n\u003cp\u003eIf you enjoyed this, we have a ton more content like this on the way! We strive to make all these detailed and nuanced topics understandable and highlight where you would run into them!\u003c/p\u003e\n\u003cp\u003eSigning up or sharing it with someone who you think could benefit from this write up would be really appreciated.\u003c/p\u003e\n\u003cp\u003eI hope you learned something useful about how Redis operates in our systems! Feedback is encouraged and you can hit me up @\u003ca href=\"https://twitter.com/myusuf3\"\u003emyusuf3\u003c/a\u003e on Twitter!\u003c/p\u003e\n\u003cp\u003eSubscribe\u003c/p\u003e\n\u003cp\u003eProcessing your application Please check your inbox and click the link to confirm your subscription. There was an error sending the email\u003c/p\u003e\n\u003ch2 id=\"references\"\u003eReferences\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#references\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://antirez.com/news/55\"\u003eReply to Aphyr attack to Sentinel - \u0026#x3C;antirez\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://aphyr.com/posts/283-jepsen-redis\"\u003eJepsen: Redis\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Copy-on-write\"\u003eCopy-on-write - Wikipedia\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://redis.io/docs/\"\u003eDocumentation - Redis is an open source (BSD licensed), in-memory data structure store, used as a database, cache, and message broker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Fork_(system_call)\"\u003efork (system call) - Wikipedia\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Quorum_(distributed_computing)\"\u003eQuorum (distributed computing) - Wikipedia\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1766965759366,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"a724de3efd251cf89fe82a5860d9008b","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":43,"column":5,"offset":2710},"end":{"line":43,"column":29,"offset":2734},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2026.articles","alias":"What I read in 2026","position":{"start":{"line":72,"column":3,"offset":4440},"end":{"line":72,"column":45,"offset":4482},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2026.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2025.articles","alias":"2025","position":{"start":{"line":73,"column":5,"offset":4487},"end":{"line":73,"column":32,"offset":4514},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2025.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2024.articles","alias":"2024","position":{"start":{"line":74,"column":5,"offset":4519},"end":{"line":74,"column":32,"offset":4546},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2024.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2023.articles","alias":"2023","position":{"start":{"line":75,"column":5,"offset":4551},"end":{"line":75,"column":32,"offset":4578},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2023.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2022.articles","alias":"2022","position":{"start":{"line":76,"column":5,"offset":4583},"end":{"line":76,"column":32,"offset":4610},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2022.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":82,"column":3,"offset":4746},"end":{"line":82,"column":39,"offset":4782},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":76,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","o7xruzrah5wzqetottecss7","z1zo2mp6ddji5p317i4x9xw","v06c2tjelh341x4resa50fh","0yqesk4rcffwgyuab5x8rfa","sy2vkbtyu671chkvgn1yt8j","ufixpmxoydiccoh59kphrib","alswadkx4wb05y1z9iwfzfv","1daut9dpw70xd0zh5a7j5p4"],"parent":null,"data":{},"body":"\nHi there üëã. I'm a Front-end developer.\n\n---\n\n- ÌòÑÏã§ÏùÄ Ïù∏Í∞ÑÏùò Ïó∞ÏÇ∞ÏúºÎ°ú ÏôÑÏ†ÑÌûà ÌååÏïÖÌï† Ïàò ÏóÜÎäî Î≥µÏû°Í≥Ñ. Ï£ºÏñ¥ÏßÑ ÏÉÅÌô©Í≥º Îä•Î†•ÏúºÎ°ú Ìï† Ïàò ÏûàÎäî ÏµúÏÑ†Ïùò Ï†ÅÏùëÏùÄ Îã®ÏàúÌï®Í≥º Íæ∏Ï§ÄÌï®.\n\n  - ÌååÏÇ∞ÏùÑ Î©¥ÌïòÎäî ÏÑ†ÏóêÏÑú Ïó¨Îü¨Í∞ÄÏßÄÎ•º Ìï¥Î≥¥Í≥† ÏûêÏã†ÏóêÍ≤å ÎßûÎäî Í±∏ ÏúÑÏ£ºÎ°ú Íæ∏Ï§ÄÌûà. Í∑∏Î•º ÏúÑÌï¥ Îã®Ïàú, Ìé∏Ïïà, ÏæåÏ†ÅÌï®Ïù¥ ÌïÑÏöî.\n\n- ü•± -\u003e ü§îüí°üå± - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -\u003e easy fun -\u003e art -\u003e profit?\n\n\u003e I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n\u003e We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n\u003e Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n\u003e [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n\u003e\n\u003e Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n\u003e Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n\u003e A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n\u003e ‚ÄúMotivation often comes after starting, not before. Action produces momentum.‚Äù\n\u003e [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n\u003e\n\u003e - James Clear\n\n\u003e Focus is more about **not** keeping busy when you need to wait for something.  \n\u003e Eat the boredom for a minute.\n\u003e\n\u003e - [[life-tips#wodenokoto]]\n\n\u003e [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n\u003e\n\u003e - https://www.ntnu.edu/cerg/advice\n\u003e - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n\u003e [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n\u003e\n\u003e - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n\u003e ÎèÑÎ¨¥ÏßÄ ÏùΩÌûàÏßÄ ÏïäÎäî Ï±Ö ÏïûÏóêÏÑú ÎÇ¥Í∞Ä ÌÉùÌïú Î∞©Î≤ïÏùÄ ÌéºÏ≥êÏßÑ ÌéòÏù¥ÏßÄ ÏïûÏóêÏÑú Î©çÎïåÎ¶¨Í∏∞Ïù¥Îã§. Îã§Î•¥Í≤å ÌëúÌòÑÌïòÎ©¥ Ïù¥Î†áÎã§. ÌéºÏ≥êÏßÑ Îëê ÌéòÏù¥ÏßÄ ÏïûÏóêÏÑú Ïò§Îûò Î®∏Î¨ºÍ∏∞.\n\u003e\n\u003e Ï±ÖÏùÑ ÌéºÏ≥êÎÜìÎäî Í≤ÉÏúºÎ°ú Ï∂©Î∂ÑÌïòÎã§. ÏùΩÏßÄ Î™ªÌï¥ÎèÑ Ï¢ãÎã§. Îß§Ïùº Ï†ïÌï¥ÏßÑ ÏßÑÎèÑÎ•º ÎÇòÍ∞ÄÏïº ÌïòÎäî ÌïôÍµê ÏàòÏóÖÏù¥ ÏïÑÎãàÎãàÍπå. ÌïòÏßÄÎßå ÏùΩÏßÄ ÏïäÏïÑÎèÑ Í¥úÏ∞ÆÎã§Í≥† Ìï¥ÏÑú ÌéºÏ≥êÎëêÏßÄÏ°∞Ï∞® ÏïäÏúºÎ©¥ Í≥§ÎûÄÌïòÎã§. Í∞ÄÎä•Ìïú Ìïú ÏûêÏ£º Ï±ÖÏùÑ ÌéºÏ≥êÎëêÎèÑÎ°ù ÌïòÏûê. Ï†ÑÌòÄ ÏùΩÏßÄ ÏïäÍ≥† Î©çÌïòÎãà Î∞îÎùºÎ≥¥Í≥† ÏûàÎã§Í∞Ä Îã§Ïãú ÎçÆÍ≤å ÎêòÎçîÎùºÎèÑ\n\u003e\n\u003e - ÎßâÎßâÌïú ÎèÖÏÑú. ÏãúÎ°úÍµ∞. P.10~13\n\n\u003e I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n\u003e My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n\u003e Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2026|read.2026.articles]]\n  - [[2025|read.2025.articles]]\n  - [[2024|read.2024.articles]]\n  - [[2023|read.2023.articles]]\n  - [[2022|read.2022.articles]]\n- üìù [Gists](https://gist.github.com/Luke-SNAW)\n- üìú [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"26iw6iack7n1dffhwlsyvzj"},"buildId":"wirstT2ztC8OQsbzKjhvw","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>