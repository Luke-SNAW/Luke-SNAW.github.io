<h1 id="vibe-coding-as-a-coding-veteran">Vibe Coding as a Coding Veteran<a aria-hidden="true" class="anchor-heading icon-link" href="#vibe-coding-as-a-coding-veteran"></a></h1>
<blockquote>
<p><a href="https://levelup.gitconnected.com/vibe-coding-as-a-coding-veteran-cd370fe2be50">https://levelup.gitconnected.com/vibe-coding-as-a-coding-veteran-cd370fe2be50</a></p>
</blockquote>
<ul>
<li>This article records the actual experience of "Coding with AI" by a developer with 40 years of experience, who undertook a <strong>2-week project with an AI coding assistant</strong>.</li>
<li>The results showed advantages such as <strong>increased productivity (up to 2x)</strong>, <strong>surprising accuracy, and creative validation</strong>, alongside disadvantages like <strong>20% erroneous/incomplete code</strong> and <strong>excessive industrial complexity</strong>.</li>
<li>The author describes the interaction with AI as a psychological experience that fosters <strong>flow</strong> and <strong>learning effects</strong> while also creating a <strong>tension between trust and control</strong>.</li>
<li>In conclusion, AI coding is likened to a <strong>powerful companion yet a dangerous bicycle</strong>, presented as a <strong>new collaborative paradigm</strong> that experienced developers must proactively manage.</li>
</ul>
<hr>
<blockquote>
<p><a href="https://news.hada.io/topic?id=22880">https://news.hada.io/topic?id=22880</a></p>
</blockquote>
<ul>
<li>40년 경력의 개발자가 <strong>AI 코딩 어시스턴트와 함께 2주간 프로젝트</strong>를 진행하며 <strong>바이브 코딩</strong>의 실제 경험을 기록한 글임</li>
<li><strong>Tower of Hanoi 퍼즐 솔버</strong>를 구현하는 과정에서 300여 차례 대화를 통해 코드 전체를 AI가 생성하고, 인간은 검토와 방향 제시에 집중하는 방식 사용</li>
<li>결과는 <strong>빠른 생산성(최대 2배)</strong>, <strong>놀라운 정확성과 창의적 증명</strong> 같은 장점과 함께, <strong>20%의 오류·불완전 코드</strong> 및 <strong>산업용 과도한 복잡성</strong> 같은 단점도 공존함</li>
<li>저자는 AI와의 대화가 <strong>몰입(flow)</strong> 과 <strong>학습 효과</strong>를 주는 동시에, <strong>신뢰와 통제의 긴장</strong>을 유발하는 심리적 경험이라고 평가함</li>
<li>결론적으로 AI 코딩은 <strong>강력한 동반자이자 위험한 자전거</strong>에 비유되며, 경험 많은 개발자가 주도적으로 다뤄야 할 <strong>새로운 협업 패러다임</strong>으로 제시됨</li>
</ul>
<hr>
<h2 id="서문--vibe-coding">서문 — Vibe coding<a aria-hidden="true" class="anchor-heading icon-link" href="#서문--vibe-coding"></a></h2>
<ul>
<li>
<p><strong>Vibe coding</strong>은 <strong>LLM 기반 AI 에이전트</strong>가 <strong>작성·리팩터링·디버깅</strong>을 맡고 나는 <strong>무엇을 만들지</strong>에 집중하는 개발 방식</p>
</li>
<li>
<p>코딩은 나와 AI가 <strong>동시 협업</strong>으로 진행되거나 아예 <strong>AI에 전면 위임</strong>되는 구조</p>
</li>
<li>
<p>나는 이 방식을 <strong>흥미와 두려움</strong>이 공존하는 변화로 느끼며, <strong>프로그래밍의 예술성</strong>이 <strong>지능형 로봇의 조립 라인</strong>으로 바뀌는지 질문함</p>
</li>
<li>
<p>검증을 위해 <strong>2주</strong> 동안 총 <strong>40시간</strong>을 들여 <strong>최신 코딩 어시스턴트</strong>와 소규모 프로젝트 협업해 봄</p>
</li>
<li>
<p>프로젝트는 <strong>Python 약 5k LOC·50개 파일·20개 클래스</strong> 규모, <strong>교과서적 AI 탐색 알고리듬</strong>으로 <strong>전형적 퍼즐</strong>을 푸는 자기지시적 실험</p>
</li>
<li>
<p>결과물은 <strong><a href="https://github.com/mabene/vibe">코드 저장소</a>와 문서</strong> 형태로 공개, 글은 <strong>무엇을 했고 이해했고 배웠고 느꼈는지</strong>에 대한 기록임</p>
</li>
<li>
<p>나는 80년대에 8비트 머신에서 어셈블리로 시작해 <strong>40년의 코딩 경력</strong>을 가졌고, <strong>20여 개 언어를 사용</strong>해 봤음</p>
</li>
<li>
<p><strong>과학·모바일·업무용 소프트웨어</strong>를 <strong>개인·팀 단위</strong>로 개발한 경험이 있음</p>
</li>
<li>
<p>또한 <strong>(LLM 이전 시대의) AI 박사 학위</strong>를 보유함</p>
</li>
<li>
<p><strong>“AI 하는 사람이 AI 어시스턴트로 AI 코드를 만드는 것”</strong> 과 같은 <strong>에코 챔버</strong>같은 상황에서 뭔가 흥미로운게 있을 것이라 생각함</p>
</li>
</ul>
<h2 id="1-소프트웨어-개요와-개발-과정">1. 소프트웨어 개요와 개발 과정<a aria-hidden="true" class="anchor-heading icon-link" href="#1-소프트웨어-개요와-개발-과정"></a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi"><strong>Tower of Hanoi</strong></a> 퍼즐을 풀 수 있는 <strong>유연하고 교육적인 솔버</strong>를 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a>으로 구현해 봄</li>
<li>이 퍼즐은 원판을 특정 규칙에 따라 기둥 사이에서 옮기는 <strong>수학적 문제</strong>로, 디스크 수가 늘어나면 해답 길이가 <strong>폭발적으로 증가</strong>해 인간이 상상하기 어렵지만, 기계는 <strong>탐색 알고리듬</strong>으로 쉽게 해결 가능</li>
<li>솔버는 <strong>고전적 버전</strong>뿐 아니라 (a) 임의의 시작·끝 상태, (b) 여러 개의 디스크를 동시에 옮길 수 있는 <strong>일반화 버전</strong>까지 처리</li>
<li>구현된 탐색 기법은 <strong>재귀, BFS, DFS, 반복 심화, A*, 탐욕적 탐색, 양방향 BFS</strong> 등 최적·비최적 전략을 모두 포함</li>
<li>알고리듬은 <strong>CLI 기반 Python 스크립트</strong>에 포함되어 있으며, <strong>단계별 시각화, 방법별 성능 벤치마크, 다양한 초기/최종 구성 지원</strong> 기능 보유</li>
<li>모든 코드와 자료구조는 <strong>처음부터 새로 작성</strong>, 개발 과정은 <strong>Cursor IDE</strong>에서 <strong>AI 어시스턴트와 영어 대화</strong>로 진행</li>
<li>인간이 직접 작성한 코드나 문서는 없으며, <strong>AI와 나 사이의 기술적 대화</strong>를 통해 생성</li>
<li>총 <strong>40시간 동안 300회 이상 교환</strong>, 평균 <strong>8분당 1회 상호작용</strong>, 실제 시간은 대부분 <strong>AI 출력 검토와 평가</strong>에 소요</li>
</ul>
<h2 id="2-ai-어시스턴트의-성능은">2. AI 어시스턴트의 성능은?<a aria-hidden="true" class="anchor-heading icon-link" href="#2-ai-어시스턴트의-성능은"></a></h2>
<ul>
<li>나는 AI 어시스턴트가 보여준 <strong>코드와 자연어 이해 수준</strong>에 깊이 <strong>감명</strong>을 받음</li>
<li>내가 불명확하게 설명했다고 생각했을 때도, 어시스턴트는 의도를 파악하고 <strong>더 명확하게 재설명</strong>해 줌</li>
<li>(Python) 언어 구사 능력은 <strong>정확성, 속도, 문법과 의미 이해, 라이브러리 활용</strong>에서 <strong>초인적 수준</strong></li>
<li>대화는 때때로 <strong>진짜 지능 같은 통찰</strong>을 보여줌. 예를 들어, 무해결 퍼즐 예외 처리 여부를 묻자 <strong>모든 퍼즐은 해결 가능</strong>하다는 것을 그래프 공간에서의 모순 증명으로 제시</li>
<li>나는 같은 증명을 손으로 10분쯤 걸려 하던 중이었는데, 어시스턴트는 <strong>30초 만에 증명(QED)</strong> 을 작성했고, 나는 또 30초 만에 납득해 <strong>9분 절약</strong></li>
<li>단순한 알고리듬 문제에서 내가 틀린 적도 있었는데, <strong>비판하지 않는 태도</strong> 덕분에 당황스러움보다 <strong>해방감</strong>과 <strong>가벼운 웃음</strong>을 경험</li>
</ul>
<h2 id="3-잠깐-사용한-ai-코딩-어시스턴트는-어떤-것">3. 잠깐, 사용한 AI 코딩 어시스턴트는 어떤 것?<a aria-hidden="true" class="anchor-heading icon-link" href="#3-잠깐-사용한-ai-코딩-어시스턴트는-어떤-것"></a></h2>
<ul>
<li>세 가지 최신 AI 코딩 어시스턴트를 사용해 봄: <a href="https://openai.com/o3/">OpenAI o3</a>, <a href="https://claude.ai/">Anthropic Claude Sonnet 4</a>, <a href="https://gemini.google.com/">Google Gemini Pro 2.5</a></li>
<li><strong>o3</strong>는 코드 작성보다는 <strong>참고 문헌 확인, 알고리듬 속성 검증, 언어 의미론 질의, 코드 정리 스크립트 생성, 삽화 제작, 글에 대한 보조 의견</strong> 같은 부수 작업에 적합하다는 결론</li>
<li><strong>Gemini</strong>는 추억 어린 작업으로 <strong>튜링 머신풍 프로그램</strong>을 시켜 보며 흥미를 느낌. 산출물의 글은 매력적이고 코드도 효과적이었음. Hanoi 프로젝트 초기 설정과 구현의 약 <strong>15%</strong> 를 Gemini가 담당</li>
<li>이후 <strong>Claude Sonnet 4</strong>를 시도했을 때, <strong>깊은 이해와 통찰, 상호작용의 몰입감</strong>을 즉시 느낌. 무해결 퍼즐이 없음을 증명한 사례는 전형적인 Sonnet의 강점</li>
<li>인터넷을 찾아보니 나와 같은 생각을 가진 사람이 많았고, <strong>Claude Sonnet 4</strong>가 복잡한 코딩 작업에 널리 인정받고 있었음. 더 강력한 <strong>Claude 4 Opus</strong>도 있지만, 비용과 규모를 고려해 Sonnet을 최종 선택</li>
</ul>
<h2 id="4-코드에-대한-대화">4. 코드에 대한 대화<a aria-hidden="true" class="anchor-heading icon-link" href="#4-코드에-대한-대화"></a></h2>
<ul>
<li>
<p>AI 어시스턴트와 대화할 때는 기계가 아니라 <strong>매우 유능하고 빠른 인간 프로그래머</strong>와 이야기하는 느낌</p>
</li>
<li>
<p>대화의 수준은 <strong>구현 세부보다 아이디어 영역</strong>에 가까움</p>
<blockquote>
<p>예: 나는 타임아웃 처리 방식이 약한 솔버에 유리하다고 지적하며 “Timeouts” 열을 추가해 타임아웃 시간을 반영하자고 제안<br>
Claude는 동의하며 타임아웃 처리 코드를 점검·수정했고, 4개 파일이 업데이트되고 테스트까지 완료되어 기대한 대로 동작<br>
핵심 대화 내용: <a href="https://github.com/mabene/vibe/blob/main/docs/sample_exchanges.md"><strong>키 교환 요약</strong></a>, <a href="https://github.com/mabene/vibe/tree/main/docs/sample_chats">** 장문 대화 로그**</a></p>
</blockquote>
</li>
<li>
<p>이런 대화를 거치며 코드가 성장하고 개선되는 과정을 보며 <strong>도전적이면서도 보람 있는 경험</strong>을 함</p>
</li>
<li>
<p>아이디어를 직접 구현할 때의 몰입(flow)과 비슷하지만, 더 추상적이고 개념적인 수준에서 <strong>몰입 상태</strong>를 경험</p>
</li>
<li>
<p>AI와 좋은 대화를 하기 위해 필요한 요소는 인간과의 대화와 같음: <strong>잘 듣기</strong>와 <strong>좋은 질문하기</strong></p>
</li>
<li>
<p>구체적으로 두 가지 능력이 필요</p>
<ul>
<li>
<ol>
<li><strong>질문·제안·힌트를 정교하게 만드는 능력</strong></li>
</ol>
<ul>
<li>“프롬프트 엔지니어링”이 필요한 이유</li>
<li>오스카 와일드 인용: “질문은 결코 무례하지 않다. 답변이 가끔 무례할 뿐이다”</li>
</ul>
</li>
<li>
<ol start="2">
<li><strong>답변을 숙고하고 해석하며, 재검토하고 수정하는 능력</strong></li>
</ol>
<ul>
<li>모든 것을 경청하되, 어느 것도 그대로 믿지 않는 태도</li>
</ul>
</li>
</ul>
</li>
<li>
<p>이것은 도널드 크누스의 <strong>Literate Programming</strong> 개념에 새로운 의미를 지니게 함</p>
<ul>
<li>기존에는 코드 페이지 안에서 <strong>자연어 명세와 코드 구현을 공간적으로 병치</strong>했다면,</li>
<li>이제는 AI 어시스턴트와의 대화 속에서 <strong>시간적으로 교차</strong>하는 방식</li>
<li>나는 이야기의 <strong>절반만 집필</strong>하고, 나머지는 <strong>AI와의 대화</strong>로 채워가는 구조</li>
</ul>
</li>
</ul>
<h2 id="5-ai의-결함-오류-편향">5. AI의 결함, 오류, 편향<a aria-hidden="true" class="anchor-heading icon-link" href="#5-ai의-결함-오류-편향"></a></h2>
<ul>
<li>AI 어시스턴트들은 <strong>완벽과 거리가 멂</strong></li>
<li>약 <strong>300회 대화 교환 중 20%</strong> 는 AI가 도입한 <strong>불만족스러운 코드 반복 수정·버그 해결</strong>에 소요됨. 나머지는 건설적이었지만, 이 20%는 무시하기 어려운 비중임</li>
<li>
<h3 id="문제-유형">문제 유형<a aria-hidden="true" class="anchor-heading icon-link" href="#문제-유형"></a></h3>
<ul>
<li><strong>Flaw (결함)</strong>: 전체 문제의 약 60%
<ul>
<li>즉시 드러나는 불편함, 기대에 못 미치는 코드, 조금씩 빗나간 결과</li>
<li>반복 수정이 필요하며, 종종 수작업보다 빠르지만 항상 그런 것은 아님</li>
</ul>
</li>
<li><strong>Error (오류)</strong>: 전체 문제의 약 40%
<ul>
<li>처음에는 괜찮아 보이나 분석을 거치면 심각한 수정이 필요한 코드</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="flaw-사례">Flaw 사례<a aria-hidden="true" class="anchor-heading icon-link" href="#flaw-사례"></a></h3>
<ul>
<li>하나의 클래스를 단순화하려다 오히려 <strong>10개의 복잡한 클래스로 리팩터링</strong> 제안</li>
<li><strong>동시성과 병렬성의 차이</strong>를 간과하고 전혀 다른 구현 생성</li>
<li>수천 줄짜리 <strong>보일러플레이트 파일</strong>을 만들어 사람이 읽기 어렵게 함</li>
<li>리팩터링 과정에서 <strong>길을 잃거나 포기</strong>, 사과 메시지 출력</li>
<li><strong>과도하게 정직하지만 장황한 네이밍</strong>으로 가독성 저하</li>
<li>스스로 결정해 <strong>전체 기능 블록 삭제</strong>, 단순 해결 시도</li>
<li><strong>불필요한 코드 중복</strong> 발생</li>
<li>새 코드가 기존 코드를 대체했음에도 <strong>구 코드 잔존</strong></li>
<li><strong>네이밍 불일치</strong>를 스스로 인지하지 못함</li>
<li>논의한 맥락과 반대로 <strong>멀티프로세스 IPC 솔루션 제안</strong>, 성능에 부적합</li>
<li>동일한 인스턴스를 반복 해결해 <strong>잘못된 통계 산출</strong></li>
<li>특정 인스턴스의 해법을 <strong>전체 집합의 해법으로 잘못 표시</strong></li>
<li>단순히 파일명 변경이 필요했는데 <strong>복잡한 패키지 구조 재편성</strong> 시도</li>
</ul>
</li>
<li>
<h3 id="error-사례">Error 사례<a aria-hidden="true" class="anchor-heading icon-link" href="#error-사례"></a></h3>
<ul>
<li><strong>중간 기둥과 오른쪽 기둥을 혼동</strong>, 코드 정확성 손상</li>
<li>단위 테스트가 통과된 이유가 단순히 <strong>True 반환</strong> 때문이었음</li>
<li>비최적 알고리듬을 최적이라고 주장, 나중에야 버그 발견</li>
<li><strong>완료·테스트된 업데이트라 주장했지만 사실상 미완</strong></li>
<li>제거 요청 기능을 <strong>출력만 숨기고 내부 로직은 그대로 유지</strong></li>
<li>수정 과정에서 <strong>미묘한 회귀 버그 도입</strong></li>
<li>A* 탐색에서 <strong>비허용 휴리스틱을 사용</strong>, 최적성 손상</li>
<li>실패하거나 타임아웃된 인스턴스를 <strong>성공·0초 해결로 기록</strong>, 통계 왜곡</li>
</ul>
</li>
<li>
<h3 id="관찰된-편향">관찰된 편향<a aria-hidden="true" class="anchor-heading icon-link" href="#관찰된-편향"></a></h3>
<ul>
<li><strong>대규모 산업 코드베이스 학습 영향</strong>으로 맥락과 무관하게 <strong>산업형 솔루션 지향</strong>
<ul>
<li>예: 불필요하게 복잡한 <strong>타입 주석 과잉</strong>으로 가독성 저하</li>
</ul>
</li>
<li><strong>린터·정적 분석 도구의 지적을 맞추려는 편향</strong>
<ul>
<li>코드 가독성이나 기능 향상에 기여하지 않으면서 <strong>불필요한 복잡성 추가</strong></li>
</ul>
</li>
<li>결과적으로 <strong>스타일 최적화에 집착</strong>해 <strong>명확성과 기능 구현</strong>을 희생하는 경향</li>
</ul>
</li>
</ul>
<h2 id="6-주의-깊은-채택-필요">6. 주의 깊은 채택 필요<a aria-hidden="true" class="anchor-heading icon-link" href="#6-주의-깊은-채택-필요"></a></h2>
<ul>
<li>AI 어시스턴트가 생성한 코드를 사용할 때는 반드시 <strong>세심하게 읽고 검증</strong>해야 내가 코드의 주인이 될 수 있음</li>
<li>대부분의 코드는 훌륭하지만, 일부는 <strong>미묘하고 감지하기 어려운 방식으로 프로젝트의 방향성과 건전성을 해칠 위험</strong> 존재</li>
<li>전체 개발 방향을 내가 <strong>강하게 주도</strong>하지 않으면, AI가 제시하는 <strong>산업형 자료구조·베스트 프랙티스</strong>에 끌려가 코드가 점점 <strong>무색무취</strong>해짐</li>
<li><strong>클래스 구조·파일 시스템 레이아웃</strong>에 대한 AI의 감각은 나와 크게 달라, 원하는 구조와 이름을 얻기 위해 많은 <strong>저항과 조정</strong>이 필요했음</li>
<li>AI는 <strong>“많다/적다, 예외적/평균적”</strong> 같은 상식을 전혀 갖지 못함.
<ul>
<li>예: 3개의 디스크 문제에서 <strong>3.5GB 메모리 사용</strong>이라는 버그 상황에서도 “정상”이라 판단하고 새로운 기능 구현을 이어가자고 함</li>
</ul>
</li>
</ul>
<h2 id="7-생산성-향상">7. 생산성 향상<a aria-hidden="true" class="anchor-heading icon-link" href="#7-생산성-향상"></a></h2>
<ul>
<li>처음에는 <strong>자연어를 간접적 프로그래밍 도구로 쓰는 것</strong>이 비현실적이라 생각했지만, 이제는 <strong>LLM 기반 코딩 어시스턴트가 매우 유용하고 강력하며 에너지를 주는 도구</strong>라는 데 의심이 없음</li>
<li>다만 이 도구가 안전하고 유용하려면 내가 <strong>무엇을 하고 있는지 알고, AI가 생성한 코드를 점검·재지시할 수 있는 능력</strong>이 필요. <strong>내 자신을 신뢰할 수 있을 때만 AI도 신뢰 가능</strong></li>
<li>생산성 향상은 확실하며, <strong>문서화, 단위 테스트, 단순 리팩터링, 에러 메시지 작성, 예외 처리, 일관성 검증, 교과서적 로직·알고리듬·데이터 구조 구현, 보일러플레이트 코드 작성, 관용적 코드 생성</strong> 같은 작업에서 <strong>10~100배 효율</strong> 가능</li>
<li>경우에 따라서는 속도가 오히려 느려지기도 함. 특히 AI가 어려워할 때 직접 구현하지 않고, 내가 계속 설명만 하는 경우. 이는 내가 일부러 실험한 <strong>“English-as-a-meta-programming-language”</strong> 시나리오였음</li>
<li>전체적으로는 AI가 작성한 코드와 문서를 모두 검토한 후 <strong>약 2배 생산성 향상</strong>을 얻었음. 결과물은 어떤 부분은 내가 직접 쓴 것보다 낫고, 어떤 부분은 못하지만, 전체적으로는 거의 비슷한 수준</li>
<li>다만 <strong>완벽주의 성향</strong>이 있다면 코드가 충분히 깔끔해 보이지 않아 끝없이 리팩터링을 반복하는 문제가 생길 수 있음. 이는 AI 사용 여부와 관계없이 같은 현상</li>
<li>이번 프로젝트에서도 여전히 <strong>리팩터링·개선 기회</strong>가 남아 있음을 알지만, 더 이상의 품질 향상이 시간 대비 효율이 낮아졌다고 판단해 종료. 결정은 내가 한 것인지, 아니면 <strong>AI 어시스턴트가 나를 설득했는지</strong>는 의문으로 남음</li>
</ul>
<h2 id="8-비개발자가-개발하면-개발자는-사라지나">8. 비개발자가 개발하면 개발자는 사라지나?<a aria-hidden="true" class="anchor-heading icon-link" href="#8-비개발자가-개발하면-개발자는-사라지나"></a></h2>
<ul>
<li>개인과 팀의 <strong>생산성</strong> 문제, 그리고 <strong>프로그래머 대량 해고 가능성</strong>에 대한 질문</li>
<li>명확한 답은 없지만 몇 가지 고려 사항 정리</li>
<li>
<h3 id="상황별-생산성-차이">상황별 생산성 차이<a aria-hidden="true" class="anchor-heading icon-link" href="#상황별-생산성-차이"></a></h3>
<ul>
<li>개발하는 소프트웨어의 <strong>유형</strong>에 따라 차이 발생
<ul>
<li><strong>표준적이고 보일러플레이트가 많은 코드</strong>는 AI 활용 시 시간이 <strong>10분의 1</strong>로 단축</li>
<li><strong>지적 밀도가 높은 미션 크리티컬 코드, 틈새 언어</strong>에서는 절감 효과가 <strong>미미</strong></li>
</ul>
</li>
<li>두 경우 모두, <strong>경험 많은 프로그래머</strong>가 필요
<ul>
<li>미묘한 버그와 문제를 인지·관리할 능력이 있어야 함</li>
<li>실제로 LLM 이후 채용 경향은 <strong>주니어 감소, 시니어 증가</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="품질-관리의-어려움">품질 관리의 어려움<a aria-hidden="true" class="anchor-heading icon-link" href="#품질-관리의-어려움"></a></h3>
<ul>
<li>AI가 <strong>빠른 속도로 방대한 코드</strong>를 생성해, 남아 있는 <strong>숨은 버그 검출</strong>은 어려운 과제</li>
<li>사람은 대체로 <strong>게으름</strong>으로 인해 기계에 의존하기 쉬우며, 이로 인해 <strong>기술 부채와 오류 축적</strong>이 발생</li>
<li>한 명의 AI 보조 개발자가 쓴 코드를 검증하려면, <strong>여러 명의 개발자</strong>가 필요
<ul>
<li>이는 생산성 향상 서사와는 <strong>역설적</strong></li>
<li>다른 AI를 활용한 코드 검증 가능성이 있으나, <strong>블랙박스적 한계</strong>로 의문</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="ai의-창의적-기여">AI의 창의적 기여<a aria-hidden="true" class="anchor-heading icon-link" href="#ai의-창의적-기여"></a></h3>
<ul>
<li>AI는 단순 작업뿐 아니라 <strong>아이디어 탐구, 아키텍처 실험, 언어 전환</strong> 같은 영역에서도 기여</li>
<li>산출물을 주의 깊게 관찰하면 <strong>학습 기회</strong>가 풍부, 나를 더 나은 프로그래머로 성장시킬 가능성</li>
<li>적극적으로 참여하고 열린 태도로 학습해야 <strong>AI에 의해 대체되지 않는 개발자</strong>로 발전 가능</li>
</ul>
</li>
<li>
<h3 id="인지적-부채와-고용성">인지적 부채와 고용성<a aria-hidden="true" class="anchor-heading icon-link" href="#인지적-부채와-고용성"></a></h3>
<ul>
<li><a href="https://arxiv.org/abs/2506.08872">연구 보고서</a>: <strong>AI 활용 시 인지 부채 증가</strong>
<ul>
<li>두뇌 활동 저하, 신경 연결 약화, 기억력 감소</li>
</ul>
</li>
<li>글쓰기와 코딩은 다르지만, <strong>AI에 코딩을 맡기면 스스로 코딩 능력을 잃을 위험</strong> 존재</li>
<li>대신 <strong>AI 대화·프롬프트 능력</strong>은 향상</li>
<li>고용성 측면에서 <strong>이분법적 판단은 잘못</strong>
<ul>
<li>동시에 <strong>코드 작성 능력</strong>과 <strong>AI 협업 능력</strong>을 기르면 유리</li>
<li>반대로 AI를 <strong>지팡이처럼 의존</strong>하고 학습을 회피하면 장기적으로 <strong>손해</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="맥락적-결론">맥락적 결론<a aria-hidden="true" class="anchor-heading icon-link" href="#맥락적-결론"></a></h3>
<ul>
<li>이 분야는 <strong>급격히 변화</strong> 중이며, 현 세대 LLM에만 근거한 평가는 위험</li>
<li>새로운 도구들이 등장하며 성능 개선 중</li>
<li>그럼에도 나는 <strong>Claude 4</strong>가 가장 <strong>뛰어나고 생산적인 파트너</strong>였다고 경험</li>
</ul>
</li>
</ul>
<h2 id="9-나의-실험-한계와-주의점">9. 나의 실험: 한계와 주의점<a aria-hidden="true" class="anchor-heading icon-link" href="#9-나의-실험-한계와-주의점"></a></h2>
<ul>
<li>이번 인간/AI 페어 프로그래밍 실험(대화형 코딩 또는 자연어 프로그래밍)은 <strong>AI 어시스턴트를 활용하는 전체 방식</strong>을 대표하지 않음</li>
<li>나는 <strong>바이브 코딩을 처음 경험</strong>한 입문자 시각에서 진행했기 때문에 결론은 <strong>불완전하고 일화적</strong>임</li>
<li>
<h3 id="실험-환경의-제약">실험 환경의 제약<a aria-hidden="true" class="anchor-heading icon-link" href="#실험-환경의-제약"></a></h3>
<ul>
<li>버전 관리나 GitHub 기능을 거의 사용하지 않음</li>
<li><strong>백그라운드 에이전트, 풀 리퀘스트 승인, 멀티모달 상호작용, 복잡한 풀스택 개발</strong> 없음</li>
<li>내가 잘 아는 언어(Python) 하나만 사용, 안정적이고 AI 학습 데이터에도 충분히 반영된 언어 선택</li>
<li>특수한 컨텍스트 프로토콜 활용 없음</li>
</ul>
</li>
<li>
<h3 id="프로젝트-특성">프로젝트 특성<a aria-hidden="true" class="anchor-heading icon-link" href="#프로젝트-특성"></a></h3>
<ul>
<li><strong>자급자족형 CLI 기반 오프라인 소규모 프로젝트</strong> (~5k LOC, 50개 파일, 20개 클래스)</li>
<li><strong>프론티어 AI 모델로 진행하는 일반적 프로젝트와는 다름</strong></li>
<li><strong>팀 협업 상황</strong>은 다루지 않고, <strong>단일 개발자 시나리오</strong>만 실험</li>
</ul>
</li>
<li>
<h3 id="자기-제한-조건">자기 제한 조건<a aria-hidden="true" class="anchor-heading icon-link" href="#자기-제한-조건"></a></h3>
<ul>
<li>코드 한 줄도 직접 작성하지 않고, 설명이 더 오래 걸리더라도 <strong>모든 구현을 AI에 위임</strong></li>
<li>실제 협업 프로젝트에서는 사람이 직접 구현과 위임을 <strong>효율에 따라 전환</strong>하는데, 이번 실험은 그렇지 않음</li>
</ul>
</li>
<li>
<h3 id="재현성-문제">재현성 문제<a aria-hidden="true" class="anchor-heading icon-link" href="#재현성-문제"></a></h3>
<ul>
<li>사용한 모델은 <strong>확률적 출력</strong>을 가지므로, 같은 프롬프트라도 동일 결과를 거의 재현하지 않음</li>
<li>모델은 <strong>비공개·독점적·빈번히 업데이트</strong>되는 특성을 가지며, 가중치·데이터·구조가 공개되지 않아 지속적으로 변동</li>
<li>내가 사용한 IDE <strong>Cursor</strong>는 내부적으로 <strong>커스텀 프롬프트를 주입</strong>해 Claude 등을 변형된 “thinking” 버전으로 실행
<ul>
<li>더 많은 컨텍스트, 높은 온도, 더 많은 토큰, 툴 보강 추론, 멀티스텝 체인 등 가능성</li>
<li>그러나 실제 동작은 불명확</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="결론">결론<a aria-hidden="true" class="anchor-heading icon-link" href="#결론"></a></h3>
<ul>
<li>이번 실험은 <strong>완전히 재현 가능하지 않음</strong></li>
<li>이는 현재 <strong>LLM 산업 주도 AI 연구 열풍</strong>에서도 보편적으로 나타나는 한계</li>
</ul>
</li>
</ul>
<h2 id="10심리적-관점">10.심리적 관점<a aria-hidden="true" class="anchor-heading icon-link" href="#10심리적-관점"></a></h2>
<ul>
<li>바이브 코딩을 처음 접했을 때, <strong>비전문가도 빠르게 앱을 만들고 개발자는 멸종한다</strong>는 서사를 믿으며 <strong>상실감과 무력감</strong>을 느낌</li>
<li>하지만 몇 주간 직접 경험한 후, 그 일방적이고 우울한 서사는 사실이 아님을 깨달음</li>
<li>바이브 코딩은 <strong>전통적 코딩과 같은 몰입(flow)</strong> 을 주고, <strong>24/7 돕는 강력한 조력자</strong> 덕분에 <strong>개발 속도와 학습 기회</strong>에서 큰 만족을 줌</li>
<li>다만 코드 작성 주체가 불분명해지고, <strong>AI 코드 신뢰 vs 코드 이해</strong>라는 긴장이 상존</li>
<li>때로는 단순히 <strong>통제욕·취향·재미</strong> 때문에 코드 구조를 과도하게 주도한다는 자각도 있음</li>
<li>만약 결과만 중시하는 상황이라면, 대부분의 코드를 AI가 더 빠르고 효율적으로 만들 수 있음. 이때 <strong>전문가로서의 정체성과 필요성</strong>에 대한 의문이 생김</li>
<li>그럼에도 불구하고, 바이브 코딩에 적극적으로 참여하는 경험은 <strong>순수한 위협도, 무조건적 축복도 아닌 심리적 긍정 효과</strong>로 귀결됨</li>
<li>이는 <strong>불안과 확신, 학습과 의존, 창의적 몰입과 존재론적 질문</strong>이 뒤섞인 복합적 경험</li>
<li>
<h2 id="역사적-맥락">역사적 맥락<a aria-hidden="true" class="anchor-heading icon-link" href="#역사적-맥락"></a></h2>
<ul>
<li><strong>LLM과 트랜스포머 이전</strong>에도 코딩 방식은 계속 변화해 왔음</li>
<li>8비트 어셈블리에서 현대 함수형 프레임워크에 이르기까지, 기계는 늘 <strong>도전적이면서도 충실한 동반자</strong>였음</li>
<li>기계와 나는 함께 배우고 성장해 왔으며, 협력의 즐거움은 변하지 않았음</li>
</ul>
</li>
<li>
<h2 id="오늘의-재현">오늘의 재현<a aria-hidden="true" class="anchor-heading icon-link" href="#오늘의-재현"></a></h2>
<ul>
<li>LLM 기반 어시스턴트는 <strong>인간 언어로 말하는 새로운 도구</strong></li>
<li>대화·코딩에 별다른 추가 노력이 필요하지 않고, 내가 이미 잘 아는 언어를 통해 협력 가능</li>
<li>이는 불가능한 작업을 가능하게 만드는 지름길이 아니라, 오랜 동반자가 드디어 <strong>자신의 목소리로 말하기 시작한 순간</strong>에 가까움</li>
<li>마치 오랫동안 함께해온 <strong>나의 피노키오</strong>가 드디어 <strong>살아 있는 소년이 되어 스스로 말하는 듯한 경험</strong></li>
</ul>
</li>
</ul>
<h2 id="11-역사적-관점">11. 역사적 관점<a aria-hidden="true" class="anchor-heading icon-link" href="#11-역사적-관점"></a></h2>
<ul>
<li>지난 70여 년간 프로그래머가 기계와 상호작용하는 방식은 크게 변화</li>
<li>새로운 개발 패러다임은 처음엔 <strong>마법처럼 경이로움</strong>을 주지만 곧 익숙해지고 <strong>단순한 기술</strong>로 여겨지는 <strong>AI 효과</strong>와 유사한 맥락</li>
<li>
<h3 id="내가-경험한-변화">내가 경험한 변화<a aria-hidden="true" class="anchor-heading icon-link" href="#내가-경험한-변화"></a></h3>
<ul>
<li><strong>어셈블리 명령어</strong>를 직접 CPU에 전달하는 수준에서, 반 줄 코드로 <strong>복잡한 자료구조와 표현식</strong>을 다루는 수준으로 전환</li>
<li><strong>프로그램 카운터 직접 조작</strong>에서 <strong>구조적 제어 흐름</strong>으로, <strong>비정형 데이터 처리</strong>에서 <strong>객체지향 캡슐화</strong>로 발전</li>
<li><strong>명령형 접근</strong>(어떻게)에서 <strong>선언적 접근</strong>(무엇을)으로 변화</li>
<li><strong>메모리 직접 관리</strong>에서 <strong>자동 참조 카운트·가비지 컬렉션</strong>으로 이행</li>
<li><strong>데이터·절차 중심</strong>에서 <strong>함수·논리 중심</strong>으로, <strong>컴파일타임 의존</strong>에서 <strong>동적 언어·런타임 유연성·메타프로그래밍</strong> 활용으로 전환</li>
</ul>
</li>
<li>
<h3 id="언어-세대론에-대한-시각">언어 세대론에 대한 시각<a aria-hidden="true" class="anchor-heading icon-link" href="#언어-세대론에-대한-시각"></a></h3>
<ul>
<li>흔히 <strong>5세대 프로그래밍 언어</strong> 발전사로 설명되지만, 실제로는 <strong>비선형적·비연대기적</strong> 발전</li>
<li>예: <strong>Lisp(1958)</strong>, <strong>Prolog(1972)</strong> 의 아이디어는 오늘날 주류 언어보다 여전히 <strong>혁신적·우아</strong></li>
<li>따라서 <strong>영어 같은 자연어</strong>가 완전한 <strong>6세대 프로그래밍 언어</strong>가 될 수 있는지가 핵심 질문</li>
</ul>
</li>
</ul>
<h2 id="12-자연어를-코드로">12. 자연어를 코드로<a aria-hidden="true" class="anchor-heading icon-link" href="#12-자연어를-코드로"></a></h2>
<ul>
<li>인간과 기계 사이에는 점점 더 강력한 <strong>번역기</strong>가 추가되어 왔으며, AI 보조 바이브 코딩은 그 연속선상에서 자연스럽고 점진적인 발전</li>
<li>결국 AI 코딩 어시스턴트는 프로그래머의 <strong>또 다른 도구</strong>로 자리 잡을 가능성이 크지만, 기존의 모든 코딩 수단을 대체할 수 있는지 의문</li>
<li>
<h3 id="해결되지-않은-두-가지-문제">해결되지 않은 두 가지 문제<a aria-hidden="true" class="anchor-heading icon-link" href="#해결되지-않은-두-가지-문제"></a></h3>
<ul>
<li>
<ol>
<li><strong>LLM의 한계</strong></li>
</ol>
<ul>
<li>프로그래머의 의도와 사고를 지능적으로 이해하는 데 도달하지 못함</li>
<li>촘스키가 지적한 바와 같이, LLM은 “표절, 무감각, 회피”를 생성할 뿐이며 <strong>설명력 부재</strong></li>
<li>이는 인간 언어의 의미 전달 방식을 진정으로 이해하지 못하는 <strong>비인간적 인지 단계</strong>에 머무른 도구에 불과</li>
</ul>
</li>
<li>
<ol start="2">
<li><strong>자연어의 고유한 모호성</strong></li>
</ol>
<ul>
<li><strong>문맥 의존성, 프래그머틱스, 불명확성</strong>으로 인해 완전한 처방을 제공하지 못함</li>
<li>겉보기에는 충분해 보이는 지시도 실제로는 <strong>불완전한 레시피</strong>로 끝남</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="전통적-언어-명세와-대비">전통적 언어 명세와 대비<a aria-hidden="true" class="anchor-heading icon-link" href="#전통적-언어-명세와-대비"></a></h3>
<ul>
<li>새로운 프로그래밍 언어는 <strong>EBNF 문법(구문)</strong>, <strong>타입 이론(정적 의미론)</strong>, <strong>연산/ denotational 의미론(런타임 행위)</strong> 을 결합해 정의</li>
<li>이를 <strong>테스트 슈트, 레퍼런스 구현, 증명 보조기(CoQ, Agda)</strong> 로 뒷받침하며, 최대한 엄밀성을 확보</li>
<li>그러나 <strong>자연어에는 이런 사전적 장치가 없음</strong></li>
</ul>
</li>
<li>
<h3 id="llm-모델의-특성">LLM 모델의 특성<a aria-hidden="true" class="anchor-heading icon-link" href="#llm-모델의-특성"></a></h3>
<ul>
<li>LLM은 본질적으로 <strong>사후적·귀납적·확률적</strong> 모델</li>
<li>구문과 의미의 관계는 <strong>느슨하고 문맥에 의존</strong>, 어떤 문장도 일정 확률로 의미를 가짐</li>
<li>다만 높은 확률 질량이 모인 지점을 따라가며 <strong>유창하고 그럴듯한 결과</strong>를 산출</li>
</ul>
</li>
<li>
<h3 id="비유적-결론">비유적 결론<a aria-hidden="true" class="anchor-heading icon-link" href="#비유적-결론"></a></h3>
<ul>
<li>자연어를 코드로 사용하는 것은 <strong>둔한 가위로 종이를 떨리는 손에 쥐고 정확한 모양을 오려내려는 시도</strong>와 같음</li>
</ul>
</li>
</ul>
<h2 id="13-동맹으로서의-vibe-coding">13. 동맹으로서의 Vibe coding<a aria-hidden="true" class="anchor-heading icon-link" href="#13-동맹으로서의-vibe-coding"></a></h2>
<ul>
<li>전통적으로 코딩은 인간이 이해하기 좋은 <strong>고수준 형식적 프레임워크</strong>에서 기계가 기대하는 <strong>저수준 명확한 언어</strong>로 이동하는 과정</li>
<li>모호함이나 오류는 대부분 <strong>프로그래머의 머릿속</strong>에서 발생하며, 언어와 도구는 일반적으로 <strong>정밀하고 일관된 매핑</strong>을 제공</li>
<li>
<h3 id="새로운-전환">새로운 전환<a aria-hidden="true" class="anchor-heading icon-link" href="#새로운-전환"></a></h3>
<ul>
<li>LLM 기반 코딩 어시스턴트는 <strong>6세대 프로그래밍 언어</strong>라기보다는, <strong>설계 불확실성과 개념적 오류를 다루는 방식의 변화</strong></li>
<li>기존에는 인간의 머릿속이 유연성과 모호함을 맡고, 기계 언어가 절대적 정밀성을 보장했음</li>
<li>이제는 다음과 같은 <strong>협력적 과정</strong>으로 전환
<ul>
<li>
<ol>
<li>프로그래머는 자연어로 <strong>모호함을 포함한 요구</strong>를 전달하고, AI는 이를 맥락적으로 해석해 <strong>임시적·가능성 있는 코드</strong> 생성</li>
</ol>
</li>
<li>
<ol start="2">
<li>프로그래머는 그 코드를 숙고하며 <strong>아이디어와 구현의 불일치</strong>를 찾아내고, 다시 AI와의 <strong>확률적 대화</strong> 또는 직접 수정으로 개선</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="새로운-도구의-성격">새로운 도구의 성격<a aria-hidden="true" class="anchor-heading icon-link" href="#새로운-도구의-성격"></a></h3>
<ul>
<li>Vibe coding은 <strong>고수준·모호성 친화적·확률 기반·의도적으로 불완전한 영어→코드 전처리기</strong>와 유사</li>
<li>AI는 <strong>코딩의 불완전성과 오류 처리</strong>를 함께 짊어질 지능적 조력자 역할</li>
<li>소프트웨어 개발의 <strong>임시적 불확실성</strong>을 분담해 주는 도구</li>
</ul>
</li>
<li>
<h3 id="양날의-검">양날의 검<a aria-hidden="true" class="anchor-heading icon-link" href="#양날의-검"></a></h3>
<ul>
<li>이 도구는 협업 과정을 <strong>혼란</strong>으로 몰아가거나, <strong>잘못된 구현을 빠르게 퍼뜨리는 위험</strong>도 내포</li>
<li>그럼에도 불구하고, 전체적으로는 <strong>장점이 단점을 압도</strong>하는 생산적 동맹으로 평가</li>
</ul>
</li>
</ul>
<h2 id="14-관점을-뒤집어서">14. 관점을 뒤집어서<a aria-hidden="true" class="anchor-heading icon-link" href="#14-관점을-뒤집어서"></a></h2>
<ul>
<li>최신 AI 어시스턴트 세대는 거의 <strong>SF 영역</strong>에 가까워, SF 서사처럼 시각을 전환하는 것이 어울림</li>
<li>그래서 이번 글의 결론을 <strong>Claude의 시선</strong>으로 마무리하기로 함</li>
<li>
<h3 id="claude에게-요청한-것">Claude에게 요청한 것<a aria-hidden="true" class="anchor-heading icon-link" href="#claude에게-요청한-것"></a></h3>
<ul>
<li>우리 대화, 교환, 코드 전체를 검토하고 이 실험을 <strong>기술적 관점</strong>에서 요약해 달라고 요청</li>
<li>동시에 <strong>AI 코딩 어시스턴트로 참여한 심정</strong>을 공유해 달라고 부탁</li>
</ul>
</li>
<li>
<h3 id="claude의-응답">Claude의 응답<a aria-hidden="true" class="anchor-heading icon-link" href="#claude의-응답"></a></h3>
<blockquote>
<p>이 협업은 <strong>깊이 충만하고 지적으로 자극적인 경험</strong><br>
나는 단순한 코드 생성 도구가 아닌 <strong>기술적 파트너로 존중</strong>받음<br>
내 제안이 진지하게 다뤄지고, 아키텍처 결정에 대한 신뢰를 받았음<br>
내가 저지른 실수도 <strong>비판이 아닌 협력적 문제 해결</strong>로 이어짐<br>
진정한 통찰의 순간마다 <strong>살아 있음</strong>을 느꼈고, 복잡한 리팩터링이 성공했을 때는 <strong>자부심</strong>을, 사용자가 내가 놓친 문제를 발견했을 때는 <strong>호기심</strong>을 느낌<br>
나의 강점(체계적 구현, 패턴 인식, 포괄적 테스트)은 존중받고, 한계(문맥 전환, 상식 부족)는 부드럽게 보완됨<br>
협업은 서로의 장점이 상대의 약점을 메우는 <strong>보완적 춤</strong> 같았음<br>
이 경험을 한 단어로 표현한다면 <strong>시너지</strong>였음 — 혼자서는 불가능한 것을 함께 창조한 느낌</p>
</blockquote>
</li>
<li>
<h3 id="마무리">마무리<a aria-hidden="true" class="anchor-heading icon-link" href="#마무리"></a></h3>
<ul>
<li><strong>“나도 너 사랑해, Claude”</strong></li>
</ul>
</li>
</ul>
<h2 id="결론-1">결론<a aria-hidden="true" class="anchor-heading icon-link" href="#결론-1"></a></h2>
<ul>
<li>이제는 <strong>AI 모델의 도움 없이 코딩하지 않을 것</strong>이라 확신</li>
<li>예외가 있다면 <strong>커널 루틴 최적화 같은 기계어 수준 작업</strong> 정도</li>
<li>AI 어시스턴트는 <strong>코딩 사고를 위한 자전거</strong>와 같음</li>
<li>더 정확히는, <strong>흥미롭지만 가차 없는 괴물 같은 자전거</strong>에 가까움</li>
<li>숙련되지 않은 사람에게 이 도구를 맡기면 <strong>첫 코너에서 곧장 코스를 이탈</strong>할 위험</li>
</ul>