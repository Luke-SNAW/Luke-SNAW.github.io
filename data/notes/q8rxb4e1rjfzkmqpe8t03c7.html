<h1 id="on-starting-a-side-project-hotwire-vs-angular">On Starting A Side-Project: Hotwire vs. Angular<a aria-hidden="true" class="anchor-heading icon-link" href="#on-starting-a-side-project-hotwire-vs-angular"></a></h1>
<blockquote>
<p><a href="https://www.bennadel.com/blog/4458-on-starting-a-side-project-hotwire-vs-angular.htm">https://www.bennadel.com/blog/4458-on-starting-a-side-project-hotwire-vs-angular.htm</a></p>
</blockquote>
<p>For the last few months, <a href="https://www.bennadel.com/blog/4396-setting-up-my-coldfusion-hotwire-demos-playground.htm" title="Read article: Setting Up My ColdFusion + Hotwire Demos Playground">I've been digging into the Hotwire framework</a>. I was initially drawn to Hotwire on its promise of allowing me to build a SPA (Single-Page Application)-like experience using an MPA (Multi-Page Application); and, to do so with <em>less effort</em>. After several months of creating demos and migrating this ColdFusion blog over to using Hotwire, I feel like I have a much better sense of how Turbo Drive, Turbo Streams, and Stimulus work. But, I'm not quite sure that I want to use Hotwire when I start my next side-project.</p>
<p><strong>CAUTION</strong>: This blog post is very much me <em>talking to myself</em>, trying to figure some things out.</p>
<h2 id="im-happy-that-i-updated-my-blog-to-use-hotwire"><a href="https://www.bennadel.com/blog/4458-on-starting-a-side-project-hotwire-vs-angular.htm#im-happy-that-i-updated-my-blog-to-use-hotwire" title="Link directly to this section: I&#x27;m Happy That I Updated My Blog to Use Hotwire"></a>I'm Happy That I Updated My Blog to Use Hotwire<a aria-hidden="true" class="anchor-heading icon-link" href="#im-happy-that-i-updated-my-blog-to-use-hotwire"></a></h2>
<p>I used this blog as a laboratory for learning about Hotwire. Prior to this, I had <em>no framework at all</em>. Sure, I had jQuery, which I eventually <a href="https://www.bennadel.com/blog/4184-replacing-jquery-110kb-with-umbrella-js-8kb.htm" title="Read article: Replacing jQuery (110kb) With Umbrella JS (8kb)">replaced with Umbrella JS</a>; but, there was nothing really tying everything together. As such, moving to Hotwire somewhat forced me to organize my code better.</p>
<p>Plus, I do love the fact that Hotwire creates a <em>persistent process</em>, which reduces the amount of work each <em>subsequent navigation event</em> has to incur. Of course, this is a "blog" where the number of pages viewed is "1" in the vast majority of cases; so, the relevance of a "subsequent navigation event" is a matter of much debate.</p>
<p>I'm also thankful that Hotwire encouraged me to think about <strong>progressive enhancement</strong> and creating an experience that would still work if the JavaScript failed to load. I do believe that this is a <em>critical ingredient</em> for any <em>public facing</em> site. And, it has certainly made this site more resilient.</p>
<p>In the end, if I were to build another public facing "content" site, <strong>I do believe that I would choose Hotwire</strong>. I also believe that I might choose it for any "simple" back-end administrative system.</p>
<h2 id="hotwire-doesnt-address-some-important-problems"><a href="https://www.bennadel.com/blog/4458-on-starting-a-side-project-hotwire-vs-angular.htm#hotwire-doesnt-address-some-important-problems" title="Link directly to this section: Hotwire Doesn&#x27;t Address Some Important Problems"></a>Hotwire Doesn't Address Some Important Problems<a aria-hidden="true" class="anchor-heading icon-link" href="#hotwire-doesnt-address-some-important-problems"></a></h2>
<p>I understand that a lot of the uphill battle with Hotwire - with <em>anything new</em> - is lack of experience. I've been building-up a completely new mental model, and it's not always obvious how things are supposed to be done. But, after a few months of experience, I'm beginning to see that Hotwire doesn't really address a certain set of problems. Here are some things that still seem fuzzy and unanswered in my mind:</p>
<ul>
<li><strong>Scoping of Names</strong>: Hotwire uses the DOM (Document Object Model) as the source of truth; and, maps DOM attributes to Stimulus Controllers. As such, every controller has to be uniquely named. As an application grows and evolves, I suspect that Controller names will have to get longer and more complex in order to remain unique. And, since controller names are included in every "action", "param", and "target" target as well, the DOM is going to get wordy!
<blockquote>
<p><strong>ASIDE</strong>: I've see this with other Dependency-Injection (DI) frameworks as well. In fact, in my AngularJS 1.x apps, I've started to prefix my Component tag-names with <code>m{x}</code> where <code>x</code> is a globally-unique counter. Example <code>&#x3C;m44-team-members></code> and <code>&#x3C;m97-email-recipients></code>. This way, I can avoid naming collisions without having to create artificially complex names.</p>
</blockquote>
</li>
<li><strong>Scoping of CSS</strong>: Most of the Hotwire examples on the web seem to use Tailwind CSS. And, I suspect that some of the impetus behind this is a lack of any native CSS scoping. Since there's no inherent compilation step in a Hotwire application, there's no hook that allows Hotwire to inject template modifications that enable scoping.</li>
<li><strong>Encapsulated Interfaces</strong>: While reusing templates for rendering is a core part of the Hotwire way, this doesn't directly address the need to encapsulate complex interfaces. Ruby on Rails has some helpers for this; but, if you're not using Rails, you're on your own.</li>
<li><strong>Layered Routing</strong>: If your application is "flat," in that a URL route only ever maps to a single page, Hotwire "just works". But, if you want to start using "auxiliary routes" to represent page state - such as making a modal window deep-linkable from <em>anywhere</em> in the application - there's no a great <em>native way</em> to do this. You can use Turbo Frames with an <code>advance</code> action to change the URL; but, this doesn't really address the page-refresh issue; or, the need to simply close the modal window and revert back to the previous URL.</li>
<li><strong>Error Handling</strong>: Whether it be a <code>401 Unauthorized</code> error or a <code>500 Server Error</code>, handling failures in Hotwire is non-obvious. You can hook into <em>events</em> and <em>override rendering</em>; however, since Hotwire is doing all the fetching <em>for you</em>, there's no clear place to put this kind of logic. And, since Turbo Frames and top-level requests seem to fail in <em>different ways</em>, handling errors is all the more complex.</li>
</ul>
<p>Now, again, I have to stress that I only have a <em>few months</em> experience with Hotwire; so, <strong>take this all with some healthy apprehension</strong>. Plus, the Basecamp team has built Basecamp and HEY, both of which are highly dynamic, interactive applications. So, if you really know what you're doing, it's clear that Hotwire gives you the tools to get it done.</p>
<h2 id="is-hotwire-really-less-work"><a href="https://www.bennadel.com/blog/4458-on-starting-a-side-project-hotwire-vs-angular.htm#is-hotwire-really-less-work" title="Link directly to this section: Is Hotwire Really Less Work?"></a>Is Hotwire Really Less Work?<a aria-hidden="true" class="anchor-heading icon-link" href="#is-hotwire-really-less-work"></a></h2>
<p>Part of the Hotwire messaging is that building an application is going to be less work. But, I'm not sure it actually works-out that way. I believe that, more than anything, aspects of the control-flow just live in different places. But, I don't believe that there's actually <em>less stuff</em> to build.</p>
<p>Consider a "Contact" form. With a Contact form I need:</p>
<ul>
<li>A controller action to render the form.</li>
<li>The form HTML itself.</li>
<li>A controller action to receive the submission.</li>
<li>The business logic to process the submission.</li>
<li>A controller action to render the Thank you.</li>
<li>The Thank you HTML itself.</li>
</ul>
<p>With Hotwire, that's all done server-side. <em>Without Hotwire</em>, some of that is server-side and some of that is client-side. Furthermore, the server-side parts are likely spread out across page-controllers and API-controllers. But, there's nothing here that I would <em>remove</em> when using Hotwire; nor is there anything that I would <em>add</em> when using a single-page application. It's the same stuff, it's just in different places.</p>
<p>Of course, if you're using Hotwire because you get to use the server-side technology more often, then it's <em>not the volume</em> of "stuff" that matters, it's the <em>implementation of the stuff</em> that makes the difference for you.</p>
<h2 id="hotwires-back-button-is-fundamentally-better"><a href="https://www.bennadel.com/blog/4458-on-starting-a-side-project-hotwire-vs-angular.htm#hotwires-back-button-is-fundamentally-better" title="Link directly to this section: Hotwire&#x27;s &#x22;Back Button&#x22; is Fundamentally Better"></a>Hotwire's "Back Button" is Fundamentally Better<a aria-hidden="true" class="anchor-heading icon-link" href="#hotwires-back-button-is-fundamentally-better"></a></h2>
<p>One thing that Hotwire <em>clearly gets right</em> is the <strong>Back Button</strong>. When you hit the back button in a Hotwire application, Turbo Drive just pulls the page out of the cache and renders it instantly. This is something that <strong>no Single-Page Application can really do quite as well</strong> (or so it seems).</p>
<h2 id="hotwire-leads-to-more-reusable-widgets"><a href="https://www.bennadel.com/blog/4458-on-starting-a-side-project-hotwire-vs-angular.htm#hotwire-leads-to-more-reusable-widgets" title="Link directly to this section: Hotwire Leads to More Reusable Widgets"></a>Hotwire Leads to More Reusable Widgets<a aria-hidden="true" class="anchor-heading icon-link" href="#hotwire-leads-to-more-reusable-widgets"></a></h2>
<p>If I were to choose Angular for my next side-project, then all the widgets I built would end up working in an Angular-only context. Which means, if I had something special - like a "Fancy Select Box" - I couldn't use it on any View outside of the Angular app.</p>
<p>With Hotwire, on the other hand, since everything is based on server-side partial reuse, any widget can be used anywhere (as long as you're loading Hotwire). Well, I mean, sort of - it depends on whether that widget was built to work via progressive enhancement.</p>
<h2 id="its-all-about-trade-offs"><a href="https://www.bennadel.com/blog/4458-on-starting-a-side-project-hotwire-vs-angular.htm#its-all-about-trade-offs" title="Link directly to this section: It&#x27;s All About Trade-Offs"></a>It's All About Trade-Offs<a aria-hidden="true" class="anchor-heading icon-link" href="#its-all-about-trade-offs"></a></h2>
<p>There's no clear-cut winner here. The reason I'm even writing this post is because <strong>I'm conflicted</strong>; and, the writing helps me think-through the problem. I think there are some things that Hotwire does really well; and, I think there are some points of friction. The question then becomes, are the benefits worth the drawbacks?</p>
<p>If I needed the site to work <em>without JavaScript</em>, it would be a non-issue - Hotwire all the way. Its "progressive enhancement" approach is a true winner.</p>
<p>But, if I'm creating a site that has decided to rely on JavaScript, are the drawbacks of Hotwire "less bad" than the drawbacks of something like Angular? Angular has added complexity, no doubt. But, it also brings a ton of value to the table. If I'm going to buy into JavaScript, then the value-add of Angular is well worth it.</p>
<p>Much to consider!</p>
<hr>
<h2 id="comments">Comments<a aria-hidden="true" class="anchor-heading icon-link" href="#comments"></a></h2>
<p>The other <em>relatively large drawback</em> to using Hotwire is that it <a href="https://www.bennadel.com/blog/4381-hotwire-turbo-drive-doesnt-work-with-cfm-page-extensions.htm" title="Read article: Hotwire Turbo Drive Doesn&#x27;t Work With .cfm Page Extensions">doesn't working with <code>.cfm</code> file extensions natively</a>. Which means, any site that uses Hotwire will <em>also have to use</em> some sort of <strong>URL-rewriting</strong> that maps all <code>.htm</code> requests to <code>.cfm</code> requests. This isn't a huge deal; but, it does add another layer of complexity where I have to define route-definitions. If I use Angular, it doesn't matter what the URLs look like.</p>