<h1 id="solidjs-feels-like-what-i-always-wanted-react-to-be">Solid.js feels like what I always wanted React to be<a aria-hidden="true" class="anchor-heading icon-link" href="#solidjs-feels-like-what-i-always-wanted-react-to-be"></a></h1>
<p><a href="https://typeofnan.dev/solid-js-feels-like-what-i-always-wanted-react-to-be/">https://typeofnan.dev/solid-js-feels-like-what-i-always-wanted-react-to-be/</a></p>
<h1 id="hooks-are-pretty-neat-but-error-prone">Hooks are pretty neat, but error-prone.<a aria-hidden="true" class="anchor-heading icon-link" href="#hooks-are-pretty-neat-but-error-prone"></a></h1>
<h1 id="faux-reactivity">Faux reactivity<a aria-hidden="true" class="anchor-heading icon-link" href="#faux-reactivity"></a></h1>
<p>I’ve thought a lot about hooks and why they don’t feel quite right.</p>
<p>The problem with React hooks is that <em>React isn’t truly reactive</em>. If a linter knows when an effect (or callback, or memo) hook is missing a dependency, then why can’t the framework automatically detect dependencies and react to those changes?</p>
<h1 id="but-what-about-hooks-of-solidjs">But what about hooks of Solid.js?<a aria-hidden="true" class="anchor-heading icon-link" href="#but-what-about-hooks-of-solidjs"></a></h1>
<p>... And we didn’t even have to tell Solid that the effect was dependent on the <code>count</code> variable.</p>
<h1 id="more-interesting-solid-concepts">More interesting Solid concepts<a aria-hidden="true" class="anchor-heading icon-link" href="#more-interesting-solid-concepts"></a></h1>
<h2 id="reactivity-not-lifecycle-hooks">Reactivity, not lifecycle hooks<a aria-hidden="true" class="anchor-heading icon-link" href="#reactivity-not-lifecycle-hooks"></a></h2>
<p>If you’ve been in React-land for a while, the following code change might be really eyebrow-raising:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createSignal</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">createEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The count is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">The count is: </span><span class="token punctuation">{</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>div</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>And the code still works. Our <code>count</code> signal doesn’t need to live in a component function, nor do the effects that rely on it. Everything is just a part of the reactive system and “lifecycle hooks” really don’t play much of a role.</p>
<h2 id="fine-grained-dom-updates">Fine-grained DOM updates<a aria-hidden="true" class="anchor-heading icon-link" href="#fine-grained-dom-updates"></a></h2>
<p>So far I’ve been focusing a lot on developer experience (e.g., more easily writing non-buggy code), but Solid is also getting a lot of praise for its performance. One key to its strong performance is that it interacts directly with the DOM (no virtual DOM) and it performs “fine-grained” DOM updates.</p>