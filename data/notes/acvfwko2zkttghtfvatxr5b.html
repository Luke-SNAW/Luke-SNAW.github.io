<h1 id="use-maps-more-and-objects-less">Use Maps More and Objects Less<a aria-hidden="true" class="anchor-heading icon-link" href="#use-maps-more-and-objects-less"></a></h1>
<blockquote>
<p><a href="https://www.builder.io/blog/maps">https://www.builder.io/blog/maps</a></p>
</blockquote>
<p>Objects in JavaScript are awesome. They can do anything! Literally‚Ä¶anything.</p>
<p>But, like all things, just because you <em>can</em> do something, doesn‚Äôt (necessarily) mean you <em>should.</em></p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// üö©</span>
<span class="token keyword">const</span> mapOfThings <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

mapOfThings<span class="token punctuation">[</span>myThing<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">]</span> <span class="token operator">=</span> myThing

<span class="token keyword">delete</span> mapOfThings<span class="token punctuation">[</span>myThing<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">]</span>
</code></pre>
<p>For instance, if you're using objects in JavaScript to store arbitrary key value pairs where you'll be adding and removing keys frequently, you should really consider using a <code>map</code> instead of a plain object.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// ‚úÖ</span>
<span class="token keyword">const</span> mapOfThings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

mapOfThings<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span>myThing<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span> myThing<span class="token punctuation">)</span>

mapOfThings<span class="token punctuation">.</span><span class="token method function property-access">delete</span><span class="token punctuation">(</span>myThing<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="performance-issues-with-objects">Performance issues with objects<a aria-hidden="true" class="anchor-heading icon-link" href="#performance-issues-with-objects"></a></h3>
<p>Whereas with objects, where the delete operator is notorious for poor performance, maps are optimized for this exact use case and in some cases can be seriously faster.</p>
<p><a href="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fdefb300b5ebe42108d9ab813d3b99b5f?width=705">Benchmark result (from the below link) showing Maps about 5x faster in this benchmark compared to Objects</a></p>
<p>Note of course this is just one <a href="https://perf.builder.io/?q=eyJpZCI6IndkbG1kbG94cm5nIiwidGl0bGUiOiJNYXAgdnMgT2JqZWN0IFBlcmZvcm1hbmNlIiwiYmVmb3JlIjoiY29uc3QgcmFuZG9tS2V5ID0gKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApXG5jb25zdCBkYXRhID0gWy4uLkFycmF5KDEwMDAwKV0ubWFwKHJhbmRvbUtleSlcbmNvbnN0IG9iaiA9IE9iamVjdC5mcm9tRW50cmllcyhkYXRhLm1hcCh4ID0%2BIFt4LCB4XSkpXG5jb25zdCBtYXAgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG9iaikpIiwidGVzdHMiOlt7Im5hbWUiOiJNYXAiLCJjb2RlIjoiLy8gRnJlZXplIHRoZSBrZXlzIGxpc3QgKHdlIGRvbid0IHdhbnQgdG8gbXV0YXRlIHdoaWxlIGl0ZXJhdGluZylcbmNvbnN0IGtleXMgPSBBcnJheS5mcm9tKG1hcC5rZXlzKCkpXG5mb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gIC8vIERlbGV0ZSBrZXlcbiAgbWFwLmRlbGV0ZShrZXkpXG4gIC8vIENyZWF0ZSBhIHJhbmRvbSBuZXcga2V5XG4gIGNvbnN0IG5ld0tleSA9IHJhbmRvbUtleSgpXG4gIG1hcC5zZXQobmV3S2V5LCBuZXdLZXkpXG59IiwicnVucyI6W10sIm9wcyI6OTAxfSx7Im5hbWUiOiJPYmplY3QiLCJjb2RlIjoiY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iailcbmZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgLy8gRGVsZXRlIGtleVxuICBkZWxldGUgb2JqW2tleV1cbiAgLy8gQ3JlYXRlIGEgcmFuZG9tIG5ldyBrZXlcbiAgY29uc3QgbmV3S2V5ID0gcmFuZG9tS2V5KClcbiAgb2JqW25ld0tleV0gPSBuZXdLZXlcbn0iLCJydW5zIjpbXSwib3BzIjoxODN9XSwidXBkYXRlZCI6IjIwMjMtMDItMDlUMDc6MDk6MzQuMjY2WiJ9">example benchmark</a> (run with Chrome v109 on a Core i7 MBP). You can also compare <a href="https://www.notion.so/Use-Maps-more-and-Objects-less-Outline-6f3e4c17e18543908ddde250ad9d2315">another benchmark</a> created by <a href="https://www.zhenghao.io/posts/object-vs-map#performance-extravaganza">Zhenghao He</a>. Just keep in mind ‚Äî micro benchmarks like this are <a href="https://mrale.ph/blog/2012/12/15/microbenchmarks-fairy-tale.html">notoriously imperfect</a> so take them with a grain of salt.</p>
<p>That said, you don‚Äôt need to trust my or anyone else‚Äôs benchmarks, as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#objects_vs._maps">MDN itself clarifies that maps are specifically optimized for this use case</a> of frequently adding and removing keys, as compared with an object that is not as optimized for this use case:</p>
<p><a href="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F0d08535f5d2e4c5bbefe257c58103d25?width=705">Screenshot of the MDN docs pointing to Maps being mentioned to have better performance than Objects for scenarios that involve frequent additions and removals of key-value pairs</a></p>
<p>If you are curious why, it has to do with how JavaScript VMs optimize JS objects by assuming their <a href="https://mathiasbynens.be/notes/shapes-ics">shape</a>, whereas a map is purpose-built for the use case of a hashmap where keys are dynamic and ever-changing.</p>
<p>Read more about how VMs assume shapes in this thread by Mi≈°ko (CTO of <a href="https://www.builder.io/">Builder.io</a>, and creator of Angular and <a href="https://qwik.builder.io/">Qwik</a>):</p>
<p>Another great article is <a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">What‚Äôs up with monomorphism</a>, which explains the performance characteristics of objects in JavaScript, and why they are not as optimized for hashmap-like use cases of frequently adding and removing keys.</p>
<p><img src="https://pbs.twimg.com/media/FoRGcweaQAQjB1g.png" alt="Understanding monomorphism can improve your JavaScript performance 60x."></p>
<p>But beyond performance, maps also solve for several issues that exist with objects.</p>
<h3 id="built-in-keys-problem">Built-in keys problem<a aria-hidden="true" class="anchor-heading icon-link" href="#built-in-keys-problem"></a></h3>
<p>One major issue of objects for hashmap-like use cases is that objects are polluted with tons of keys built into them already. <em>WHAT?</em></p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> myMap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

myMap<span class="token punctuation">.</span><span class="token property-access">valueOf</span> <span class="token comment">// => [Function: valueOf]</span>
myMap<span class="token punctuation">.</span><span class="token property-access">toString</span> <span class="token comment">// => [Function: toString]</span>
myMap<span class="token punctuation">.</span><span class="token property-access">hasOwnProperty</span> <span class="token comment">// => [Function: hasOwnProperty]</span>
myMap<span class="token punctuation">.</span><span class="token property-access">isPrototypeOf</span> <span class="token comment">// => [Function: isPrototypeOf]</span>
myMap<span class="token punctuation">.</span><span class="token property-access">propertyIsEnumerable</span> <span class="token comment">// => [Function: propertyIsEnumerable]</span>
myMap<span class="token punctuation">.</span><span class="token property-access">toLocaleString</span> <span class="token comment">// => [Function: toLocaleString]</span>
myMap<span class="token punctuation">.</span><span class="token property-access">constructor</span> <span class="token comment">// => [Function: Object]</span>
</code></pre>
<p>So if you try and access any of these properties, each of them has values already even though this object is supposed to be empty.</p>
<p>This alone should be a clear reason not to use an object for an arbitrary-keyed hashmap, as it can lead to some really hairy bugs you‚Äôll only discover later.</p>
<h3 id="iteration-awkwardness">Iteration awkwardness<a aria-hidden="true" class="anchor-heading icon-link" href="#iteration-awkwardness"></a></h3>
<p>Speaking of strange ways that JavaScript objects treat keys, iterating through objects is riddled with gotchas.</p>
<p>For instance, you may already know not to do this:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> myObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// üö© You may stumble upon some inherited keys you didn't mean to</span>
<span class="token punctuation">}</span>
</code></pre>
<p>And you may have been told instead to do this:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> myObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>myObject<span class="token punctuation">.</span><span class="token method function property-access">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// üö©</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>But this is still problematic, as <code>myObject.hasOwnProperty</code> can easily be overridden with any other value. Nothing is preventing anyone from doing <code>myObject.hasOwnProperty = () => explode()</code>.</p>
<p>So instead you should really do this funky mess:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> myObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token property-access">prototype</span><span class="token punctuation">.</span><span class="token method function property-access">hasOwnProperty</span><span class="token punctuation">.</span><span class="token method function property-access">call</span><span class="token punctuation">(</span>myObject<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// üòï</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Or if you prefer your code to not look like a mess, you can use the more recently added <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn"><code>Object.hasOwn</code></a>:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> myObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">hasOwn</span><span class="token punctuation">(</span>myObject<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// üòê</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Or you can give up on a <code>for</code> loop entirely and just use <code>Object.keys</code> with <code>forEach</code>.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span>myObject<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// üò¨</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>However, with maps, there are no such issues at all. You can use a standard <code>for</code> loop, with a standard iterator, and a really nice destructuring pattern to get both the <code>key</code> and <code>value</code> at once:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> myMap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// üòç</span>
<span class="token punctuation">}</span>
</code></pre>
<p><em>Me gusta.</em></p>
<p>In fact, this is so nice, we now have an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries</code></a> method to do similar with objects. It's one additional step so doesn't feel quite so first-class, but hey it works.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">entries</span><span class="token punctuation">(</span>myObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// üôÇ</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Add that one to the long list of "loops in objects are ugly so choose one of the following 5 options you prefer".</p>
<p>But for Maps, it's nice to know there is one simple and elegant way to iterate built in directly.</p>
<p>Additionally, you can iterate over just keys or values as well:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> myMap<span class="token punctuation">.</span><span class="token method function property-access">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// üôÇ</span>
<span class="token punctuation">}</span>

<span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> myMap<span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// üôÇ</span>
<span class="token punctuation">}</span>
</code></pre>
<h3 id="key-ordering">Key ordering<a aria-hidden="true" class="anchor-heading icon-link" href="#key-ordering"></a></h3>
<p>One additional perk of maps is they preserve the order of their keys. This has been a long asked for quality of objects, and now exists for maps.</p>
<p>This gives us another very cool feature, which is that we can destructure keys directly from a map, in their exact order:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> myMap
</code></pre>
<p>This can also open up some interesting use cases, like trivially implementing an O(1) LRU Cache:</p>
<blockquote>
<p>One cool use case for Maps - creating a simple O(1) LRU cache</p>
<p>Given how Maps preserve the order of their keys, implementation is trivial:<br>
<a href="https://t.co/HkMyzL03o0">https://t.co/HkMyzL03o0</a></p>
</blockquote>
<h3 id="copying">Copying<a aria-hidden="true" class="anchor-heading icon-link" href="#copying"></a></h3>
<p>Now you might say, <em>oh, well, objects have some advantages, like they're very easy to copy</em>, for instance, using an object spread or assign.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> copied <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span>myObject <span class="token punctuation">}</span>
<span class="token keyword">const</span> copied <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> myObject<span class="token punctuation">)</span>
</code></pre>
<p>But it turns out that maps are just as easy to copy:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> copied <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span>myMap<span class="token punctuation">)</span>
</code></pre>
<p>The reason this works is because the constructor of <code>Map</code> takes an iterable of <code>[key, value]</code> tuples. And conveniently, maps are iterable, producing tuples of their keys and values. Nice.</p>
<p>Similarly, you can also do deep copies of maps, just like you can with objects, using <a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">structuredClone</a>:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> deepCopy <span class="token operator">=</span> <span class="token function">structuredClone</span><span class="token punctuation">(</span>myMap<span class="token punctuation">)</span>
</code></pre>
<h3 id="converting-maps-to-objects-and-objects-to-maps">Converting maps to objects and objects to maps<a aria-hidden="true" class="anchor-heading icon-link" href="#converting-maps-to-objects-and-objects-to-maps"></a></h3>
<p>Converting maps to objects is readily done using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries">Object.fromEntries</a>:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> myObj <span class="token operator">=</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">fromEntries</span><span class="token punctuation">(</span>myMap<span class="token punctuation">)</span>
</code></pre>
<p>And going the other way is straightforward as well, using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">Object.entries</a>:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">entries</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>Easy!</p>
<p>And, now that we know this, we no longer have to construct maps using tuples:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token string">"keyTwo"</span><span class="token punctuation">,</span> <span class="token string">"valueTwo"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<p>You can instead construct them like objects, which to me is a bit nicer on the eyes:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> myMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span>
  <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">entries</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    key<span class="token operator">:</span> <span class="token string">"value"</span><span class="token punctuation">,</span>
    keyTwo<span class="token operator">:</span> <span class="token string">"valueTwo"</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre>
<p>Or you could make a handy little helper too:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">makeMap</span> <span class="token operator">=</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> myMap <span class="token operator">=</span> <span class="token function">makeMap</span><span class="token punctuation">(</span><span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">"value"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>Or with TypeScript:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> makeMap <span class="token operator">=</span> <span class="token operator">&#x3C;</span><span class="token constant">V</span> <span class="token operator">=</span> <span class="token builtin">unknown</span><span class="token operator">></span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token maybe-class-name">Record</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token arrow operator">=></span>
  <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span><span class="token operator">&#x3C;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token constant">V</span><span class="token operator">></span></span><span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> myMap <span class="token operator">=</span> <span class="token function">makeMap</span><span class="token punctuation">(</span><span class="token punctuation">{</span> key<span class="token operator">:</span> <span class="token string">"value"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// => Map&#x3C;string, string></span>
</code></pre>
<p>I‚Äôm a fan of that.</p>
<h3 id="key-types">Key types<a aria-hidden="true" class="anchor-heading icon-link" href="#key-types"></a></h3>
<p>Maps are not just a more ergonomic and better-performing way to handle key value maps in JavaScript. They can even do things that you just cannot accomplish at all with plain objects.</p>
<p>For instance, maps are not limited to only having strings as keys ‚Äî you can use any type of object as a key for a map. And I mean, like, anything.</p>
<pre class="language-typescript"><code class="language-typescript">myMap<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
myMap<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
myMap<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span><span class="token dom variable">document</span><span class="token punctuation">.</span><span class="token property-access">body</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
myMap<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
myMap<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span>myDog<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
</code></pre>
<p>But, why?</p>
<p>One helpful use case for this is associating metadata with an object without having to modify that object directly.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> metadata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

metadata<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span>myDomNode<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  internalId<span class="token operator">:</span> <span class="token string">"..."</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

metadata<span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span>myDomNode<span class="token punctuation">)</span>
<span class="token comment">// => { internalId: '...' }</span>
</code></pre>
<p>This can be useful, for instance, when you want to associate temporary state to objects you read and write from a database. You can add as much temporary data associated directly with the object reference, without risk.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> metadata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

metadata<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span>myTodo<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  focused<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

metadata<span class="token punctuation">.</span><span class="token method function property-access">get</span><span class="token punctuation">(</span>myTodo<span class="token punctuation">)</span>
<span class="token comment">// => { focused: true }</span>
</code></pre>
<p>Now when we save <code>myTodo</code> back to the database, only the values we want saved are there, and our temporary state (which is in a separate map) does not get included accidentally.</p>
<p>This does have one issue though.</p>
<p>Normally, the garbage collector would collect this object and remove it from memory. However, because our map is holding a reference, it'll never be garbage collected, causing a memory leak.</p>
<h3 id="weakmaps">WeakMaps<a aria-hidden="true" class="anchor-heading icon-link" href="#weakmaps"></a></h3>
<p>Here‚Äôs where we can use the <code>WeakMap</code> type. Weak maps perfectly solve for the above memory leak as they hold a weak reference to the object.</p>
<p>So if all other references are removed, the object will automatically be garbage collected and removed from this weak map.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> metadata <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">WeakMap</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// ‚úÖ No memory leak, myTodo will be removed from the map</span>
<span class="token comment">// automatically when there are no other references</span>
metadata<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span>myTodo<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  focused<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="moar-map-stuff">Moar map stuff<a aria-hidden="true" class="anchor-heading icon-link" href="#moar-map-stuff"></a></h3>
<p>A few remaining useful things to know about Maps before we continue on:</p>
<pre class="language-typescript"><code class="language-typescript">map<span class="token punctuation">.</span><span class="token method function property-access">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Clear a map entirely</span>
map<span class="token punctuation">.</span><span class="token property-access">size</span> <span class="token comment">// Get the size of the map</span>
map<span class="token punctuation">.</span><span class="token method function property-access">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Iterator of all map keys</span>
map<span class="token punctuation">.</span><span class="token method function property-access">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Iterator of all map values</span>
</code></pre>
<p>Ok, you get it, maps have nice methods. Moving on.</p>
<h3 id="sets">Sets<a aria-hidden="true" class="anchor-heading icon-link" href="#sets"></a></h3>
<p>If we are talking about maps, we should also mention their cousin, Sets, which give us a better-performing way to create a <em>unique</em> list of elements where we can easily add, remove, and look up if a set contains an item:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

set<span class="token punctuation">.</span><span class="token method function property-access">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
set<span class="token punctuation">.</span><span class="token method function property-access">delete</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
set<span class="token punctuation">.</span><span class="token method function property-access">has</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
</code></pre>
<p>In some cases, sets can <a href="https://perf.builder.io/?q=eyJpZCI6IjZtaDFsdjJscm56IiwidGl0bGUiOiJBcnJheSB2cyBTZXQgcGVyZm9ybWFuY2UiLCJiZWZvcmUiOiJjb25zdCBsZW5ndGggPSAxMF8wMDBcbmNvbnN0IGFyciA9IFsuLi5BcnJheShsZW5ndGgpLmtleXMoKV0ubWFwKHggPT4gKHggKiAxNikudG9TdHJpbmcoMzYpKVxuY29uc3Qgc2V0ID0gbmV3IFNldChhcnIpIiwidGVzdHMiOlt7Im5hbWUiOiJBcnJheSIsImNvZGUiOiJjb25zdCByYW5kb21WYWx1ZSA9IChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW5ndGgpICogMTYpLnRvU3RyaW5nKDM2KVxuXG4vLyBGaW5kIHRoZSB2YWx1ZVxuYXJyLmluY2x1ZGVzKHJhbmRvbVZhbHVlKVxuXG4vLyBSZW1vdmUgdGhlIHZhbHVlXG5hcnIuc3BsaWNlKGFyci5pbmRleE9mKHJhbmRvbVZhbHVlKSwgMSlcblxuLy8gQWRkIGl0IGJhY2tcbmFyci5wdXNoKHJhbmRvbVZhbHVlKSIsInJ1bnMiOltdLCJvcHMiOjEwNDQwfSx7Im5hbWUiOiJTZXQiLCJjb2RlIjoiY29uc3QgcmFuZG9tVmFsdWUgPSAoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuZ3RoKSAqIDE2KS50b1N0cmluZygzNilcblxuLy8gRmluZCB0aGUgdmFsdWVcbnNldC5oYXMocmFuZG9tVmFsdWUpXG5cbi8vIFJlbW92ZSB0aGUgdmFsdWVcbnNldC5kZWxldGUocmFuZG9tVmFsdWUpXG5cbi8vIEFkZCBpdCBiYWNrXG5zZXQuYWRkKHJhbmRvbVZhbHVlKSIsInJ1bnMiOltdLCJvcHMiOjc4MTMxNn1dLCJ1cGRhdGVkIjoiMjAyMy0wMi0wN1QxMDoxOTozMi4wNjVaIn0%3D">yield significantly better performance</a> than the equivalent operations with an array.</p>
<p><a href="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F7034341cab394484b2e80ea3829b1acb?width=705">Screenshot of the Array vs Set benchmark with Sets having almost 100x better performance</a></p>
<p><em>Blah blah microbenchmarks are not perfect, test your own code under real-world conditions to verify you get a benefit, or</em> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set#performance"><em>don't just take my word for it</em></a>.</p>
<p>Similarly, we get a <code>WeakSet</code> class in JavaScript that will help us avoid memory leaks as well.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// No memory leaks here, captain ü´°</span>
<span class="token keyword">const</span> checkedTodos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">WeakSet</span></span><span class="token punctuation">(</span><span class="token punctuation">[</span>todo1<span class="token punctuation">,</span> todo2<span class="token punctuation">,</span> todo3<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="serialization"><a href="https://www.builder.io/blog/maps#serialization">Serialization</a><a aria-hidden="true" class="anchor-heading icon-link" href="#serialization"></a></h3>
<p>Now you might say there's one last advantage that plain objects and arrays have over maps and sets ‚Äî serialization.</p>
<p><em>Ha! You thought you got me on that one. But I‚Äôve got answers for you, friend.</em></p>
<p>So, yes, <code>JSON.stringify()</code>/ <code>JSON.parse()</code> support for objects and maps is extremely handy.</p>
<p>But, have you ever noticed that when you want to pretty print JSON you always have to add a <code>null</code> as the second argument? Do you know what that parameter even does?</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment">//                  ^^^^ what dis do</span>
</code></pre>
<p>As it turns out, that parameter can be very helpful to us. It is called a <em>replacer</em> and it allows us to define how any custom type should be serialized.</p>
<p>We can use this to easily convert maps and sets to objects and arrays for serialization:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// Convert maps to plain objects</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">fromEntries</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// Convert sets to arrays</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token keyword module">from</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> value
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<blockquote>
<p>Why did the JavaScript developer quit their job? They didn‚Äôt get <em>arrays</em>. Ha ha ho ho. Ok.</p>
</blockquote>
<p>Now we can just abstract this into a basic reusable function, and serialize away.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">{</span> set<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> map<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>

<span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">stringify</span><span class="token punctuation">(</span>test<span class="token punctuation">,</span> replacer<span class="token punctuation">)</span>
<span class="token comment">// => { set: [1, 2, 3], map: { key: value } }</span>
</code></pre>
<p>For converting back, we can use the same trick with <code>JSON.parse()</code>, but doing the opposite, by using its <em>reviver</em> parameter, to convert arrays back to Sets and objects back to maps when parsing:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">parse</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token method function property-access">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>value <span class="token operator">&#x26;&#x26;</span> <span class="token keyword">typeof</span> value <span class="token operator">===</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">entries</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> value
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
<p>Also note that both <em>replacers</em> and <em>revivers</em> work recursively, so they are able to serialize and deserialize maps and sets <em>anywhere</em> in our JSON tree.</p>
<p>But, there is just one small problem with our above serialization implementation.</p>
<p>We currently don‚Äôt differentiate a plain object or array versus a map or a set at parse time, so we cannot intermix plain objects and maps in our JSON or we will end up with this:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> hello<span class="token operator">:</span> <span class="token string">"world"</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> replacer<span class="token punctuation">)</span>
<span class="token keyword">const</span> parsed <span class="token operator">=</span> <span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">parse</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> reviver<span class="token punctuation">)</span>
<span class="token comment">// Map&#x3C;string, string></span>
</code></pre>
<p>We can solve this by creating a special property; for example, called <code>__type</code>, to denote when something should be a map or a set as opposed to a plain object or array, like so:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">replacer</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> __type<span class="token operator">:</span> <span class="token string">"Map"</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">fromEntries</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span> __type<span class="token operator">:</span> <span class="token string">"Set"</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token known-class-name class-name">Array</span><span class="token punctuation">.</span><span class="token keyword module">from</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> value
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">reviver</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>value<span class="token operator">?.</span>__type <span class="token operator">===</span> <span class="token string">"Set"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>value<span class="token operator">?.</span>__type <span class="token operator">===</span> <span class="token string">"Map"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token known-class-name class-name">Object</span><span class="token punctuation">.</span><span class="token method function property-access">entries</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token property-access">value</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword control-flow">return</span> value
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> set<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> map<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"key"</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> replacer<span class="token punctuation">)</span>
<span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token known-class-name class-name">JSON</span><span class="token punctuation">.</span><span class="token method function property-access">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> reviver<span class="token punctuation">)</span>
<span class="token comment">// { set: new Set([1, 2]), map: new Map([['key', 'value']]) }</span>
</code></pre>
<p>Now we have full JSON serialization and deserialization support for sets and maps. Neat.</p>
<h3 id="when-you-should-use-what"><a href="https://www.builder.io/blog/maps#when-you-should-use-what">When you should use what</a><a aria-hidden="true" class="anchor-heading icon-link" href="#when-you-should-use-what"></a></h3>
<p>For structured objects that have a well-defined set of keys ‚Äî such as if every <code>event</code> should have a title and a date ‚Äî you generally want an object.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// For structured objects, use Object</span>
<span class="token keyword">const</span> event <span class="token operator">=</span> <span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token string">"Builder.io Conf"</span><span class="token punctuation">,</span>
  date<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Date</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre>
<p>They're very optimized for fast reads and writes when you have a fixed set of keys.</p>
<p>When you can have any number of keys, and you may need to add and remove keys frequently, consider using <code>map</code> for better performance and ergonomics.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// For dynamic hashmaps, use Map</span>
<span class="token keyword">const</span> eventsMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Map</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
eventsMap<span class="token punctuation">.</span><span class="token method function property-access">set</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span>
eventsMap<span class="token punctuation">.</span><span class="token method function property-access">delete</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">)</span>
</code></pre>
<p>When creating an array where the order of elements matter and you may intentionally want duplicates in the array, then a plain array is generally a great idea.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// For ordered lists, or those that may need duplicate items, use Array</span>
<span class="token keyword">const</span> myArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
</code></pre>
<p>But when you know you never want duplicates and the order of items doesn't matter, consider using a set.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// For unordered unique lists, use Set</span>
<span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token known-class-name class-name">Set</span></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<h2 id="about-me"><a href="https://www.builder.io/blog/maps#about-me">About me</a><a aria-hidden="true" class="anchor-heading icon-link" href="#about-me"></a></h2>
<p>Hi! I'm¬†<a href="https://twitter.com/Steve8708?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor">Steve</a>, CEO of¬†<a href="https://www.builder.io/">Builder.io</a>.</p>
<p>We make a way to drag + drop with your components to create pages and other CMS content on your site or app, <a href="https://www.builder.io/blog/headless-cms-workflow">visually</a>.</p>
<p>You may find it interesting or useful:</p>