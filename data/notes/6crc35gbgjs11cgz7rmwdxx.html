<h1 id="why-after-6-years-im-over-graphql">Why, after 6 years, Iâ€™m over GraphQL<a aria-hidden="true" class="anchor-heading icon-link" href="#why-after-6-years-im-over-graphql"></a></h1>
<blockquote>
<p><a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/">https://bessey.dev/blog/2024/05/24/why-im-over-graphql/</a></p>
</blockquote>
<p>GraphQL is an incredible piece of technology that has captured a lot of mindshare since I first started slinging it in production in 2018. You wonâ€™t have to look far back on this (rather inactive) blog to see I have previously championed this technology. After building many a React SPA on top of a hodge podge of untyped JSON REST APIs, I found GraphQL a breath of fresh air. I was truly a GraphQL hype train member.</p>
<p>However, as the years have gone on and I have had the opportunity to deploy to environments where non functional requirements like security, performance, and maintainability were more of a concern, my perspective has changed. In this article I would like to take you through why today, <strong>I would not recommend GraphQL to most people</strong>, and what I think are better alternatives.</p>
<p>Throughout I will use Ruby code with the excellent <a href="https://graphql-ruby.org/">graphql-ruby</a> library for examples, but I believe many of these problems are ubiquitous across choice of language / GraphQL library.</p>
<p>If you know of better solutions and mitigations, please do leave a comment. Now, lets beginâ€¦</p>
<h2 id="attack-surface">Attack surface<a aria-hidden="true" class="anchor-heading icon-link" href="#attack-surface"></a></h2>
<p>It was obvious from GraphQLâ€™s beginning that exposing a <strong>query language</strong> to untrusted clients increases the attack surface of the application. Nevertheless, the variety of attacks to consider was even broader than I imagined, and mitigating them is quite a burden. Hereâ€™s the worst Iâ€™ve had to deal with over the yearsâ€¦</p>
<h3 id="authorisation">Authorisation<a aria-hidden="true" class="anchor-heading icon-link" href="#authorisation"></a></h3>
<p>I think this is the most widely understood risk of GraphQL, so I wonâ€™t go into too much depth here. TLDR: if you expose a fully self documenting query API to all clients, you better be damn sure that <strong>every field</strong> is authorised against the current user appropriately to the context in which that field is being fetched. Initially authorising <strong>objects</strong> seems like enough, but this quickly becomes insufficient. For example, say we are the ~Twitter~ X ğŸ™„ API:</p>
<pre><code>query {
  user(id: 321) {
    handle # âœ… I am allowed to view Users public info
    email # ğŸ›‘ I shouldn't be able to see their PII just because I can view the User
  }
  user(id: 123) {
    blockedUsers {
      # ğŸ›‘ And sometimes I shouldn't even be able to see their public info,
      # because context matters!
      handle
    }
  }
}
</code></pre>
<p>One wonders how much GraphQL holds responsibility for Broken Access Control climbing to the <a href="https://owasp.org/Top10/">OWASP Top 10â€™s #1 spot</a>. One mitigation here is to make your API secure by default by integrating with <a href="https://graphql-ruby.org/authorization/authorization">your GraphQL libraryâ€™s authorisation framework</a>. Every object returned and/or field resolved, your authorisation system is called to confirm that the current user has access.</p>
<p>Compare this to the REST world where generally speaking you would authorise <strong>every endpoint</strong>, a far smaller task.</p>
<h3 id="rate-limiting">Rate limiting<a aria-hidden="true" class="anchor-heading icon-link" href="#rate-limiting"></a></h3>
<p>With GraphQL we cannot assume that all requests are equally hard on the server. There is no limit to how big a query can be. Even in a completely empty schema, the types exposed for <a href="https://graphql.org/learn/introspection/">introspection</a> are cyclical, so its possible to craft a valid query that returns MBs of JSON:</p>
<pre><code>query {
  __schema{
    types{
      __typename
      interfaces {
        possibleTypes {
          interfaces {
            possibleTypes {
              name
            }
          }
        }
      }
    }
  }
}
</code></pre>
<p>I just tested this attack against a <strong>very</strong> popular websiteâ€™s GraphQL API explorer and got a 500 response back after 10 seconds. I just ate 10 seconds of someoneâ€™s CPU time running this (whitespace removed) <strong>128 byte</strong> query, and it doesnâ€™t even require me to be logged in.</p>
<p>A common mitigation<sup id="fnref:1" role="doc-noteref"><a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fn:1" class="footnote" rel="footnote">1</a></sup> for this attack is to</p>
<ol>
<li>Estimate the complexity of resolving <strong>every single field in the schema</strong>, and abandon queries that exceed some maximum complexity value</li>
<li>Capture the actual complexity of the run query and take it out of bucket of credits that resets at some interval</li>
</ol>
<p>This calculation is a <a href="https://graphql-ruby.org/queries/complexity_and_depth#prevent-complex-queries">delicate affair to get right</a>. It gets particularly tricky when you are returning list fields whose length is not known prior to execution. You can make an assumption about the complexity of these, but if you are wrong, you may end up rate limiting valid queries or not rate limiting invalid queries.</p>
<p>To make matters worse, its common for the graph that makes up the schema to contain cycles. Lets say you run a blog with Articles which each have multiple Tags, from which you can see associated Articles.</p>
<pre><code>type Article {
  title: String
  tags: [Tag]
}
type Tag {
  name: String
  relatedTags: [Tag]
}
</code></pre>
<p>When estimating the complexity of <code>Tag.relatedTags</code>, you might assume that an article will never have more than 5 tags, so you set this fields complexity to <strong>5</strong> (or 5 * <a href="https://graphql-ruby.org/queries/complexity_and_depth#how-complexity-scoring-works">its childrenâ€™s complexity</a>). The problem here is that <code>Article.relatedTags</code> can be its own child, so your estimateâ€™s inaccuracy can compound exponentially. The formula is <code>N^5 * 1</code>. So given this query:</p>
<pre><code>query {
  tag(name: "security") {
    relatedTags {
      relatedTags {
        relatedTags {
          relatedTags {
            relatedTags { name }
          }
        }
      }
    }
  }
}
</code></pre>
<p>You expect a complexity of <code>5^5 = 3,125</code>. If an attacker is able to find an Article with 10 tags, they can trigger a query with a â€œtrueâ€ complexity of <code>10^5 = 100_000</code>, <strong>20x</strong> greater than estimated.</p>
<p>A partial mitigation here is to <a href="https://graphql-ruby.org/queries/complexity_and_depth#prevent-deeply-nested-queries">prevent deeply nested queries</a>. However, the example above demonstrates that this is not really a defense, as itâ€™ts not an unusually deep query. GraphQL Rubyâ€™s default maximum depth is <strong>13</strong>, this is just 7.</p>
<p>Compare this to rate limiting a REST endpoint, which generally have comparable response times. In this case all you need is a bucketed rate limiter that prevents a user exceeding, say, 200 requests per minute across all endpoints. If you <strong>do</strong> have slower endpoints (say, a CSV report or PDF generator) you can define more aggressive rate limits for these. With some HTTP middleware this is pretty trivial:</p>
<pre><code>Rack::Attack.throttle('API v1', limit: 200, period: 60) do |req|
  if req.path =~ '/api/v1/'
    req.env['rack.session']['session_id']
  end
end
</code></pre>
<h3 id="query-parsing">Query parsing<a aria-hidden="true" class="anchor-heading icon-link" href="#query-parsing"></a></h3>
<p>Before a query is executed, it is first parsed. We once received a pen-test report evidencing that its possible to craft an invalid query string that OOMâ€™d the server. For example:</p>
<pre><code>query {
  __typename @a @b @c @d @e ... # imagine 1k+ more of these
}
</code></pre>
<p>This is a <strong>syntactically</strong> valid query, but invalid for our schema. A spec compliant server will parse this and start building an errors response containing thousands of errors which we found consumed <strong>2,000x</strong> more memory than the query string itself. Because of this memory amplification, its not enough to just limit the payload size, as you will have valid queries that are larger than the the smallest dangerous malicious query.</p>
<p>If your server exposes a concept of maximum number of errors to accrue before abandoning parsing, <a href="https://github.com/rmosolgo/graphql-ruby/issues/4154">this can be mitigated</a>. If not, youâ€™ll have to roll your own solution. There is no REST equivalent to this attack of this severity.</p>
<h2 id="performance">Performance<a aria-hidden="true" class="anchor-heading icon-link" href="#performance"></a></h2>
<p>When it comes to performance in GraphQL people often talk about itâ€™s incompatibility with HTTP caching. For me personally, this has not been an issue. For SaaS applications, data is usually highly user specific and serving stale data is unacceptable, so I have not found myself missing response caches (or the cache invalidation bugs they causeâ€¦).</p>
<p>The major performance problems I <strong>did</strong> find myself dealing with wereâ€¦</p>
<h3 id="data-fetching-and-the-n1-problem">Data fetching and the N+1 problem<a aria-hidden="true" class="anchor-heading icon-link" href="#data-fetching-and-the-n1-problem"></a></h3>
<p>I think this issue is pretty widely understood nowadays. TLDR: if a field resolver hits an external data source such as a DB or HTTP API, and it is nested in a list containing N items, it will do those calls N times.</p>
<p>This is not a unique problem to GraphQL, and actually the strict GraphQL resolution algorithm has allowed most libraries to share a common solution: <a href="https://graphql-ruby.org/dataloader/overview.html">the Dataloader pattern</a>. Unique to GraphQL though is the fact that since it is a query language, this can <strong>become</strong> a problem with no backend changes when a client modifies a query. As a result, I found you end up having to defensively introduce the Dataloader abstraction everywhere <em>just in case</em> a client ends up fetching a field in a list context in the future. This is a lot of boilerplate to write and maintain.</p>
<p>Meanwhile, in REST, we can generally hoist nested N+1 queries up to the controller, which I think is a pattern much easier to wrap your head around:</p>
<pre><code>class BlogsController &#x3C; ApplicationController
  def index
    @latest_blogs = Blog.limit(25).includes(:author, :tags)
    render json: BlogSerializer.render(@latest_blogs)
  end

  def show
    # No prefetching necessary here since N=1
    @blog = Blog.find(params[:id])
    render json: BlogSerializer.render(@blog)
  end
end
</code></pre>
<h3 id="authorisation-and-the-n1-problem">Authorisation and the N+1 problem<a aria-hidden="true" class="anchor-heading icon-link" href="#authorisation-and-the-n1-problem"></a></h3>
<p>But wait, thereâ€™s more N+1s! If you followed the advice earlier of integrating with your libraryâ€™s authorisation framework, youâ€™ve now got a whole new category of N+1 problems to deal with. Lets continue with our X API example from earlier:</p>
<pre><code>class UserType &#x3C; GraphQL::BaseObject
  field :handle, String
  field :birthday, authorize_with: :view_pii
end

class UserPolicy &#x3C; ApplicationPolicy
  def view_pii?
    # Oh no, I hit the DB to fetch the user's friends
    user.friends_with?(record)
  end
end
</code></pre>
<pre><code>query {
  me {
    friends { # returns N Users
      handle
      birthday # runs UserPolicy#view_pii? N times
    }
  }
}
</code></pre>
<p>This is actually trickier to deal with than our previous example, because authorisation code is not always run in a GraphQL context. It may for example be run in a background job or an HTML endpoint. That means we canâ€™t just reach for a Dataloader naively, because Dataloaders expect to be run from within GraphQL (in the Ruby implementation anyway).</p>
<p>In my experience, this is actually <strong>the biggest source of performance issues</strong>. We would regularly find that our queries were spending more time authorising data than anything else. Again, this problem simply does not exist in the REST world.</p>
<p>I have mitigated this using nasty things like <a href="https://api.rubyonrails.org/classes/ActiveSupport/CurrentAttributes.html">request level globals</a> to memoise data across policy calls, but its never felt great.</p>
<h2 id="coupling">Coupling<a aria-hidden="true" class="anchor-heading icon-link" href="#coupling"></a></h2>
<p>In my experience, in a mature GraphQL codebase, your business logic is forced into the <a href="https://en.wikipedia.org/wiki/Transport_layer">transport layer</a>. This happens through a number of mechanisms, some of which weâ€™ve already talked about:</p>
<ul>
<li>Solving data authorisation leads to peppering authorisation rules throughout your GraphQL types</li>
<li>Solving mutation / argument authorisation leads to peppering authorisation rules throughout your GraphQL arguments</li>
<li>Solving resolver data fetching N+1s leads to moving this logic into GraphQL specific dataloaders</li>
<li>Leveraging the (lovely) <a href="https://graphql-ruby.org/pagination/using_connections">Relay Connection</a> pattern leads to moving data fetching logic into GraphQL specific <a href="https://graphql-ruby.org/pagination/custom_connections">custom connection objects</a></li>
</ul>
<p>The net effect of all of this is to meaningfully test your application you <strong>must</strong> extensively test at the integration layer, i.e. by running GraphQL queries. I have found this makes for a painful experience. Any errors encountered are captured by the framework, leading to the fun task of reading stack traces in JSON GraphQL error responses. Since so much around authorisation and Dataloaders happens inside the framework, debugging is often much harder as the breakpoint you want is not in application code.</p>
<p>And of course, again, since its a query language youâ€™re going to be writing a lot more tests to confirm that all those argument and field level behaviours we mentioned are working correctly.</p>
<h2 id="complexity">Complexity<a aria-hidden="true" class="anchor-heading icon-link" href="#complexity"></a></h2>
<p>Taken in aggregate, the various mitigations to security and performance issues weâ€™ve gone through add <strong>significant</strong> complexity to a codebase. Itâ€™s not that REST does not have these problems (though it certainly has fewer), itâ€™s just that the REST solutions are generally much simpler for a backend developer to implement and understand.</p>
<h2 id="and-more">And moreâ€¦<a aria-hidden="true" class="anchor-heading icon-link" href="#and-more"></a></h2>
<p>So those are the major reasons I am, for the most part, over GraphQL. I have a few more peeves, but to keep this article growing further Iâ€™ll summarise them here..</p>
<ul>
<li>GraphQL discourages breaking changes and provides no tools to deal with them. This adds needless complexity for those who control all their clients, who will have to <a href="https://graphql-ruby.org/changesets/overview.html">find workarounds</a>.</li>
<li>Reliance on HTTP response codes turns up everywhere in tooling, so dealing with the fact that 200 can mean everything from everything is Ok through to everything is down can be quite annoying.</li>
<li>Fetching all your data in one query in the HTTP 2+ age is often not beneficial to response time, in fact it will worsen it if your server is not parallelised, vs sending separate requests to separate servers to process in parallel.</li>
</ul>
<h2 id="alternatives">Alternatives<a aria-hidden="true" class="anchor-heading icon-link" href="#alternatives"></a></h2>
<p>Ok, end of the rant. What would I recommend instead? To be up front, I am definitely early in the <a href="https://en.wikipedia.org/wiki/Gartner_hype_cycle">hype cycle</a> here, but right now my view is that if you:</p>
<ol>
<li>Control all your clients</li>
<li>Have â‰¤3 clients</li>
<li>Have a client written in a statically typed language</li>
<li>Are using >1 language across the server and clients<sup id="fnref:2" role="doc-noteref"><a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fn:2" class="footnote" rel="footnote">2</a></sup></li>
</ol>
<p>You are probably better off exposing an <strong>OpenAPI 3.0+</strong> compliant JSON REST API. If, as in my experience, the main thing your frontend devs like about GraphQL is its self documenting type safe nature, I think this will work well for you. Tooling in this area has improved a lot since GraphQL came on the scene; there are many options for generating typed client code even down to <a href="https://orval.dev/overview">framework specific data fetching libraries</a>. My experience so far is pretty close to â€œthe best parts of what <strong>I</strong> used GraphQL for, without the complexity Facebook neededâ€.</p>
<p>As with GraphQL thereâ€™s a couple of implementation approachâ€¦</p>
<p><strong>Implementation first</strong> tooling generates OpenAPI specs from a typed / type hinted server. <a href="https://fastapi.tiangolo.com/">FastAPI</a> in Python and <a href="https://github.com/lukeautry/tsoa">tsoa</a> in TypeScript are good examples of this approach<sup id="fnref:3" role="doc-noteref"><a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fn:3" class="footnote" rel="footnote">3</a></sup>. This is the approach I have the most experience with, and I think it works well.</p>
<p><strong>Specification first</strong> is equivalent to â€œschema firstâ€ in GraphQL. Spec first tooling generates code from a hand written spec. I canâ€™t say Iâ€™ve ever looked at an OpenAPI YAML file and thought â€œI would love to have written that myselfâ€, but the recent release of <a href="https://typespec.io/">TypeSpec</a> changes things entirely. With it could come a quite elegant schema first workflow:</p>
<ol>
<li>Write a succinct human readable TypeSpec schema</li>
<li>Generate an OpenAPI YAML spec from it</li>
<li>Generate statically typed API client for your frontend language of choice (e.g. <a href="https://orval.dev/overview">TypeScript</a>)</li>
<li>Generate statically typed server handlers for your backend language &#x26; server framework (e.g. <a href="https://docs.buildwithfern.com/server-boilerplate/server-boilerplate/express-js">TypeScript + Express</a>, <a href="https://docs.buildwithfern.com/server-boilerplate/server-boilerplate/fast-api">Python + FastAPI</a>, <a href="https://github.com/deepmap/oapi-codegen">Go + Echo</a>)</li>
<li>Write an implementation for that handler that compiles, safe in the knowledge that it will be type safe</li>
</ol>
<p>This approach is less mature but I think has a lot of promise.</p>
<p>To me, it seems like powerful <strong>and</strong> simpler options are here, and Iâ€™m excited to learn their drawbacks next ğŸ˜„.</p>
<ol>
<li>Persisted queries are also a mitigation for this and many attacks, but if you actually want to expose a customer facing GraphQL API, persisted queries are not an option.Â <a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fnref:1">â†©</a></li>
<li>Otherwise a language specific solution like <a href="https://trpc.io/">tRPC</a> might be a better fit.Â <a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fnref:2">â†©</a></li>
<li>In Ruby, I guess because type hints are not popular, there is no equivalent approach. Instead we have <a href="https://github.com/rswag/rswag">rswag</a> which generates OpenAPI specs from request specs. It would be cool if we could build an OpenAPI spec from Sorbet / RBS typed endpoints!Â <a href="https://bessey.dev/blog/2024/05/24/why-im-over-graphql/#fnref:3">â†©</a></li>
</ol>
<hr>
<h2 id="gn-6ë…„-ë§Œì—-graphqlì„-ê·¸ë§Œë‘”-ì´ìœ ">GNâº: 6ë…„ ë§Œì— GraphQLì„ ê·¸ë§Œë‘” ì´ìœ <a aria-hidden="true" class="anchor-heading icon-link" href="#gn-6ë…„-ë§Œì—-graphqlì„-ê·¸ë§Œë‘”-ì´ìœ "></a></h2>
<blockquote>
<p><a href="https://news.hada.io/topic?id=15097">https://news.hada.io/topic?id=15097</a></p>
</blockquote>
<ul>
<li>2018ë…„ë¶€í„° 6ë…„ê°„ ì‚¬ìš© í›„, ì§„ì •í•œ GraphQL ì—´í˜ˆ íŒ¬ì´ì—ˆì§€ë§Œ ì´ì œ íšŒì˜ê°€ ë“¦</li>
<li>ì´ì œ GraphQLì„ ì¶”ì²œí•˜ì§€ ì•ŠëŠ” ì´ìœ ì™€ ë” ë‚˜ì€ ëŒ€ì•ˆì´ ë¬´ì—‡ì´ë¼ê³  ìƒê°í•˜ëŠ”ì§€ì— ëŒ€í•´ ì„¤ëª…í•˜ê³ ì í•¨</li>
</ul>
<h3 id="ê³µê²©-í‘œë©´">ê³µê²© í‘œë©´<a aria-hidden="true" class="anchor-heading icon-link" href="#ê³µê²©-í‘œë©´"></a></h3>
<ul>
<li>GraphQLì€ ì¿¼ë¦¬ ì–¸ì–´ë¥¼ ë…¸ì¶œí•˜ì—¬ ê³µê²© í‘œë©´ì„ ë„“íˆëŠ” ìœ„í—˜ì´ ìˆìŒ.</li>
<li>ê¶Œí•œ ë¶€ì—¬ì™€ ê´€ë ¨ëœ ë¬¸ì œëŠ” íŠ¹íˆ ì¤‘ìš”í•¨.
<ul>
<li>ëª¨ë“  í•„ë“œì— ëŒ€í•´ ì ì ˆí•œ ê¶Œí•œ ê²€ì‚¬ê°€ í•„ìš”í•¨.</li>
<li>REST APIì—ì„œëŠ” ì—”ë“œí¬ì¸íŠ¸ë§ˆë‹¤ ê¶Œí•œì„ ê²€ì‚¬í•˜ëŠ” ê²ƒì´ ë” ê°„ë‹¨í•¨.</li>
</ul>
</li>
</ul>
<h4 id="ê¶Œí•œ-ë¶€ì—¬">ê¶Œí•œ ë¶€ì—¬<a aria-hidden="true" class="anchor-heading icon-link" href="#ê¶Œí•œ-ë¶€ì—¬"></a></h4>
<ul>
<li>ëª¨ë“  í•„ë“œì— ëŒ€í•´ ì‚¬ìš©ì ê¶Œí•œì„ í™•ì¸í•´ì•¼ í•¨.</li>
<li>REST APIì—ì„œëŠ” ì—”ë“œí¬ì¸íŠ¸ë§ˆë‹¤ ê¶Œí•œì„ ê²€ì‚¬í•˜ëŠ” ê²ƒì´ ë” ê°„ë‹¨í•¨.</li>
</ul>
<h4 id="ì†ë„-ì œí•œ">ì†ë„ ì œí•œ<a aria-hidden="true" class="anchor-heading icon-link" href="#ì†ë„-ì œí•œ"></a></h4>
<ul>
<li>GraphQL ì¿¼ë¦¬ëŠ” í¬ê¸° ì œí•œì´ ì—†ì–´ì„œ ì„œë²„ì— í° ë¶€ë‹´ì„ ì¤„ ìˆ˜ ìˆìŒ.</li>
<li>ì¿¼ë¦¬ ë³µì¡ì„±ì„ ì¶”ì •í•˜ê³ , ì¼ì • ë³µì¡ì„±ì„ ì´ˆê³¼í•˜ëŠ” ì¿¼ë¦¬ë¥¼ ì œí•œí•˜ëŠ” ë°©ë²•ì´ ìˆìŒ.</li>
<li>REST APIì—ì„œëŠ” ìš”ì²­ ìˆ˜ë¥¼ ì œí•œí•˜ëŠ” ê²ƒì´ ë” ê°„ë‹¨í•¨.</li>
</ul>
<h4 id="ì¿¼ë¦¬-íŒŒì‹±">ì¿¼ë¦¬ íŒŒì‹±<a aria-hidden="true" class="anchor-heading icon-link" href="#ì¿¼ë¦¬-íŒŒì‹±"></a></h4>
<ul>
<li>ì˜ëª»ëœ ì¿¼ë¦¬ ë¬¸ìì—´ì´ ì„œë²„ì˜ ë©”ëª¨ë¦¬ë¥¼ ê³¼ë„í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ.</li>
<li>ìµœëŒ€ ì˜¤ë¥˜ ìˆ˜ë¥¼ ì„¤ì •í•˜ì—¬ íŒŒì‹±ì„ ì¤‘ë‹¨í•˜ëŠ” ë°©ë²•ì´ ìˆìŒ.</li>
</ul>
<h3 id="ì„±ëŠ¥">ì„±ëŠ¥<a aria-hidden="true" class="anchor-heading icon-link" href="#ì„±ëŠ¥"></a></h3>
<h4 id="ë°ì´í„°-í˜ì¹­ê³¼-n1-ë¬¸ì œ">ë°ì´í„° í˜ì¹­ê³¼ N+1 ë¬¸ì œ<a aria-hidden="true" class="anchor-heading icon-link" href="#ë°ì´í„°-í˜ì¹­ê³¼-n1-ë¬¸ì œ"></a></h4>
<ul>
<li>í•„ë“œ ë¦¬ì¡¸ë²„ê°€ ì™¸ë¶€ ë°ì´í„° ì†ŒìŠ¤ë¥¼ ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œí•  ìˆ˜ ìˆìŒ.</li>
<li>Dataloader íŒ¨í„´ì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆìŒ.</li>
<li>RESTì—ì„œëŠ” ì»¨íŠ¸ë¡¤ëŸ¬ì—ì„œ N+1 ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ê²ƒì´ ë” ê°„ë‹¨í•¨.</li>
</ul>
<h4 id="ê¶Œí•œ-ë¶€ì—¬ì™€-n1-ë¬¸ì œ">ê¶Œí•œ ë¶€ì—¬ì™€ N+1 ë¬¸ì œ<a aria-hidden="true" class="anchor-heading icon-link" href="#ê¶Œí•œ-ë¶€ì—¬ì™€-n1-ë¬¸ì œ"></a></h4>
<ul>
<li>ê¶Œí•œ ë¶€ì—¬ ì½”ë“œê°€ N+1 ë¬¸ì œë¥¼ ì¼ìœ¼í‚¬ ìˆ˜ ìˆìŒ.</li>
<li>RESTì—ì„œëŠ” ì´ ë¬¸ì œê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ.</li>
</ul>
<h3 id="ê²°í•©">ê²°í•©<a aria-hidden="true" class="anchor-heading icon-link" href="#ê²°í•©"></a></h3>
<ul>
<li>GraphQL ì½”ë“œë² ì´ìŠ¤ëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ì „ì†¡ ê³„ì¸µì— ê°•í•˜ê²Œ ê²°í•©ë¨.</li>
<li>í†µí•© í…ŒìŠ¤íŠ¸ê°€ í•„ìš”í•˜ê³ , ë””ë²„ê¹…ì´ ì–´ë ¤ì›€.</li>
</ul>
<h3 id="ë³µì¡ì„±">ë³µì¡ì„±<a aria-hidden="true" class="anchor-heading icon-link" href="#ë³µì¡ì„±"></a></h3>
<ul>
<li>GraphQLì˜ ë³´ì•ˆ ë° ì„±ëŠ¥ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë‹¤ì–‘í•œ ë°©ë²•ë“¤ì´ ì½”ë“œë² ì´ìŠ¤ì˜ ë³µì¡ì„±ì„ ì¦ê°€ì‹œí‚´.</li>
<li>REST ì†”ë£¨ì…˜ì€ ì¼ë°˜ì ìœ¼ë¡œ ë” ê°„ë‹¨í•¨.</li>
</ul>
<h3 id="ëŒ€ì•ˆ">ëŒ€ì•ˆ<a aria-hidden="true" class="anchor-heading icon-link" href="#ëŒ€ì•ˆ"></a></h3>
<ul>
<li>OpenAPI 3.0+ë¥¼ ì‚¬ìš©í•˜ëŠ” JSON REST APIë¥¼ ì¶”ì²œí•¨.</li>
<li>ì •ì  íƒ€ì… ì–¸ì–´ë¡œ ì‘ì„±ëœ í´ë¼ì´ì–¸íŠ¸ê°€ ìˆëŠ” ê²½ìš°, OpenAPIê°€ ë” ë‚˜ì€ ì„ íƒì¼ ìˆ˜ ìˆìŒ.</li>
<li>OpenAPIëŠ” ìë™ìœ¼ë¡œ íƒ€ì… ì•ˆì „í•œ í´ë¼ì´ì–¸íŠ¸ ì½”ë“œë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŒ.</li>
</ul>
<h2 id="gnì˜-ì˜ê²¬">GNâºì˜ ì˜ê²¬<a aria-hidden="true" class="anchor-heading icon-link" href="#gnì˜-ì˜ê²¬"></a></h2>
<ul>
<li>GraphQLì€ ê°•ë ¥í•˜ì§€ë§Œ, ë³´ì•ˆê³¼ ì„±ëŠ¥ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë° ë§ì€ ë…¸ë ¥ì´ í•„ìš”í•¨.</li>
<li>REST APIëŠ” ìƒëŒ€ì ìœ¼ë¡œ ê°„ë‹¨í•˜ê³ , ë§ì€ ê²½ìš°ì— ë” ì í•©í•  ìˆ˜ ìˆìŒ.</li>
<li>OpenAPIëŠ” íƒ€ì… ì•ˆì „ì„±ê³¼ ìë™í™”ëœ ë„êµ¬ë¥¼ ì œê³µí•˜ì—¬ ê°œë°œ ìƒì‚°ì„±ì„ ë†’ì¼ ìˆ˜ ìˆìŒ.</li>
<li>GraphQLì„ ë„ì…í•  ë•ŒëŠ” ë³´ì•ˆ ë° ì„±ëŠ¥ ë¬¸ì œë¥¼ ì¶©ë¶„íˆ ê³ ë ¤í•´ì•¼ í•¨.</li>
<li>RESTì™€ GraphQLì˜ ì¥ë‹¨ì ì„ ë¹„êµí•˜ì—¬ í”„ë¡œì íŠ¸ì— ë§ëŠ” ê¸°ìˆ ì„ ì„ íƒí•˜ëŠ” ê²ƒì´ ì¤‘ìš”í•¨.</li>
</ul>
<h2 id="hacker-news-ì˜ê²¬"><a href="https://news.ycombinator.com/item?id=40521518">Hacker News ì˜ê²¬</a><a aria-hidden="true" class="anchor-heading icon-link" href="#hacker-news-ì˜ê²¬"></a></h2>
<ul>
<li>GraphQL ë„ì… í›„ ë§ì€ ë¬¸ì œë¥¼ ê²ªì—ˆìŒ. ê¶Œí•œ ê´€ë¦¬ì™€ ì„±ëŠ¥ ë¬¸ì œë¡œ ì¸í•´ ë” ì´ìƒ ì‚¬ìš©í•˜ê³  ì‹¶ì§€ ì•ŠìŒ. í”„ë¡ íŠ¸ì—”ë“œì—ì„œë§Œ ì‚¬ìš©í•˜ë©´ ì¢‹ì„ ìˆ˜ ìˆì§€ë§Œ, ë°±ì—”ë“œì™€ì˜ í†µí•©ì€ ë³µì¡í•¨.</li>
<li>RESTë¥¼ ë¨¼ì € ë°°ìš°ê³  gRPCë¥¼ ì‚¬ìš©í•´ë³´ë‹ˆ íƒ€ì… ì•ˆì „í•œ APIê°€ ë§¤ë ¥ì ì´ì—ˆìŒ. GraphQLì€ ë§ì€ ì´ì ì´ ì—†ê³ , ë°ì´í„°ë² ì´ìŠ¤ì²˜ëŸ¼ ë™ì‘í•  ë•Œë§Œ ìœ ìš©í•¨.</li>
<li>ë‘ ê°œì˜ GraphQL í”„ë¡œì íŠ¸ì—ì„œ ì¼í–ˆëŠ”ë°, ì´ˆê¸°ì—ëŠ” ì‘ê²Œ ì‹œì‘í–ˆì§€ë§Œ ì‹œê°„ì´ ì§€ë‚˜ë©´ì„œ ë³µì¡í•´ì¡ŒìŒ. ë””ë²„ê¹…ì´ ì–´ë µê³  ì„±ëŠ¥ ë¬¸ì œê°€ ë°œìƒí•¨. RESTì™€ RPCê°€ ë” ê°„ë‹¨í•˜ê³  ê´€ë¦¬í•˜ê¸° ì‰¬ì›€.</li>
<li>Hasura ì°½ë¦½ìë¡œì„œ GraphQL ì‚¬ìš©ì˜ ì§„í™”ë¥¼ ë³´ì•˜ìŒ. GraphQLì€ ë°ì´í„° ë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ êµ¬ì¶•í•˜ê¸° ë§¤ìš° ì–´ë ¤ì›€. REST ìœ„ì— GraphQLì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ë¹„íš¨ìœ¨ì ì„. GraphQLì˜ ì£¼ìš” ì‚¬ìš© ì‚¬ë¡€ëŠ” ì—¬ëŸ¬ ë°ì´í„° ì†Œë¹„ìê°€ ìˆëŠ” ê²½ìš°ì„.</li>
<li>í”„ë¡ íŠ¸ì—”ë“œ ì—”ì§€ë‹ˆì–´ë“¤ì´ ì¿¼ë¦¬ë¥¼ ì¤‘ì•™ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì €ì¥í•˜ê³  ì¬ì‚¬ìš©í•˜ëŠ”ë°, ì´ëŠ” GraphQLì„ RESTì²˜ëŸ¼ ì‚¬ìš©í•˜ëŠ” ê²ƒê³¼ ê°™ìŒ.</li>
<li>OpenAPI, GraphQL, JSON/HTTP, gRPCë¥¼ ì‚¬ìš©í•´ë³¸ ê²½í—˜ìœ¼ë¡œ, GraphQL ì¿¼ë¦¬ë¥¼ ì œí•œí•˜ëŠ” ê²ƒì´ ì„±ëŠ¥ê³¼ ë³´ì•ˆ ë¬¸ì œë¥¼ ì™„í™”í•  ìˆ˜ ìˆìŒ. Buf Connectê°€ ëŒ€ë¶€ë¶„ì˜ í”„ë¡œì íŠ¸ì— ê°€ì¥ ì í•©í•œ íƒ€í˜‘ì ì„.</li>
<li>Facebookì—ì„œ GraphQLì„ ì‚¬ìš©í•œ ê²½í—˜ìœ¼ë¡œ, ë§ì€ ì‚¬ëŒë“¤ì´ GraphQLì´ í•´ê²°í•˜ë ¤ëŠ” ë¬¸ì œë¥¼ ê°€ì§€ê³  ìˆì§€ ì•ŠìŒ. Facebookì€ ë²„ì „ ê´€ë¦¬ì™€ ë³µì¡í•œ ê°ì²´ ëª¨ë¸ì„ ë‹¤ë£¨ê¸° ìœ„í•´ GraphQLì„ ì‚¬ìš©í•¨.</li>
<li>Facebookì—ì„œ GraphQLì´ ì˜ ì‘ë™í•˜ëŠ” ì´ìœ ëŠ” ëª¨ë“  ì‚¬ìš©ìê°€ ë¡œê·¸ì¸í•˜ê³ , ë³´ì•ˆì´ ëª¨ë“  í•„ë“œì— ë‚´ì¬ë˜ì–´ ìˆê¸° ë•Œë¬¸ì„. SPAì™€ ë¡œê·¸ì¸ ìš”êµ¬ ì‚¬í•­ì´ ìˆëŠ” ê²½ìš° GraphQLì´ ìœ ìš©í•  ìˆ˜ ìˆìŒ.</li>
<li>GraphQLì„ ì‚¬ìš©í•´ë³´ë‹ˆ ì²˜ìŒì—ëŠ” ì¢‹ì•˜ì§€ë§Œ, ê²°êµ­ ë§ì€ ì¶”ê°€ ì‘ì—…ê³¼ ì¤‘ë³µì´ í•„ìš”í–ˆìŒ. JSON-RPC íƒ€ì… ì—”ë“œí¬ì¸íŠ¸ë¡œ ì‹œì‘í•˜ê³  í•„ìš”í•œ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ëŠ” ê²ƒì´ ë” ë‚˜ì•˜ìŒ.</li>
<li>ì‘ì€ í”„ë¡œì íŠ¸ì—ì„œ GraphQLì„ ì‚¬ìš©í•´ë³´ë‹ˆ ê±°ì˜ ëª¨ë“  ë¶€ë¶„ì´ ì¢‹ì•˜ìŒ. Apollo Clientì™€ graphql-codegenì„ ì‚¬ìš©í•´ Vue 3ìš© íƒ€ì…ê³¼ í•¨ìˆ˜ë¥¼ ìƒì„±í–ˆìŒ. ì¼ë¶€ ë¬¸ì œëŠ” ìˆì—ˆì§€ë§Œ, íƒ€ì… ìˆ˜ì¤€ì—ì„œ ë§ì€ ì˜¤ë¥˜ë¥¼ ì¡ì•„ì¤Œ.</li>
</ul>