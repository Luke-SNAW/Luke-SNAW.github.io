<h1 id="the-expressivity-limitations-of-object-oriented-programming">The Expressivity Limitations of Object-Oriented Programming<a aria-hidden="true" class="anchor-heading icon-link" href="#the-expressivity-limitations-of-object-oriented-programming"></a></h1>
<blockquote>
<p><a href="https://two-wrongs.com/expressive-limitations-of-oop.html">https://two-wrongs.com/expressive-limitations-of-oop.html</a></p>
<p>The document discusses the limitations of object-oriented programming for encoding knowledge. It argues that knowledge takes the shape of rich propositions involving various relationships, but OOP can only represent is-a and has-a relationships. This inadequate representation leads to confusing code when trying to express domain knowledge. While classification trees are insufficient, cramming knowledge into OOP relationships creates unnecessary problems. The document suggests being mindful of the propositions we aim to encode and considering alternative representations beyond classic OOP if needed. Overall, it argues the shape of our knowledge should drive our code structure rather than restricting knowledge into limited OOP relationships.</p>
</blockquote>
<p>tl;dr: Writing software is encoding knowledge. Knowledge takes the shape of propositions. Compressing rich propositions into <em>is-a</em> and <em>has-a</em> relationships does not lend itself to clarity.</p>
<p>That was dense. Let’s back up a little bit.</p>
<hr>
<p>I’m learning a little bit of <em>cognitive task analysis</em> <a id="fnref-1" class="fnref" href="#fn-1">1</a> at the moment, and one of the first tools the authors present are concept maps<a id="fnref-2" class="fnref" href="#fn-2">2</a>. Concept maps are based on the core idea that <em>propositions are the fundamental unit of knowledge</em>.</p>
<p>I’m not the right person to strictly define propositions, but you probably get the right idea if you think of a proposition as a statement that, if you would make it more concrete, could become a single testable hypothesis. Here are a few examples of propositions<a id="fnref-3" class="fnref" href="#fn-3">3</a>:</p>
<ul>
<li>The gasoline engine is off when the vehicle is stopped.</li>
<li>High voltage parts incorporate electromagnetic shielding.</li>
<li>The vehicle may cause sound interference in some third party-produced radio parts.</li>
<li>The service plug is used only when the vehicle is subject to high voltage.</li>
<li>A label is usually attached to the front side window.</li>
<li>This system does not guarantee absolute security against all vehicle thefts.</li>
<li>The indicator light goes off after the power switch has been turned to on.</li>
<li>The units on the gauges differ depending on the target region.</li>
<li>The warning indicators inform the driver of the status of the vehicle’s systems.</li>
<li>Regeneration refers to conversion of kinetic to electrical energy.</li>
<li>The hybrid system indicator requires the shift lever in drive.</li>
</ul>
<p>Look at the richness of those statements! We have temporal conditions (“when” and “after”), statistical generalisations (“usually” and “may cause”), preconditions in both directions (“used only when” and “requires”), statements of subcomponents (“incorporate”), linguistic abstraction (“refers to”), psychological statements (“inform”), functional dependencies (“differ depending on”).</p>
<p>This is what knowledge looks like. <em>A</em> can be related to <em>B</em> through a wide variety of abstract relationships. This matters for software design, because programming is literally translating our knowledge about the problem into a form the computer can execute. The shape of our knowledge has direct consequences on the shape of our code.</p>
<p>Now, what does object-oriented programming look like? We tell students that it allows exactly two kinds of propositions:</p>
<ul>
<li>a car <em>is-a</em> vehicle, and</li>
<li>a car <em>has-a</em> shift lever.</li>
</ul>
<p>That’s it. This is not enough to encode the richness of our knowledge about a domain.<a id="fnref-4" class="fnref" href="#fn-4">4</a> Expertise researchers have also discovered this; classification trees are simply insufficient to express knowledge, and if we try, we end up with complicated ontologies that have long since lost any discernable connection to the original problem.</p>
<p>Shoehorning knowledge into the two classic object-oriented proposition types creates problems that are auxiliary to the one we’re trying to solve.</p>
<p>But we can do better!</p>
<p>The first step is to be mindful of what we are doing. Whenever we find ourselves creating a new type of object – especially if it’s one we struggle to find a good name for – we can stop and think about exactly what sort of proposition it is we’re trying to write the code for, and if there’s a better way to express it. If we do this consistently, we may come up with new useful patterns to encode various types of propositions.<a id="fnref-5" class="fnref" href="#fn-5">5</a></p>
<hr>
<p>Some preview readers have had a recurring misconception, which I want to set straight: I’m not claiming <em>is-a</em> and <em>has-a</em> are the only types of abstraction available object-oriented <em>languages</em>. As a reader pointed out, most object-oriented languages have other types of abstractions which are <em>not</em> the object-oriented parts, like interfaces (<em>responds-to</em>), plain functions<a id="fnref-6" class="fnref" href="#fn-6">6</a>, and more.</p>
<p>This is specifically what is meant by “stop and think […] if there’s a better way to express it”. It seems to me as if the two object-oriented propositions is-a and has-a are a very popular hammer, and I think we can do a better job of illustrating to people why and how not everything is a nail.</p>
<hr>
<h2 id="tags">Tags<a aria-hidden="true" class="anchor-heading icon-link" href="#tags"></a></h2>
<ol>
<li><a title="Private" href="https://wiki.dendron.so/notes/hfyvYGJZQiUwQaaxQO27q.html" target="_blank" class="private">OOP (Private)</a></li>
</ol>
<h2 id="footnotes">Footnotes<a aria-hidden="true" class="anchor-heading icon-link" href="#footnotes"></a></h2>
<ol>
<li><span id="fn-1" style="width: 0; height: 0;"></span><p>Working Minds: A Practitioner’s Guide To Cognitive Task Analysis; Hoffman, Klein, &#x26; Crandall; Bradford Books; 2006.<a class="fn" href="#fnref-1">˄</a></p></li>
<li><span id="fn-2" style="width: 0; height: 0;"></span><p>If you do an image search on the web for concept maps, you will see a lot of mind maps – it is a common misconception that concept maps and mind maps are the same thing. They are not. Concept maps have proven themselves useful in studying expertise, whereas mind maps … I don’t actually know if mind maps are useful for anything.<a class="fn" href="#fnref-2">˄</a></p></li>
<li><span id="fn-3" style="width: 0; height: 0;"></span><p>I just pulled arbitrary quotes from a document I happened to have open on my second monitor anyway.<a class="fn" href="#fnref-3">˄</a></p></li>
<li><span id="fn-4" style="width: 0; height: 0;"></span><p>Imagine trying to express “the service plug is used only when the vehicle is subject to high voltage” using those two relationships. You’re likely to end up with confusing artifacts like a <code>ServicePluggable</code> which is-a vehicle!<a class="fn" href="#fnref-4">˄</a></p></li>
<li><span id="fn-5" style="width: 0; height: 0;"></span><p>And if you happen to look for a way to innovate on programming language design, take a hint from the research around expertise, and come up with first-class ways to encode other propositions.<a class="fn" href="#fnref-5">˄</a></p></li>
<li><span id="fn-6" style="width: 0; height: 0;"></span><p>Sometimes only available as class methods, but still.<a class="fn" href="#fnref-6">˄</a></p></li>
</ol>