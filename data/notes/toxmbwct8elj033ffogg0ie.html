<h1 id="level-of-parallelism">Level of parallelism<a aria-hidden="true" class="anchor-heading icon-link" href="#level-of-parallelism"></a></h1>
<p><a href="https://coredumped.dev/2022/05/19/a-vision-of-a-multi-threaded-emacs/#what-level-of-parallelism-do-you-want">https://coredumped.dev/2022/05/19/a-vision-of-a-multi-threaded-emacs/#what-level-of-parallelism-do-you-want</a></p>
<p>Level 1 - memory unsafe and data races allowed</p>
<p>Languages where incorrect code can lead to corruption of the program state and segfaults. This includes C++ and Swift.</p>
<p>Level 2 - memory safe and data races allowed</p>
<p>Languages where parallelism is memory safe, but can still lead to data races. This includes Java and Go.</p>
<p>Level 3 - memory safe and no data races</p>
<p>Languages that enable <a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">fearless concurrency</a> by eliminating unguarded access to shared-memory. This includes Clojure, Rust, and TCL.</p>
<p>Generally the closer you are Level 1 the more footguns there are, but the more performance you can squeeze out. The higher you go the easier concurrent code is to write, but you have less performance and control. The exception to this is Rust, which is a safe Level 3 language with the performance of a Level 1.</p>