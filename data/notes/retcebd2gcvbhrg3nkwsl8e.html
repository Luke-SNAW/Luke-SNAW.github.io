<h1 id="the-rise-of-worse-is-better">The Rise of Worse is Better<a aria-hidden="true" class="anchor-heading icon-link" href="#the-rise-of-worse-is-better"></a></h1>
<blockquote>
<p>Richard P. Gabriel</p>
<p>Lucid, Inc</p>
<p><a href="https://www.dreamsongs.com/RiseOfWorseIsBetter.html">https://www.dreamsongs.com/RiseOfWorseIsBetter.html</a></p>
</blockquote>
<hr>
<p>This article discusses two contrasting design philosophies in programming: the MIT approach, which emphasizes achieving the "right thing" with complex, ideal solutions, and the New Jersey approach, characterized by simplicity and practicality. The author argues that while the MIT philosophy leads to well-designed systems like Common Lisp and Scheme, the New Jersey approach, exemplified by early Unix and C, offers better survival characteristics in software development. A key example illustrates a discussion between an MIT and a New Jersey programmer about handling system routine errors, highlighting the New Jersey approach's focus on simplicity over complexity.</p>
<p>The author posits that the worse-is-better philosophy prioritizes implementation simplicity, making systems easier to port and use on a variety of machines, thus allowing for widespread adoption. This philosophy conditions programmers to accept some trade-offs in safety and convenience for enhanced performance. The article suggests that while Lisp compilers were competitive with C compilers, the latter gained more traction due to their practicality.</p>
<p>The author concludes that the quest for the "right thing" often results in overly complex systems that take a long time to develop and may only run on advanced hardware. Instead, a more effective strategy is to release a simpler, albeit imperfect solution first, allowing it to gain popularity before iterating towards improvement. Ultimately, the article calls for a reevaluation of the Lisp community's design approach.</p>
<ul>
<li><strong>Design Philosophies</strong>: The document contrasts two design philosophies: the "MIT approach," which emphasizes achieving the ideal solution, and the "New Jersey approach," which prioritizes simplicity and practicality.</li>
<li><strong>Worse-is-Better</strong>: The "worse-is-better" philosophy asserts that simpler, less perfect designs can be more successful and widely adopted than more complex, ideal solutions.</li>
<li><strong>Survival of Designs</strong>: Despite its flaws, the worse-is-better philosophy tends to have better survival characteristics in software development compared to the idealistic MIT approach.</li>
<li><strong>Real-World Examples</strong>: Early Unix and C exemplify the New Jersey approach, demonstrating how simplicity in design can lead to widespread adoption and functionality across various hardware.</li>
<li><strong>Portability</strong>: The simplicity of Unix and C allows them to be easily ported to less powerful machines, making them more versatile and widely used.</li>
<li><strong>User Conditioning</strong>: Users of worse-is-better systems become accustomed to accepting less-than-ideal functionality, which can facilitate the spread of such systems.</li>
<li><strong>Incremental Improvement</strong>: Once a simpler system gains traction, there is potential for gradual improvement towards a more complete solution without overwhelming complexity.</li>
<li><strong>Complexity of Ideal Solutions</strong>: The document highlights that pursuing the ideal solution can lead to prolonged development times and complexity, often resulting in software that is difficult to implement and run.</li>
<li><strong>Integration Tradition</strong>: The New Jersey approach fosters a culture of component reuse, leading to better integration in software systems.</li>
<li><strong>Rethinking Lisp Design</strong>: The author suggests that the Lisp community should reconsider its design philosophy in light of the success of simpler, more pragmatic systems like C and Unix.</li>
</ul>
<hr>
<p>{an excerpt from "Lisp: Good News, Bad News, How to Win Big." <a href="https://www.dreamsongs.com/WIB.html">html</a>}</p>
<h2 id="21-the-rise-of-worse-is-better">2.1 The Rise of <em>Worse is Better</em><a aria-hidden="true" class="anchor-heading icon-link" href="#21-the-rise-of-worse-is-better"></a></h2>
<p>I and just about every designer of Common Lisp and CLOS has had extreme exposure to the MIT/Stanford style of design. The essence of this style can be captured by the phrase <em>the right thing</em>. To such a designer it is important to get all of the following characteristics right:</p>
<ul>
<li>Simplicity -- the design must be simple, both in implementation and interface. It is more important for the interface to be simple than the implementation.</li>
<li>Correctness -- the design must be correct in all observable aspects. Incorrectness is simply not allowed.</li>
<li>Consistency -- the design must not be inconsistent. A design is allowed to be slightly less simple and less complete to avoid inconsistency. Consistency is as important as correctness.</li>
<li>Completeness -- the design must cover as many important situations as is practical. All reasonably expected cases must be covered. Simplicity is not allowed to overly reduce completeness.</li>
</ul>
<p>I believe most people would agree that these are good characteristics. I will call the use of this philosophy of design the <em>MIT approach</em>. Common Lisp (with CLOS) and Scheme represent the MIT approach to design and implementation.</p>
<p>The worse-is-better philosophy is only slightly different:</p>
<ul>
<li>Simplicity -- the design must be simple, both in implementation and interface. It is more important for the implementation to be simple than the interface. Simplicity is the most important consideration in a design.</li>
<li>Correctness -- the design must be correct in all observable aspects. It is slightly better to be simple than correct.</li>
<li>Consistency -- the design must not be overly inconsistent. Consistency can be sacrificed for simplicity in some cases, but it is better to drop those parts of the design that deal with less common circumstances than to introduce either implementational complexity or inconsistency.</li>
<li>Completeness -- the design must cover as many important situations as is practical. All reasonably expected cases should be covered. Completeness can be sacrificed in favor of any other quality. In fact, completeness must be sacrificed whenever implementation simplicity is jeopardized. Consistency can be sacrificed to achieve completeness if simplicity is retained; especially worthless is consistency of interface.</li>
</ul>
<p>Early Unix and C are examples of the use of this school of design, and I will call the use of this design strategy the <em>New Jersey approach</em>. I have intentionally caricatured the worse-is-better philosophy to convince you that it is obviously a bad philosophy and that the New Jersey approach is a bad approach.</p>
<p>However, I believe that worse-is-better, even in its strawman form, has better survival characteristics than the-right-thing, and that the New Jersey approach when used for software is a better approach than the MIT approach.</p>
<p>Let me start out by retelling a story that shows that the MIT/New-Jersey distinction is valid and that proponents of each philosophy actually believe their philosophy is better.</p>
<p>Two famous people, one from MIT and another from Berkeley (but working on Unix) once met to discuss operating system issues. The person from MIT was knowledgeable about ITS (the MIT AI Lab operating system) and had been reading the Unix sources. He was interested in how Unix solved the PC loser-ing problem. The PC loser-ing problem occurs when a user program invokes a system routine to perform a lengthy operation that might have significant state, such as IO buffers. If an interrupt occurs during the operation, the state of the user program must be saved. Because the invocation of the system routine is usually a single instruction, the PC of the user program does not adequately capture the state of the process. The system routine must either back out or press forward. The right thing is to back out and restore the user program PC to the instruction that invoked the system routine so that resumption of the user program after the interrupt, for example, re-enters the system routine. It is called <em>PC loser-ing</em> because the PC is being coerced into <em>loser mode</em>, where <em>loser</em> is the affectionate name for <em>user</em> at MIT.</p>
<p>The MIT guy did not see any code that handled this case and asked the New Jersey guy how the problem was handled. The New Jersey guy said that the Unix folks were aware of the problem, but the solution was for the system routine to always finish, but sometimes an error code would be returned that signaled that the system routine had failed to complete its action. A correct user program, then, had to check the error code to determine whether to simply try the system routine again. The MIT guy did not like this solution because it was not the right thing.</p>
<p>The New Jersey guy said that the Unix solution was right because the design philosophy of Unix was simplicity and that the right thing was too complex. Besides, programmers could easily insert this extra test and loop. The MIT guy pointed out that the implementation was simple but the interface to the functionality was complex. The New Jersey guy said that the right tradeoff has been selected in Unix -- namely, implementation simplicity was more important than interface simplicity.</p>
<p>The MIT guy then muttered that sometimes it takes a tough man to make a tender chicken, but the New Jersey guy didn’t understand (I’m not sure I do either).</p>
<p>Now I want to argue that worse-is-better is better. C is a programming language designed for writing Unix, and it was designed using the New Jersey approach. C is therefore a language for which it is easy to write a decent compiler, and it requires the programmer to write text that is easy for the compiler to interpret. Some have called C a fancy assembly language. Both early Unix and C compilers had simple structures, are easy to port, require few machine resources to run, and provide about 50%-80% of what you want from an operating system and programming language.</p>
<p>Half the computers that exist at any point are worse than median (smaller or slower). Unix and C work fine on them. The worse-is-better philosophy means that implementation simplicity has highest priority, which means Unix and C are easy to port on such machines. Therefore, one expects that if the 50% functionality Unix and C support is satisfactory, they will start to appear everywhere. And they have, haven’t they?</p>
<p>Unix and C are the ultimate computer viruses.</p>
<p>A further benefit of the worse-is-better philosophy is that the programmer is conditioned to sacrifice some safety, convenience, and hassle to get good performance and modest resource use. Programs written using the New Jersey approach will work well both in small machines and large ones, and the code will be portable because it is written on top of a virus.</p>
<p>It is important to remember that the initial virus has to be basically good. If so, the viral spread is assured as long as it is portable. Once the virus has spread, there will be pressure to improve it, possibly by increasing its functionality closer to 90%, but users have already been conditioned to accept worse than the right thing. Therefore, the worse-is-better software first will gain acceptance, second will condition its users to expect less, and third will be improved to a point that is almost the right thing. In concrete terms, even though Lisp compilers in 1987 were about as good as C compilers, there are many more compiler experts who want to make C compilers better than want to make Lisp compilers better.</p>
<p>The good news is that in 1995 we will have a good operating system and programming language; the bad news is that they will be Unix and C++.</p>
<p>There is a final benefit to worse-is-better. Because a New Jersey language and system are not really powerful enough to build complex monolithic software, large systems must be designed to reuse components. Therefore, a tradition of integration springs up.</p>
<p>How does the right thing stack up? There are two basic scenarios: the <em>big complex system scenario</em> and the <em>diamond-like jewel</em> scenario.</p>
<p>The <em>big complex system</em> scenario goes like this:</p>
<p>First, the right thing needs to be designed. Then its implementation needs to be designed. Finally it is implemented. Because it is the right thing, it has nearly 100% of desired functionality, and implementation simplicity was never a concern so it takes a long time to implement. It is large and complex. It requires complex tools to use properly. The last 20% takes 80% of the effort, and so the right thing takes a long time to get out, and it only runs satisfactorily on the most sophisticated hardware.</p>
<p>The <em>diamond-like jewel</em> scenario goes like this:</p>
<p>The right thing takes forever to design, but it is quite small at every point along the way. To implement it to run fast is either impossible or beyond the capabilities of most implementors.</p>
<p>The two scenarios correspond to Common Lisp and Scheme.</p>
<p>The first scenario is also the scenario for classic artificial intelligence software.</p>
<p>The right thing is frequently a monolithic piece of software, but for no reason other than that the right thing is often designed monolithically. That is, this characteristic is a happenstance.</p>
<p>The lesson to be learned from this is that it is often undesirable to go for the right thing first. It is better to get half of the right thing available so that it spreads like a virus. Once people are hooked on it, take the time to improve it to 90% of the right thing.</p>
<p>A wrong lesson is to take the parable literally and to conclude that C is the right vehicle for AI software. The 50% solution has to be basically right, and in this case it isn’t.</p>
<p>But, one can conclude only that the Lisp community needs to seriously rethink its position on Lisp design. I will say more about this later.</p>
<hr>
<h2 id="hn">HN<a aria-hidden="true" class="anchor-heading icon-link" href="#hn"></a></h2>
<h3 id="d0mine"><a href="https://news.ycombinator.com/item?id=41770603">d0mine</a><a aria-hidden="true" class="anchor-heading icon-link" href="#d0mine"></a></h3>
<p>There is also "satisficing" (vs. maximizing).</p>
<p>Your model of the world is not perfect so instead of trying to find a globally optimal solution, you are satisfied with a local optimum that exceeds some threshold that has to suffices.</p>
<p><a href="https://en.wikipedia.org/wiki/Satisficing">https://en.wikipedia.org/wiki/Satisficing</a></p>