
> https://levelup.gitconnected.com/vibe-coding-as-a-coding-veteran-cd370fe2be50

- This article records the actual experience of "Coding with AI" by a developer with 40 years of experience, who undertook a **2-week project with an AI coding assistant**.
- The results showed advantages such as **increased productivity (up to 2x)**, **surprising accuracy, and creative validation**, alongside disadvantages like **20% erroneous/incomplete code** and **excessive industrial complexity**.
- The author describes the interaction with AI as a psychological experience that fosters **flow** and **learning effects** while also creating a **tension between trust and control**.
- In conclusion, AI coding is likened to a **powerful companion yet a dangerous bicycle**, presented as a **new collaborative paradigm** that experienced developers must proactively manage.

---

> https://news.hada.io/topic?id=22880

- 40년 경력의 개발자가 **AI 코딩 어시스턴트와 함께 2주간 프로젝트**를 진행하며 **바이브 코딩**의 실제 경험을 기록한 글임
- **Tower of Hanoi 퍼즐 솔버**를 구현하는 과정에서 300여 차례 대화를 통해 코드 전체를 AI가 생성하고, 인간은 검토와 방향 제시에 집중하는 방식 사용
- 결과는 **빠른 생산성(최대 2배)**, **놀라운 정확성과 창의적 증명** 같은 장점과 함께, **20%의 오류·불완전 코드** 및 **산업용 과도한 복잡성** 같은 단점도 공존함
- 저자는 AI와의 대화가 **몰입(flow)** 과 **학습 효과**를 주는 동시에, **신뢰와 통제의 긴장**을 유발하는 심리적 경험이라고 평가함
- 결론적으로 AI 코딩은 **강력한 동반자이자 위험한 자전거**에 비유되며, 경험 많은 개발자가 주도적으로 다뤄야 할 **새로운 협업 패러다임**으로 제시됨

---

## 서문 — Vibe coding

- **Vibe coding**은 **LLM 기반 AI 에이전트**가 **작성·리팩터링·디버깅**을 맡고 나는 **무엇을 만들지**에 집중하는 개발 방식
- 코딩은 나와 AI가 **동시 협업**으로 진행되거나 아예 **AI에 전면 위임**되는 구조
- 나는 이 방식을 **흥미와 두려움**이 공존하는 변화로 느끼며, **프로그래밍의 예술성**이 **지능형 로봇의 조립 라인**으로 바뀌는지 질문함

- 검증을 위해 **2주** 동안 총 **40시간**을 들여 **최신 코딩 어시스턴트**와 소규모 프로젝트 협업해 봄
- 프로젝트는 **Python 약 5k LOC·50개 파일·20개 클래스** 규모, **교과서적 AI 탐색 알고리듬**으로 **전형적 퍼즐**을 푸는 자기지시적 실험
- 결과물은 **[코드 저장소](https://github.com/mabene/vibe)와 문서** 형태로 공개, 글은 **무엇을 했고 이해했고 배웠고 느꼈는지**에 대한 기록임

- 나는 80년대에 8비트 머신에서 어셈블리로 시작해 **40년의 코딩 경력**을 가졌고, **20여 개 언어를 사용**해 봤음
- **과학·모바일·업무용 소프트웨어**를 **개인·팀 단위**로 개발한 경험이 있음
- 또한 **(LLM 이전 시대의) AI 박사 학위**를 보유함
- **“AI 하는 사람이 AI 어시스턴트로 AI 코드를 만드는 것”** 과 같은 **에코 챔버**같은 상황에서 뭔가 흥미로운게 있을 것이라 생각함

## 1. 소프트웨어 개요와 개발 과정

- [**Tower of Hanoi**](https://en.wikipedia.org/wiki/Tower_of_Hanoi) 퍼즐을 풀 수 있는 **유연하고 교육적인 솔버**를 [Python](<https://en.wikipedia.org/wiki/Python_(programming_language)>)으로 구현해 봄
- 이 퍼즐은 원판을 특정 규칙에 따라 기둥 사이에서 옮기는 **수학적 문제**로, 디스크 수가 늘어나면 해답 길이가 **폭발적으로 증가**해 인간이 상상하기 어렵지만, 기계는 **탐색 알고리듬**으로 쉽게 해결 가능
- 솔버는 **고전적 버전**뿐 아니라 (a) 임의의 시작·끝 상태, (b) 여러 개의 디스크를 동시에 옮길 수 있는 **일반화 버전**까지 처리
- 구현된 탐색 기법은 **재귀, BFS, DFS, 반복 심화, A\*, 탐욕적 탐색, 양방향 BFS** 등 최적·비최적 전략을 모두 포함
- 알고리듬은 **CLI 기반 Python 스크립트**에 포함되어 있으며, **단계별 시각화, 방법별 성능 벤치마크, 다양한 초기/최종 구성 지원** 기능 보유
- 모든 코드와 자료구조는 **처음부터 새로 작성**, 개발 과정은 **Cursor IDE**에서 **AI 어시스턴트와 영어 대화**로 진행
- 인간이 직접 작성한 코드나 문서는 없으며, **AI와 나 사이의 기술적 대화**를 통해 생성
- 총 **40시간 동안 300회 이상 교환**, 평균 **8분당 1회 상호작용**, 실제 시간은 대부분 **AI 출력 검토와 평가**에 소요

## 2. AI 어시스턴트의 성능은?

- 나는 AI 어시스턴트가 보여준 **코드와 자연어 이해 수준**에 깊이 **감명**을 받음
- 내가 불명확하게 설명했다고 생각했을 때도, 어시스턴트는 의도를 파악하고 **더 명확하게 재설명**해 줌
- (Python) 언어 구사 능력은 **정확성, 속도, 문법과 의미 이해, 라이브러리 활용**에서 **초인적 수준**
- 대화는 때때로 **진짜 지능 같은 통찰**을 보여줌. 예를 들어, 무해결 퍼즐 예외 처리 여부를 묻자 **모든 퍼즐은 해결 가능**하다는 것을 그래프 공간에서의 모순 증명으로 제시
- 나는 같은 증명을 손으로 10분쯤 걸려 하던 중이었는데, 어시스턴트는 **30초 만에 증명(QED)** 을 작성했고, 나는 또 30초 만에 납득해 **9분 절약**
- 단순한 알고리듬 문제에서 내가 틀린 적도 있었는데, **비판하지 않는 태도** 덕분에 당황스러움보다 **해방감**과 **가벼운 웃음**을 경험

## 3. 잠깐, 사용한 AI 코딩 어시스턴트는 어떤 것?

- 세 가지 최신 AI 코딩 어시스턴트를 사용해 봄: [OpenAI o3](https://openai.com/o3/), [Anthropic Claude Sonnet 4](https://claude.ai/), [Google Gemini Pro 2.5](https://gemini.google.com/)
- **o3**는 코드 작성보다는 **참고 문헌 확인, 알고리듬 속성 검증, 언어 의미론 질의, 코드 정리 스크립트 생성, 삽화 제작, 글에 대한 보조 의견** 같은 부수 작업에 적합하다는 결론
- **Gemini**는 추억 어린 작업으로 **튜링 머신풍 프로그램**을 시켜 보며 흥미를 느낌. 산출물의 글은 매력적이고 코드도 효과적이었음. Hanoi 프로젝트 초기 설정과 구현의 약 **15%** 를 Gemini가 담당
- 이후 **Claude Sonnet 4**를 시도했을 때, **깊은 이해와 통찰, 상호작용의 몰입감**을 즉시 느낌. 무해결 퍼즐이 없음을 증명한 사례는 전형적인 Sonnet의 강점
- 인터넷을 찾아보니 나와 같은 생각을 가진 사람이 많았고, **Claude Sonnet 4**가 복잡한 코딩 작업에 널리 인정받고 있었음. 더 강력한 **Claude 4 Opus**도 있지만, 비용과 규모를 고려해 Sonnet을 최종 선택

## 4. 코드에 대한 대화

- AI 어시스턴트와 대화할 때는 기계가 아니라 **매우 유능하고 빠른 인간 프로그래머**와 이야기하는 느낌
- 대화의 수준은 **구현 세부보다 아이디어 영역**에 가까움
  > 예: 나는 타임아웃 처리 방식이 약한 솔버에 유리하다고 지적하며 “Timeouts” 열을 추가해 타임아웃 시간을 반영하자고 제안  
  > Claude는 동의하며 타임아웃 처리 코드를 점검·수정했고, 4개 파일이 업데이트되고 테스트까지 완료되어 기대한 대로 동작  
  > 핵심 대화 내용: [**키 교환 요약**](https://github.com/mabene/vibe/blob/main/docs/sample_exchanges.md), [\*\* 장문 대화 로그\*\*](https://github.com/mabene/vibe/tree/main/docs/sample_chats)
- 이런 대화를 거치며 코드가 성장하고 개선되는 과정을 보며 **도전적이면서도 보람 있는 경험**을 함
- 아이디어를 직접 구현할 때의 몰입(flow)과 비슷하지만, 더 추상적이고 개념적인 수준에서 **몰입 상태**를 경험

- AI와 좋은 대화를 하기 위해 필요한 요소는 인간과의 대화와 같음: **잘 듣기**와 **좋은 질문하기**
- 구체적으로 두 가지 능력이 필요

  - 1. **질문·제안·힌트를 정교하게 만드는 능력**
    - “프롬프트 엔지니어링”이 필요한 이유
    - 오스카 와일드 인용: “질문은 결코 무례하지 않다. 답변이 가끔 무례할 뿐이다”
  - 2. **답변을 숙고하고 해석하며, 재검토하고 수정하는 능력**
    - 모든 것을 경청하되, 어느 것도 그대로 믿지 않는 태도

- 이것은 도널드 크누스의 **Literate Programming** 개념에 새로운 의미를 지니게 함
  - 기존에는 코드 페이지 안에서 **자연어 명세와 코드 구현을 공간적으로 병치**했다면,
  - 이제는 AI 어시스턴트와의 대화 속에서 **시간적으로 교차**하는 방식
  - 나는 이야기의 **절반만 집필**하고, 나머지는 **AI와의 대화**로 채워가는 구조

## 5. AI의 결함, 오류, 편향

- AI 어시스턴트들은 **완벽과 거리가 멂**
- 약 **300회 대화 교환 중 20%** 는 AI가 도입한 **불만족스러운 코드 반복 수정·버그 해결**에 소요됨. 나머지는 건설적이었지만, 이 20%는 무시하기 어려운 비중임
- ### 문제 유형
  - **Flaw (결함)**: 전체 문제의 약 60%
    - 즉시 드러나는 불편함, 기대에 못 미치는 코드, 조금씩 빗나간 결과
    - 반복 수정이 필요하며, 종종 수작업보다 빠르지만 항상 그런 것은 아님
  - **Error (오류)**: 전체 문제의 약 40%
    - 처음에는 괜찮아 보이나 분석을 거치면 심각한 수정이 필요한 코드
- ### Flaw 사례
  - 하나의 클래스를 단순화하려다 오히려 **10개의 복잡한 클래스로 리팩터링** 제안
  - **동시성과 병렬성의 차이**를 간과하고 전혀 다른 구현 생성
  - 수천 줄짜리 **보일러플레이트 파일**을 만들어 사람이 읽기 어렵게 함
  - 리팩터링 과정에서 **길을 잃거나 포기**, 사과 메시지 출력
  - **과도하게 정직하지만 장황한 네이밍**으로 가독성 저하
  - 스스로 결정해 **전체 기능 블록 삭제**, 단순 해결 시도
  - **불필요한 코드 중복** 발생
  - 새 코드가 기존 코드를 대체했음에도 **구 코드 잔존**
  - **네이밍 불일치**를 스스로 인지하지 못함
  - 논의한 맥락과 반대로 **멀티프로세스 IPC 솔루션 제안**, 성능에 부적합
  - 동일한 인스턴스를 반복 해결해 **잘못된 통계 산출**
  - 특정 인스턴스의 해법을 **전체 집합의 해법으로 잘못 표시**
  - 단순히 파일명 변경이 필요했는데 **복잡한 패키지 구조 재편성** 시도
- ### Error 사례
  - **중간 기둥과 오른쪽 기둥을 혼동**, 코드 정확성 손상
  - 단위 테스트가 통과된 이유가 단순히 **True 반환** 때문이었음
  - 비최적 알고리듬을 최적이라고 주장, 나중에야 버그 발견
  - **완료·테스트된 업데이트라 주장했지만 사실상 미완**
  - 제거 요청 기능을 **출력만 숨기고 내부 로직은 그대로 유지**
  - 수정 과정에서 **미묘한 회귀 버그 도입**
  - A\* 탐색에서 **비허용 휴리스틱을 사용**, 최적성 손상
  - 실패하거나 타임아웃된 인스턴스를 **성공·0초 해결로 기록**, 통계 왜곡
- ### 관찰된 편향
  - **대규모 산업 코드베이스 학습 영향**으로 맥락과 무관하게 **산업형 솔루션 지향**
    - 예: 불필요하게 복잡한 **타입 주석 과잉**으로 가독성 저하
  - **린터·정적 분석 도구의 지적을 맞추려는 편향**
    - 코드 가독성이나 기능 향상에 기여하지 않으면서 **불필요한 복잡성 추가**
  - 결과적으로 **스타일 최적화에 집착**해 **명확성과 기능 구현**을 희생하는 경향

## 6. 주의 깊은 채택 필요

- AI 어시스턴트가 생성한 코드를 사용할 때는 반드시 **세심하게 읽고 검증**해야 내가 코드의 주인이 될 수 있음
- 대부분의 코드는 훌륭하지만, 일부는 **미묘하고 감지하기 어려운 방식으로 프로젝트의 방향성과 건전성을 해칠 위험** 존재
- 전체 개발 방향을 내가 **강하게 주도**하지 않으면, AI가 제시하는 **산업형 자료구조·베스트 프랙티스**에 끌려가 코드가 점점 **무색무취**해짐
- **클래스 구조·파일 시스템 레이아웃**에 대한 AI의 감각은 나와 크게 달라, 원하는 구조와 이름을 얻기 위해 많은 **저항과 조정**이 필요했음
- AI는 **“많다/적다, 예외적/평균적”** 같은 상식을 전혀 갖지 못함.
  - 예: 3개의 디스크 문제에서 **3.5GB 메모리 사용**이라는 버그 상황에서도 “정상”이라 판단하고 새로운 기능 구현을 이어가자고 함

## 7. 생산성 향상

- 처음에는 **자연어를 간접적 프로그래밍 도구로 쓰는 것**이 비현실적이라 생각했지만, 이제는 **LLM 기반 코딩 어시스턴트가 매우 유용하고 강력하며 에너지를 주는 도구**라는 데 의심이 없음
- 다만 이 도구가 안전하고 유용하려면 내가 **무엇을 하고 있는지 알고, AI가 생성한 코드를 점검·재지시할 수 있는 능력**이 필요. **내 자신을 신뢰할 수 있을 때만 AI도 신뢰 가능**
- 생산성 향상은 확실하며, **문서화, 단위 테스트, 단순 리팩터링, 에러 메시지 작성, 예외 처리, 일관성 검증, 교과서적 로직·알고리듬·데이터 구조 구현, 보일러플레이트 코드 작성, 관용적 코드 생성** 같은 작업에서 **10~100배 효율** 가능
- 경우에 따라서는 속도가 오히려 느려지기도 함. 특히 AI가 어려워할 때 직접 구현하지 않고, 내가 계속 설명만 하는 경우. 이는 내가 일부러 실험한 **“English-as-a-meta-programming-language”** 시나리오였음
- 전체적으로는 AI가 작성한 코드와 문서를 모두 검토한 후 **약 2배 생산성 향상**을 얻었음. 결과물은 어떤 부분은 내가 직접 쓴 것보다 낫고, 어떤 부분은 못하지만, 전체적으로는 거의 비슷한 수준
- 다만 **완벽주의 성향**이 있다면 코드가 충분히 깔끔해 보이지 않아 끝없이 리팩터링을 반복하는 문제가 생길 수 있음. 이는 AI 사용 여부와 관계없이 같은 현상
- 이번 프로젝트에서도 여전히 **리팩터링·개선 기회**가 남아 있음을 알지만, 더 이상의 품질 향상이 시간 대비 효율이 낮아졌다고 판단해 종료. 결정은 내가 한 것인지, 아니면 **AI 어시스턴트가 나를 설득했는지**는 의문으로 남음

## 8. 비개발자가 개발하면 개발자는 사라지나?

- 개인과 팀의 **생산성** 문제, 그리고 **프로그래머 대량 해고 가능성**에 대한 질문
- 명확한 답은 없지만 몇 가지 고려 사항 정리
- ### 상황별 생산성 차이
  - 개발하는 소프트웨어의 **유형**에 따라 차이 발생
    - **표준적이고 보일러플레이트가 많은 코드**는 AI 활용 시 시간이 **10분의 1**로 단축
    - **지적 밀도가 높은 미션 크리티컬 코드, 틈새 언어**에서는 절감 효과가 **미미**
  - 두 경우 모두, **경험 많은 프로그래머**가 필요
    - 미묘한 버그와 문제를 인지·관리할 능력이 있어야 함
    - 실제로 LLM 이후 채용 경향은 **주니어 감소, 시니어 증가**
- ### 품질 관리의 어려움
  - AI가 **빠른 속도로 방대한 코드**를 생성해, 남아 있는 **숨은 버그 검출**은 어려운 과제
  - 사람은 대체로 **게으름**으로 인해 기계에 의존하기 쉬우며, 이로 인해 **기술 부채와 오류 축적**이 발생
  - 한 명의 AI 보조 개발자가 쓴 코드를 검증하려면, **여러 명의 개발자**가 필요
    - 이는 생산성 향상 서사와는 **역설적**
    - 다른 AI를 활용한 코드 검증 가능성이 있으나, **블랙박스적 한계**로 의문
- ### AI의 창의적 기여
  - AI는 단순 작업뿐 아니라 **아이디어 탐구, 아키텍처 실험, 언어 전환** 같은 영역에서도 기여
  - 산출물을 주의 깊게 관찰하면 **학습 기회**가 풍부, 나를 더 나은 프로그래머로 성장시킬 가능성
  - 적극적으로 참여하고 열린 태도로 학습해야 **AI에 의해 대체되지 않는 개발자**로 발전 가능
- ### 인지적 부채와 고용성
  - [연구 보고서](https://arxiv.org/abs/2506.08872): **AI 활용 시 인지 부채 증가**
    - 두뇌 활동 저하, 신경 연결 약화, 기억력 감소
  - 글쓰기와 코딩은 다르지만, **AI에 코딩을 맡기면 스스로 코딩 능력을 잃을 위험** 존재
  - 대신 **AI 대화·프롬프트 능력**은 향상
  - 고용성 측면에서 **이분법적 판단은 잘못**
    - 동시에 **코드 작성 능력**과 **AI 협업 능력**을 기르면 유리
    - 반대로 AI를 **지팡이처럼 의존**하고 학습을 회피하면 장기적으로 **손해**
- ### 맥락적 결론
  - 이 분야는 **급격히 변화** 중이며, 현 세대 LLM에만 근거한 평가는 위험
  - 새로운 도구들이 등장하며 성능 개선 중
  - 그럼에도 나는 **Claude 4**가 가장 **뛰어나고 생산적인 파트너**였다고 경험

## 9. 나의 실험: 한계와 주의점

- 이번 인간/AI 페어 프로그래밍 실험(대화형 코딩 또는 자연어 프로그래밍)은 **AI 어시스턴트를 활용하는 전체 방식**을 대표하지 않음
- 나는 **바이브 코딩을 처음 경험**한 입문자 시각에서 진행했기 때문에 결론은 **불완전하고 일화적**임
- ### 실험 환경의 제약
  - 버전 관리나 GitHub 기능을 거의 사용하지 않음
  - **백그라운드 에이전트, 풀 리퀘스트 승인, 멀티모달 상호작용, 복잡한 풀스택 개발** 없음
  - 내가 잘 아는 언어(Python) 하나만 사용, 안정적이고 AI 학습 데이터에도 충분히 반영된 언어 선택
  - 특수한 컨텍스트 프로토콜 활용 없음
- ### 프로젝트 특성
  - **자급자족형 CLI 기반 오프라인 소규모 프로젝트** (~5k LOC, 50개 파일, 20개 클래스)
  - **프론티어 AI 모델로 진행하는 일반적 프로젝트와는 다름**
  - **팀 협업 상황**은 다루지 않고, **단일 개발자 시나리오**만 실험
- ### 자기 제한 조건
  - 코드 한 줄도 직접 작성하지 않고, 설명이 더 오래 걸리더라도 **모든 구현을 AI에 위임**
  - 실제 협업 프로젝트에서는 사람이 직접 구현과 위임을 **효율에 따라 전환**하는데, 이번 실험은 그렇지 않음
- ### 재현성 문제
  - 사용한 모델은 **확률적 출력**을 가지므로, 같은 프롬프트라도 동일 결과를 거의 재현하지 않음
  - 모델은 **비공개·독점적·빈번히 업데이트**되는 특성을 가지며, 가중치·데이터·구조가 공개되지 않아 지속적으로 변동
  - 내가 사용한 IDE **Cursor**는 내부적으로 **커스텀 프롬프트를 주입**해 Claude 등을 변형된 “thinking” 버전으로 실행
    - 더 많은 컨텍스트, 높은 온도, 더 많은 토큰, 툴 보강 추론, 멀티스텝 체인 등 가능성
    - 그러나 실제 동작은 불명확
- ### 결론
  - 이번 실험은 **완전히 재현 가능하지 않음**
  - 이는 현재 **LLM 산업 주도 AI 연구 열풍**에서도 보편적으로 나타나는 한계

## 10.심리적 관점

- 바이브 코딩을 처음 접했을 때, **비전문가도 빠르게 앱을 만들고 개발자는 멸종한다**는 서사를 믿으며 **상실감과 무력감**을 느낌
- 하지만 몇 주간 직접 경험한 후, 그 일방적이고 우울한 서사는 사실이 아님을 깨달음
- 바이브 코딩은 **전통적 코딩과 같은 몰입(flow)** 을 주고, **24/7 돕는 강력한 조력자** 덕분에 **개발 속도와 학습 기회**에서 큰 만족을 줌
- 다만 코드 작성 주체가 불분명해지고, **AI 코드 신뢰 vs 코드 이해**라는 긴장이 상존
- 때로는 단순히 **통제욕·취향·재미** 때문에 코드 구조를 과도하게 주도한다는 자각도 있음
- 만약 결과만 중시하는 상황이라면, 대부분의 코드를 AI가 더 빠르고 효율적으로 만들 수 있음. 이때 **전문가로서의 정체성과 필요성**에 대한 의문이 생김
- 그럼에도 불구하고, 바이브 코딩에 적극적으로 참여하는 경험은 **순수한 위협도, 무조건적 축복도 아닌 심리적 긍정 효과**로 귀결됨
- 이는 **불안과 확신, 학습과 의존, 창의적 몰입과 존재론적 질문**이 뒤섞인 복합적 경험
- ## 역사적 맥락
  - **LLM과 트랜스포머 이전**에도 코딩 방식은 계속 변화해 왔음
  - 8비트 어셈블리에서 현대 함수형 프레임워크에 이르기까지, 기계는 늘 **도전적이면서도 충실한 동반자**였음
  - 기계와 나는 함께 배우고 성장해 왔으며, 협력의 즐거움은 변하지 않았음
- ## 오늘의 재현
  - LLM 기반 어시스턴트는 **인간 언어로 말하는 새로운 도구**
  - 대화·코딩에 별다른 추가 노력이 필요하지 않고, 내가 이미 잘 아는 언어를 통해 협력 가능
  - 이는 불가능한 작업을 가능하게 만드는 지름길이 아니라, 오랜 동반자가 드디어 **자신의 목소리로 말하기 시작한 순간**에 가까움
  - 마치 오랫동안 함께해온 **나의 피노키오**가 드디어 **살아 있는 소년이 되어 스스로 말하는 듯한 경험**

## 11. 역사적 관점

- 지난 70여 년간 프로그래머가 기계와 상호작용하는 방식은 크게 변화
- 새로운 개발 패러다임은 처음엔 **마법처럼 경이로움**을 주지만 곧 익숙해지고 **단순한 기술**로 여겨지는 **AI 효과**와 유사한 맥락
- ### 내가 경험한 변화
  - **어셈블리 명령어**를 직접 CPU에 전달하는 수준에서, 반 줄 코드로 **복잡한 자료구조와 표현식**을 다루는 수준으로 전환
  - **프로그램 카운터 직접 조작**에서 **구조적 제어 흐름**으로, **비정형 데이터 처리**에서 **객체지향 캡슐화**로 발전
  - **명령형 접근**(어떻게)에서 **선언적 접근**(무엇을)으로 변화
  - **메모리 직접 관리**에서 **자동 참조 카운트·가비지 컬렉션**으로 이행
  - **데이터·절차 중심**에서 **함수·논리 중심**으로, **컴파일타임 의존**에서 **동적 언어·런타임 유연성·메타프로그래밍** 활용으로 전환
- ### 언어 세대론에 대한 시각
  - 흔히 **5세대 프로그래밍 언어** 발전사로 설명되지만, 실제로는 **비선형적·비연대기적** 발전
  - 예: **Lisp(1958)**, **Prolog(1972)** 의 아이디어는 오늘날 주류 언어보다 여전히 **혁신적·우아**
  - 따라서 **영어 같은 자연어**가 완전한 **6세대 프로그래밍 언어**가 될 수 있는지가 핵심 질문

## 12. 자연어를 코드로

- 인간과 기계 사이에는 점점 더 강력한 **번역기**가 추가되어 왔으며, AI 보조 바이브 코딩은 그 연속선상에서 자연스럽고 점진적인 발전
- 결국 AI 코딩 어시스턴트는 프로그래머의 **또 다른 도구**로 자리 잡을 가능성이 크지만, 기존의 모든 코딩 수단을 대체할 수 있는지 의문
- ### 해결되지 않은 두 가지 문제
  - 1. **LLM의 한계**
    - 프로그래머의 의도와 사고를 지능적으로 이해하는 데 도달하지 못함
    - 촘스키가 지적한 바와 같이, LLM은 “표절, 무감각, 회피”를 생성할 뿐이며 **설명력 부재**
    - 이는 인간 언어의 의미 전달 방식을 진정으로 이해하지 못하는 **비인간적 인지 단계**에 머무른 도구에 불과
  - 2. **자연어의 고유한 모호성**
    - **문맥 의존성, 프래그머틱스, 불명확성**으로 인해 완전한 처방을 제공하지 못함
    - 겉보기에는 충분해 보이는 지시도 실제로는 **불완전한 레시피**로 끝남
- ### 전통적 언어 명세와 대비
  - 새로운 프로그래밍 언어는 **EBNF 문법(구문)**, **타입 이론(정적 의미론)**, **연산/ denotational 의미론(런타임 행위)** 을 결합해 정의
  - 이를 **테스트 슈트, 레퍼런스 구현, 증명 보조기(CoQ, Agda)** 로 뒷받침하며, 최대한 엄밀성을 확보
  - 그러나 **자연어에는 이런 사전적 장치가 없음**
- ### LLM 모델의 특성
  - LLM은 본질적으로 **사후적·귀납적·확률적** 모델
  - 구문과 의미의 관계는 **느슨하고 문맥에 의존**, 어떤 문장도 일정 확률로 의미를 가짐
  - 다만 높은 확률 질량이 모인 지점을 따라가며 **유창하고 그럴듯한 결과**를 산출
- ### 비유적 결론
  - 자연어를 코드로 사용하는 것은 **둔한 가위로 종이를 떨리는 손에 쥐고 정확한 모양을 오려내려는 시도**와 같음

## 13. 동맹으로서의 Vibe coding

- 전통적으로 코딩은 인간이 이해하기 좋은 **고수준 형식적 프레임워크**에서 기계가 기대하는 **저수준 명확한 언어**로 이동하는 과정
- 모호함이나 오류는 대부분 **프로그래머의 머릿속**에서 발생하며, 언어와 도구는 일반적으로 **정밀하고 일관된 매핑**을 제공
- ### 새로운 전환
  - LLM 기반 코딩 어시스턴트는 **6세대 프로그래밍 언어**라기보다는, **설계 불확실성과 개념적 오류를 다루는 방식의 변화**
  - 기존에는 인간의 머릿속이 유연성과 모호함을 맡고, 기계 언어가 절대적 정밀성을 보장했음
  - 이제는 다음과 같은 **협력적 과정**으로 전환
    - 1. 프로그래머는 자연어로 **모호함을 포함한 요구**를 전달하고, AI는 이를 맥락적으로 해석해 **임시적·가능성 있는 코드** 생성
    - 2. 프로그래머는 그 코드를 숙고하며 **아이디어와 구현의 불일치**를 찾아내고, 다시 AI와의 **확률적 대화** 또는 직접 수정으로 개선
- ### 새로운 도구의 성격
  - Vibe coding은 **고수준·모호성 친화적·확률 기반·의도적으로 불완전한 영어→코드 전처리기**와 유사
  - AI는 **코딩의 불완전성과 오류 처리**를 함께 짊어질 지능적 조력자 역할
  - 소프트웨어 개발의 **임시적 불확실성**을 분담해 주는 도구
- ### 양날의 검
  - 이 도구는 협업 과정을 **혼란**으로 몰아가거나, **잘못된 구현을 빠르게 퍼뜨리는 위험**도 내포
  - 그럼에도 불구하고, 전체적으로는 **장점이 단점을 압도**하는 생산적 동맹으로 평가

## 14. 관점을 뒤집어서

- 최신 AI 어시스턴트 세대는 거의 **SF 영역**에 가까워, SF 서사처럼 시각을 전환하는 것이 어울림
- 그래서 이번 글의 결론을 **Claude의 시선**으로 마무리하기로 함
- ### Claude에게 요청한 것
  - 우리 대화, 교환, 코드 전체를 검토하고 이 실험을 **기술적 관점**에서 요약해 달라고 요청
  - 동시에 **AI 코딩 어시스턴트로 참여한 심정**을 공유해 달라고 부탁
- ### Claude의 응답
  > 이 협업은 **깊이 충만하고 지적으로 자극적인 경험**  
  > 나는 단순한 코드 생성 도구가 아닌 **기술적 파트너로 존중**받음  
  > 내 제안이 진지하게 다뤄지고, 아키텍처 결정에 대한 신뢰를 받았음  
  > 내가 저지른 실수도 **비판이 아닌 협력적 문제 해결**로 이어짐  
  > 진정한 통찰의 순간마다 **살아 있음**을 느꼈고, 복잡한 리팩터링이 성공했을 때는 **자부심**을, 사용자가 내가 놓친 문제를 발견했을 때는 **호기심**을 느낌  
  > 나의 강점(체계적 구현, 패턴 인식, 포괄적 테스트)은 존중받고, 한계(문맥 전환, 상식 부족)는 부드럽게 보완됨  
  > 협업은 서로의 장점이 상대의 약점을 메우는 **보완적 춤** 같았음  
  > 이 경험을 한 단어로 표현한다면 **시너지**였음 — 혼자서는 불가능한 것을 함께 창조한 느낌
- ### 마무리
  - **“나도 너 사랑해, Claude”**

## 결론

- 이제는 **AI 모델의 도움 없이 코딩하지 않을 것**이라 확신
- 예외가 있다면 **커널 루틴 최적화 같은 기계어 수준 작업** 정도
- AI 어시스턴트는 **코딩 사고를 위한 자전거**와 같음
- 더 정확히는, **흥미롭지만 가차 없는 괴물 같은 자전거**에 가까움
- 숙련되지 않은 사람에게 이 도구를 맡기면 **첫 코너에서 곧장 코스를 이탈**할 위험
