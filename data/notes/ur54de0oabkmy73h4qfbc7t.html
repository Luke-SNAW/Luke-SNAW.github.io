<h1 id="five-tips-for-a-healthier-postgres-database-in-the-new-year">Five Tips For a Healthier Postgres Database in the New Year<a aria-hidden="true" class="anchor-heading icon-link" href="#five-tips-for-a-healthier-postgres-database-in-the-new-year"></a></h1>
<blockquote>
<p><a href="https://www.crunchydata.com/blog/five-tips-for-a-healthier-postgres-database-in-the-new-year">https://www.crunchydata.com/blog/five-tips-for-a-healthier-postgres-database-in-the-new-year</a></p>
</blockquote>
<h2 id="set-a-statement-timeout">Set a statement timeout<a aria-hidden="true" class="anchor-heading icon-link" href="#set-a-statement-timeout"></a></h2>
<p>Long running (usually unintentionally so) queries can wreck havoc on a database. They can hold up other queries, replication, or other database processes. Most applications are designed for typical queries to run in a few milliseconds. You may have long running queries for reporting, but these are best offloaded to a read replica for reporting and analytics. To prevent those long running queries you can set a <code>statement_timeout</code>:</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> mydatabase <span class="token keyword">SET</span> statement_timeout <span class="token operator">=</span> <span class="token string">'60s'</span><span class="token punctuation">;</span>
</code></pre>
<p><em>For good measure you may also want to set your <code>idle_in_transaction</code> timeout as well, which will cancel long running transaction that are no longer performing work.</em></p>
<h2 id="ensure-you-have-query-tracking">Ensure you have query tracking<a aria-hidden="true" class="anchor-heading icon-link" href="#ensure-you-have-query-tracking"></a></h2>
<p>Understanding what is going on inside your database is always a good idea. Which queries are slow? Which queries are run too many times? Enter the most useful Postgres extension that exists: <code>pg_stat_statements</code>.</p>
<p>Pg_stat_statements records every query that runs against your database, parameterizes it, and then records a variety of metrics about it. That makes it easy to answer the above questions. If you don't have it installed already do it today by running:</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> EXTENSION pg_stat_statements<span class="token punctuation">;</span>
</code></pre>
<p>Once it's in place you can take a look at our <a href="https://www.crunchydata.com/blog/tentative-smarter-query-optimization-in-postgres-starts-with-pg_stat_statements">deep dive</a> on all the insights it can show you.</p>
<h2 id="log-slow-running-queries">Log slow running queries<a aria-hidden="true" class="anchor-heading icon-link" href="#log-slow-running-queries"></a></h2>
<p>While <code>pg_stat_statements</code> is useful for looking at frequently run queries or queries that may always be slow, sometimes you have extreme outlier queries. With <code>pg_stat_statements</code> you may review your queries every few months. Meanwhile your Postgres logs likely <a href="https://docs.crunchybridge.com/how-to/logging/?CrunchyAnonId=caesivkkyecnldlsqpittjuniiyazdbraadbozbw">feed into</a> some other central system that you are monitoring daily and have alerting on. Catching these slow outlier queries early can be a great canary for things you should quickly move off to a read-replica for scaling or that you should rewrite to be more efficient. You can <a href="https://www.crunchydata.com/blog/logging-tips-for-postgres-featuring-your-slow-queries">log all slow queries</a> that take over a certain time with <code>log_min_duration_statement</code>.</p>
<p>For many SaaS applications setting your <code>log_min_duration_statement</code> to something like 1 second: <code>1s</code> or even as low as 100 milliseconds: <code>100ms</code> can be a big asset.</p>
<h2 id="improve-your-connection-management">Improve your connection management<a aria-hidden="true" class="anchor-heading icon-link" href="#improve-your-connection-management"></a></h2>
<p>If you're using Rails, Django, Hibernate or any other framework/ORM you've likely set a connection pool in your application settings for your database. That connection pool is likely reducing latency in new connections to your database, but is also limiting the performance available for your database. On versions prior to Postgres 14, connections consumed extra overhead leaving <code>idle</code> connections as wasted space. The solution to this is not to replace your in app connection pooling, but rather add a server side connection pooler such as PgBouncer. With PgBouncer you're able to scale to 10s of thousands of connections with no problem. You can take a quick look at your existing database to see if PgBouncer would help:</p>
<pre class="language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       state
<span class="token keyword">FROM</span> pg_stat_activity
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre>
<p>If you see <code>idle</code> is above 20 it's recommended to explore using PgBouncer. Adding PgBouncer is often a no brainer to get better performance without any heavy refactoring required. And to make it easy if you're on <a href="https://docs.crunchybridge.com/how-to/pgbouncer/?CrunchyAnonId=caesivkkyecnldlsqpittjuniiyazdbraadbozbw">Crunchy Bridge</a> it's already available to you.</p>
<h2 id="find-your-goldilocks-range-for-indexes">Find your goldilocks range for indexes<a aria-hidden="true" class="anchor-heading icon-link" href="#find-your-goldilocks-range-for-indexes"></a></h2>
<p>There seems to be a common lifecycle of indexes within applications. First you start off with almost none, maybe a few on primary keys. Then you start adding them, one by one, two by two, until you've got quite a few indexes for most any query you can run. Something is slow? Throw an index at it. What you end up with is some contention on overall throughput of your database, and well a lot of indexes that became a tangled ball of yarn over time.</p>
<p>We've got a slew of write-ups and guides on indexes and unfortunately there isn't a "this is your one thing to read and your done". But a few key things and you can be in a better place:</p>
<ul>
<li><a href="https://www.crunchydata.com/blog/three-easy-things-to-remember-about-postgres-indexes">A primer on indexes</a></li>
<li><a href="https://www.crunchydata.com/blog/cleaning-up-your-postgres-database">Check for unused indexes</a></li>
<li><a href="https://learn.crunchydata.com/postgresql-devel/courses/basics/indextypes">Index types in Postgres</a></li>
<li><a href="https://learn.crunchydata.com/postgresql-devel/courses/basics/introindex">A starter lesson on indexes</a></li>
</ul>
<h2 id="heres-to-less-database-problems-in-2022">Here's to less database problems in 2022<a aria-hidden="true" class="anchor-heading icon-link" href="#heres-to-less-database-problems-in-2022"></a></h2>
<p>Our goal at Crunchy is to make Postgres great. One part of that is helping our customers understand their database and providing them with support and guidance for all their Postgres needs.</p>
<p>With <a href="https://www.crunchydata.com/products/crunchy-bridge/">Crunchy Bridge</a> we're working towards making all of the above easier, so it's one less thing you have to worry about. We've already had customers migrate and see <a href="https://www.crunchydata.com/case-studies/rival-iq/">3-5x performance improvement</a> over their existing cloud providers. We know if you're here you're already a fan of Postgres. In this coming year we look forward to making the developer experience of Postgres better than it's ever been.</p>
<hr>
<h2 id="pg_stat_statements-is-not-free"><a href="https://news.ycombinator.com/item?id=34754445">pg_stat_statements is not free</a><a aria-hidden="true" class="anchor-heading icon-link" href="#pg_stat_statements-is-not-free"></a></h2>
<p>pg_stat_statements is useful, but it isn't completely free, e.g. <a href="https://www.alibabacloud.com/blog/postgresql-v12-how-pg-stat-statements-causes-high-concurrency-performance-issues_597790">https://www.alibabacloud.com/blog/postgresql-v12-how-pg-stat-statements-causes-high-concurrency-performance-issues_597790</a> (admittedly from pg12, which is three major versions ago).</p>
<p>Most people should probably leave it enabled, but if you have a database with a very defined and understood query pattern, then it might be worth running <em>perf</em> and checking if it is costing you.</p>