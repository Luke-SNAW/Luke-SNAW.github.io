<h1 id="software-engineering">Software Engineering<a aria-hidden="true" class="anchor-heading icon-link" href="#software-engineering"></a></h1>
<h2 id="collections">Collections<a aria-hidden="true" class="anchor-heading icon-link" href="#collections"></a></h2>
<ul>
<li>
<p><a href="https://github.com/alan2207/bulletproof-react">Bulletproof React</a> - A simple, scalable, and powerful architecture for building production ready React applications.</p>
</li>
<li>
<p><a href="https://refactoring.guru/refactoring/smells">Code Smells</a></p>
</li>
<li>
<p><a href="https://hcarvalhoalves.github.io/software-development-waste/">Notes on Software Development Waste</a></p>
</li>
<li>
<p><a href="https://swizec.com/blog/even-small-things-can-make-your-code-gnarly/">Small choices can wreck your codebase</a></p>
</li>
<li>
<p><a href="https://arnoldgalovics.com/microservices-in-production/">Don’t start with microservices – monoliths are your friend</a></p>
</li>
<li>
<p><a href="https://www.swyx.io/career-ladders/">Every Public Engineering Career Ladder</a></p>
</li>
<li>
<p><a href="https://xdg.me/ask-for-feedback/">Best career advice: ask for feedback</a></p>
</li>
<li>
<p><a href="https://dmitripavlutin.com/interface-vs-implementation/">Programming to Interface Vs to Implementation</a></p>
</li>
<li>
<p><a href="https://refactoring.guru/design-patterns/catalog">The Catalog of Design Patterns</a></p>
</li>
<li>
<p><a href="https://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast">Make It Work Make It Right Make It Fast</a> is an assertion that if you can "make it right", you'll be able to "make it fast" later.</p>
</li>
<li>
<p><a href="https://kentcdodds.com/blog/colocation">Colocation</a></p>
</li>
<li>
<p><a href="https://github.com/elsewhencode/project-guidelines">Project Guidelines</a></p>
</li>
<li>
<p><a href="https://alexkondov.com/hexagonal-inspired-architecture-in-react/">Hexagonal-Inspired Architecture in React</a> <a class="color-tag" style="--tag-color: #1d5dec;" href="/notes/jqe1umqwl5gqjj4292jqy0f">#bookmark</a></p>
</li>
<li>
<p><a href="https://about.sourcegraph.com/blog/cheating-is-all-you-need">Cheating is All You Need</a></p>
<blockquote>
<p>Software engineering exists as a discipline because you cannot EVER under any circumstances TRUST CODE.</p>
<ul>
<li>You get the LLM to draft some code for you that’s 80% complete/correct.</li>
<li>You tweak the last 20% by hand.</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p><a href="https://news.ycombinator.com/item?id=35275438">Vanclief</a> is hesitant about 5 times as productive because we only need to "check the code is good" for two main reasons:</p>
<ol>
<li>It is my belief that if you are proficient enough in the task at hand, it is actually a distraction to be checking "someone else code" over just writing it yourself. When I wrote the code, I know it by heart and I know what it does (or is supposed to do). At least for me, having to be creating prompts and then reviewing the code that generates is slower and takes me out of the flow. It is also more exhausting than just writing the thing myself.</li>
<li>I am only able to check the correctness of the code, if am am proficient enough as a programmer (and possibly in the language as well). To become proficient I need to write a lot of code, but the more I use LLMs, the less repetitions I get in. So in a way it feels like LLMs are going to make you a "worse" programmer by doing the work for you.</li>
</ol>
</blockquote>
</blockquote>
</li>
<li>
<p><a href="https://floooh.github.io/2018/06/17/handles-vs-pointers.html">Handles are the better pointers</a></p>
</li>
<li>
<p><a href="https://www.evanjones.ca/nanosecond-collisions.html">Nanosecond timestamp collisions are common</a></p>
<ul>
<li><a href="https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format">https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format</a></li>
</ul>
</li>
<li>
<p><a href="https://instagram-engineering.com/what-powers-instagram-hundreds-of-instances-dozens-of-technologies-adf2e22da2ad">How Instagram scaled to 14 million users with only 3 engineers</a></p>
<ul>
<li>Keep things very simple.</li>
<li>Don’t re-invent the wheel.</li>
<li>Use proven, solid technologies when possible.</li>
</ul>
</li>
<li>
<p><a href="https://htmx.org/essays/locality-of-behaviour/">Locality of Behaviour (LoB)</a></p>
</li>
<li>
<p><a href="https://alexkondov.com/locality-of-behavior-react/">Locality of Behavior in React Components</a></p>
<blockquote>
<p>Abstractions are not an enemy of locality. You don’t need to inline everything in a single file. In the context of a React component, the invocation of the function is more important than what it actually does.</p>
</blockquote>
</li>
<li>
<p><a href="https://samwho.dev/bloom-filters/">Bloom Filters</a></p>
<ul>
<li>Bloom filters return true it doesn't mean "yes", it means "maybe", false-positive.</li>
<li>If you're happy to accept being wrong 0.0001% of the time (1 in a million), you could use a bloom filter which can store the same data in 82% reduction in size.</li>
</ul>
</li>
<li>
<p><a href="https://maheshba.bitbucket.io/blog/2024/05/08/2024-ThreeLaws.html">Three Laws of Software Complexity</a></p>
<ol>
<li>A well-designed system will degrade into a badly designed system over time.</li>
<li>Complexity is a Moat (filled by Leaky Abstractions).</li>
<li>There is no fundamental upper limit on Software Complexity.</li>
</ol>
</li>
<li>
<p><a href="https://jazco.dev/2025/02/19/imperfection/">When Imperfect Systems are Good, Actually: Bluesky's Lossy Timelines</a></p>
</li>
<li>
<p><a href="https://blog.startifact.com/posts/succinct/">Succinct data structures</a></p>
</li>
<li>
<p><a href="https://compilade.net/blog/ternary-packing">How to pack ternary numbers in 8-bit bytes</a></p>
<blockquote>
<p><code>log(3) / log(2)</code> bits per ternary digit</p>
</blockquote>
</li>
<li>
<p><a href="https://iamvishnu.com/posts/utf8-is-brilliant-design">UTF-8 is a Brilliant Design</a> - still be backward compatible with ASCII</p>
<ol>
<li>Read a byte. If it starts with 0, it's a single-byte character (ASCII). Show the character represented by the remaining 7 bits on the screen. Continue with the next byte.</li>
<li>If the byte didn't start with a 0, then:
<ul>
<li>If it starts with 110, it's a two-byte character, so read the next byte as well.</li>
<li>If it starts with 1110, it's a three-byte character, so read the next two bytes.</li>
<li>If it starts with 11110, it's a four-byte character, so read the next three bytes.</li>
</ul>
</li>
<li>Once the number of bytes are determined, read all the remaining bits except the leading bits, and find the binary value (aka. code point) of the character.</li>
<li>Look up the code point in the Unicode character set to find the corresponding character and display it on the screen.</li>
<li>Read the next byte and repeat the process.</li>
</ol>
</li>
<li>
<p><a href="https://www.zigae.com/chrome-gc/">V8과 WebAssembly: 현대 자바스크립트 엔진의 구조와 성능 최적화(상하편)</a></p>
<ul>
<li>V8의 세대별 힙 구조는 객체의 수명에 따라 최적화된 처리를 가능하게 하며, Young Generation과 Old Generation으로 구분되어 관리된다.</li>
<li>V8의 세대별 객체 승격 메커니즘은 Age-based, Size-based, Pretenuring 등의 복합적인 휴리스틱을 사용하여 객체를 Old Generation으로 승격시킨다.</li>
<li>React의 Fiber 아키텍처는 V8의 세대별 가설과 충돌하며, Fiber 노드는 컴포넌트가 마운트된 동안 계속 살아있어 Old Generation으로 승격되어 Major GC 부담을 증가시킨다.</li>
<li>React Hooks는 클로저 메모리 누수를 일으킬 수 있으며, useEffect와 같은 훅은 클로저가 전체 컴포넌트 스코프를 캡처하여 메모리 누수를 유발할 수 있다.</li>
<li>V8의 Orinoco 프로젝트는 병렬 처리, 증분 처리, 동시 처리 등의 기술을 도입하여 GC pause time을 크게 감소시켰으며, 특히 동시 마킹은 Major GC pause time을 60-70% 감소시켰다.</li>
</ul>
</li>
</ul>
<h2 id="modeling">Modeling<a aria-hidden="true" class="anchor-heading icon-link" href="#modeling"></a></h2>
<ul>
<li><a href="https://www.socallinuxexpo.org/scale/22x/presentations/closing-keynote-leslie-lamport">Coding Isn't Programming</a> - Closing Keynote with Leslie Lamport <a href="https://www.socallinuxexpo.org/sites/default/files/presentations/linux-expo%20%281%29.pdf">PDF</a>
<ul>
<li><a href="https://news.hada.io/topic?id=19969">https://news.hada.io/topic?id=19969</a></li>
</ul>
</li>
<li><a href="https://muratbuffalo.blogspot.com/2018/01/why-you-should-use-modeling-with.html">Why you should use modeling [with TLA+/PlusCal]</a>
<ul>
<li>Modeling shows you how sloppy your "design" is.</li>
<li>Being smart does not scale; exhaustive model checking comes to the rescue</li>
<li>Don't trust your deduction abilities for proving that each action preserves the safety conditions you identify.</li>
</ul>
</li>
</ul>
<h2 id="you-cant-buy-integration"><a href="https://martinfowler.com/articles/cant-buy-integration.html">You Can't Buy Integration</a><a aria-hidden="true" class="anchor-heading icon-link" href="#you-cant-buy-integration"></a></h2>
<ul>
<li><a href="http://paulgraham.com/weird.html">99.5% of programming consists of gluing together calls to library functions.</a></li>
</ul>
<h2 id="dont-call-yourself-a-programmer-and-other-career-advice"><a href="https://www.kalzumeus.com/2011/10/28/dont-call-yourself-a-programmer/">Don't Call Yourself A Programmer, And Other Career Advice</a><a aria-hidden="true" class="anchor-heading icon-link" href="#dont-call-yourself-a-programmer-and-other-career-advice"></a></h2>
<ul>
<li>90% of programming jobs are in creating Line of Business software.</li>
<li>Engineers are hired to create business value, not to program things.</li>
<li>Add revenue. Reduce costs. Those are your only goals.</li>
</ul>
<h2 id="eight-tips-to-write-functions-like-a-senior-developer"><a href="https://medium.com/@dhruba-dahal/eight-tips-to-write-functions-like-a-senior-developer-794140719351">Eight tips to Write Functions like a Senior Developer</a><a aria-hidden="true" class="anchor-heading icon-link" href="#eight-tips-to-write-functions-like-a-senior-developer"></a></h2>
<ul>
<li>Do one thing and do it well</li>
<li>Never use flag arguments</li>
<li>Prefer exceptions over error codes</li>
<li>Make separation between command and query</li>
</ul>
<h2 id="architecture">Architecture<a aria-hidden="true" class="anchor-heading icon-link" href="#architecture"></a></h2>
<ul>
<li><a href="https://medium.com/codex/clean-architecture-for-dummies-df6561d42c94">Domain-centric Architectures (Clean and Hexagonal) for Dummies</a></li>
<li><a href="https://github.com/Sairyss/domain-driven-hexagon">Domain-Driven Hexagon</a></li>
<li><a href="https://www.infoq.com/news/2021/01/bbc-serverless-scale/">BBC Online Uses Serverless to Scale Extremely Fast</a></li>
<li><a href="https://www.patterns.dev/posts/islands-architecture/">Islands Architecture</a></li>
<li><a href="https://news.ycombinator.com/item?id=34230641">HN: Modules, not microservices</a>
<blockquote>
<ul>
<li>I just want to point out that for the second problem (scalability of CPU/memory/io), microservices almost always make things worse.</li>
<li>I was working at Amazon when they started transitioning from monolith to microservices, and the big win there was locality of data and caching.</li>
<li>Microservices are less <em>efficient</em>, but are still more <em>scalable</em>.</li>
<li>I am working on a project that uses a microservice architecture to make the individual components scalable and separate the concerns. However one of the unexpected consequences is that we are now doing a lot of network calls between these microservices, and this has actually become the main speed bottleneck for our program, especially since some of these services are not even in the same data center. We are now attempting to solve this with caches and doing batch requests, but all of this created additional overhead that could have all been avoided by not using microservices.<br>
This experience has strongly impacted my view of microservices and for all personal projects I will develop in the future I will stick with a monolith until much later instead of starting with microservices.</li>
</ul>
</blockquote>
</li>
<li><a href="https://medium.com/source-and-buggy/do-one-thing-and-do-it-well-886b11a5d21">Kernighan and Pike were right: Do one thing, and do it well</a></li>
<li><a href="https://fernandovillalba.substack.com/p/its-not-microservice-or-monolith">It's not microservice or monolith; it's cognitive load you need to understand first</a>
<blockquote>
<ul>
<li>“Instead of choosing between a monolithic architecture or a microservices architecture, design the software to fit the maximum team cognitive load”</li>
<li>If you have only one team, consider adjusting your architecture to match the team’s capacity. Favour monolithic, cohesive and modular architectures.</li>
<li>If you have multiple teams, consider doing microservices or similar type of architectures so they can work independently.</li>
<li>The types of communication boundaries change significantly between single and multiple team architectures. Single teams are optimized to communicate via the codebase, documentation, discussions and design meetings. Multiple teams are better optimized to communicate via well-designed APIs (or libraries) that abstract the complexities of their domains.</li>
</ul>
</blockquote>
</li>
<li><a href="https://techblog.lycorp.co.jp/ko/4-patterns-of-global-collaboration">한국어 몰라요 - 글로벌 협업의 4가지 패턴</a></li>
</ul>
<h3 id="thread-per-core"><a href="https://without.boats/blog/thread-per-core/">Thread-per-core</a><a aria-hidden="true" class="anchor-heading icon-link" href="#thread-per-core"></a></h3>
<p>The thread-per-core architecture for Rust async programs has been controversial. While it promises better performance and ease of implementation, it may only achieve one, not both. A share-nothing approach keeps data in separate core caches but is complex to implement transactionally. Research showed this approach reduced tail latencies over a shared approach. However, the experiments did not test dynamic work imbalances that could appear in practice. Work-stealing may help address imbalances while still keeping some data pinned to cores, achieving both performance and utilization benefits. The debate focuses on balancing work-stealing with shared state rather than ease of implementation claims.</p>
<blockquote>
<p><a href="https://news.ycombinator.com/item?id=37791635">The debate isn't about thread-per-core work stealing executors, it's whether async/await is a good abstraction for it in Rust. And the more async code I write the more I feel that it's leaky and hard to program against.</a></p>
</blockquote>
<h2 id="algorithms">Algorithms<a aria-hidden="true" class="anchor-heading icon-link" href="#algorithms"></a></h2>
<h3 id="hexagonal-grids"><a href="https://www.redblobgames.com/grids/hexagons/">Hexagonal Grids</a><a aria-hidden="true" class="anchor-heading icon-link" href="#hexagonal-grids"></a></h3>
<p>This guide discusses different approaches to representing hexagonal grids in code, including cube, axial, offset, and doubled coordinates.</p>
<ul>
<li>Each system has tradeoffs in terms of simplicity for algorithms and storage.</li>
<li>Axial coordinates are recommended for algorithms as they allow basic math operations.</li>
<li>Offset coordinates may be better for storage.</li>
</ul>
<h2 id="approximate-timing-for-various-operations-on-a-typical-pc"><a href="https://norvig.com/21-days.html">Approximate timing for various operations on a typical PC</a><a aria-hidden="true" class="anchor-heading icon-link" href="#approximate-timing-for-various-operations-on-a-typical-pc"></a></h2>
<table border="1" cellpadding="2" cellspacing="2"><tbody><tr><td>execute typical instruction</td><td align="right">1/1,000,000,000 sec = 1 nanosec</td></tr><tr><td>fetch from L1 cache memory</td><td align="right">0.5 nanosec</td></tr><tr><td>branch misprediction</td><td align="right">5 nanosec</td></tr><tr><td>fetch from L2 cache memory</td><td align="right">7 nanosec</td></tr><tr><td>Mutex lock/unlock</td><td align="right">25 nanosec</td></tr><tr><td>fetch from main memory</td><td align="right">100 nanosec</td></tr><tr><td>send 2K bytes over 1Gbps network</td><td align="right">20,000 nanosec</td></tr><tr><td>read 1MB sequentially from memory</td><td align="right">250,000 nanosec</td></tr><tr><td>fetch from new disk location (seek)</td><td align="right">8,000,000 nanosec</td></tr><tr><td>read 1MB sequentially from disk</td><td align="right">20,000,000 nanosec</td></tr><tr><td>send packet US to Europe and back</td><td align="right">150 milliseconds = 150,000,000 nanosec</td></tr></tbody></table>
<h2 id="crypto">Crypto<a aria-hidden="true" class="anchor-heading icon-link" href="#crypto"></a></h2>
<ul>
<li><a href="https://cryptopals.com/">the cryptopals crypto challenges</a></li>
</ul>
<hr>
<strong>Children</strong>
<ol>
<li><a href="/notes/ndzzrqq15oi71pbemlkqse3">1x Programming</a></li>
<li><a href="/notes/6lhj3c2ssl5vhunnbtfvdui">Base64 Encoding, Explained</a></li>
<li><a href="/notes/3qd6qjev0hbwuzw47h96vee">Clean Architecture on Frontend</a></li>
<li><a href="/notes/7jdxj17k3fj5r6l4zuqdx57">Fast-Paced Multiplayer (Part II): Client-Side Prediction and Server Reconciliation</a></li>
<li><a href="/notes/kkmhbz67acbzr5hxrw1cbxa">Fast-Paced Multiplayer (Part III): Entity Interpolation</a></li>
<li><a href="/notes/o2xgz8c6d9xn3at1rjymbnw">Fast-Paced Multiplayer (Part IV): Lag Compensation</a></li>
<li><a href="/notes/80dlg24o2sdu3ti1ipwlgcb">Feature Sliced Design</a></li>
<li><a href="/notes/bpw92y9ez0959qtnaedllfs">How Pinterest scaled to 11 million users with only 6 engineers</a></li>
<li><a href="/notes/e3yxr6ae8tfu2hzmbi70rzc">In defense of simple architectures</a></li>
<li><a href="/notes/x8ialsmpsu1udfkifxlitql">L8 Explains Career of Software Engineers</a></li>
<li><a href="/notes/6hmmfse40un0yvyhcfhf1kh">Master the Art of Caching for System Design Interviews: A Complete Guide</a></li>
<li><a href="/notes/p54hilx39w0qha68frckomu">PIDs: Creating Stable Control in Games</a></li>
<li><a href="/notes/cdve3pqbh1ftajzj8uu0get">Programming as Theory Building</a></li>
<li><a href="/notes/7uuid3nck5c8r1ngjm8o254">Recommendations for designing magic numbers of binary file formats</a></li>
<li><a href="/notes/c00nsizm5rcb32jay5z3ifm">Refactoring</a></li>
<li><a href="/notes/a48cslm3wj5bpq04rrkzrhx">Services By Lifecycle</a></li>
<li><a href="/notes/2az7jx1wd9guc66l1cdb54j">The 7 Most Influential Papers in Computer Science History</a></li>
<li><a href="/notes/tgud80cj6687x0o11ht4sn6">The Entity Service Antipattern</a></li>
<li><a href="/notes/bmkxxriirn5e6ajhyzpiqtb">The Law of Leaky Abstractions</a></li>
<li><a href="/notes/h4bdthyszcjle90ytec22xp">Tidy First? Kent Beck on Refactoring</a></li>
<li><a href="/notes/97ha3zf4db021vg7p1jtby7">What Sets an Exceptional Programmer Apart From an Ordinary Programmer</a></li>
<li><a href="/notes/2xg6iqfwi5i0aceu5y7d1h2">What the heck is the edge anyway?</a></li>
</ol>