<h1 id="making-sense-of-react-server-components">Making Sense of React Server Components<a aria-hidden="true" class="anchor-heading icon-link" href="#making-sense-of-react-server-components"></a></h1>
<blockquote>
<p><a href="https://www.joshwcomeau.com/react/server-components/">https://www.joshwcomeau.com/react/server-components/</a></p>
</blockquote>
<p>So, here's something that makes me feel old: React celebrated its 10th birthday this year!</p>
<p>In the decade since React was first introduced to a bewildered dev community, it’s gone through several evolutions. The React team has not been shy when it comes to radical changes: if they discover a better solution to a problem, they'll run with it.</p>
<p>A couple of months ago, the React team unveiled <em>React Server Components,</em> the latest paradigm shift. For the first time ever, React components can run exclusively on the server.</p>
<p>There's been <em>so much friggin’ confusion</em> about this online. Lots of folks have lots of questions around what this is, how it works, what the benefits are, and how it fits together with things like Server Side Rendering.</p>
<p>I've been doing a lot of experimentation with React Server Components, and I've answered a lot of my own questions. I have to admit, I'm <em>way</em> more excited about this stuff than I expected to be. <em>It's really cool!</em></p>
<p>So, my goal today is to help demystify this stuff for you, to answer a lot of the questions you might have about React Server Components!</p>
<blockquote>
<p><strong>Intended audience</strong></p>
<p>This tutorial is written primarily for developers who are already using React, and who are curious about React Server Components. You don't need to be a React expert, but it will likely be pretty confusing if you're just getting started with React.</p>
</blockquote>
<h2 id="a-quick-primer-on-server-side-rendering"><a href="https://www.joshwcomeau.com/react/server-components/#a-quick-primer-on-server-side-rendering-1">A quick primer on Server Side Rendering</a><a aria-hidden="true" class="anchor-heading icon-link" href="#a-quick-primer-on-server-side-rendering"></a></h2>
<p>To put React Server Components in context, it's helpful to understand how Server Side Rendering (SSR) works. If you're already familiar with SSR, feel free to skip to the next heading!</p>
<p>When I first started using React in 2015, most React setups used a “client-side” rendering strategy. The user would receive an HTML file that looked like this:</p>
<pre class="language-html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&#x3C;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>html</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>root<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/static/js/bundle.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>html</span><span class="token punctuation">></span></span>
</code></pre>
<p>That <code>bundle.js</code> script includes everything we need to mount and run the application, including React, other third-party dependencies, and all of the code we've written.</p>
<p>Once the JS has been downloaded and parsed, React springs into action, conjuring all of the DOM nodes for our entire application, and housing it in that empty <code>&#x3C;div id="root"></code>.</p>
<p>The problem with this approach is that it takes time to do all of that work. <strong>And while it's all happening, the user is staring at a blank white screen.</strong> This problem tends to get worse over time: every new feature we ship adds more kilobytes to our JavaScript bundle, prolonging the amount of time that the user has to sit and wait.*</p>
<p>Server Side Rendering was designed to improve this experience. Instead of sending an empty HTML file, the server will render our application to <em>generate</em> the actual HTML. The user receives a fully-formed HTML document.</p>
<p>That HTML file will still include the <code>&#x3C;script></code> tag, since we still need React to run on the client, to handle any interactivity. But we configure React to work a little bit differently in-browser: instead of conjuring all of the DOM nodes from scratch, it instead <em>adopts</em> the existing HTML. This process is known as <em>hydration.</em></p>
<p>I like the way React core team member Dan Abramov explains this:</p>
<blockquote>
<p>Hydration is like watering the “dry” HTML with the “water” of interactivity and event handlers.</p>
</blockquote>
<p>Once the JS bundle has been downloaded, React will quickly run through our entire application, building up a virtual sketch of the UI, and “fitting” it to the real DOM, attaching event handlers, firing off any effects, and so on.</p>
<p>And so, that's SSR in a nutshell. A server generates the initial HTML so that users don't have to stare at an empty white page while the JS bundles are downloaded and parsed. Client-side React then picks up where server-side React left off, adopting the DOM and sprinkling in the interactivity.</p>
<blockquote>
<p><strong>An umbrella term</strong></p>
<p>When we talk about Server Side Rendering, we typically imagine a flow that looks like this:</p>
<ol>
<li>User visits <em>myWebsite.com</em>.</li>
<li>A Node.js server receives the request, and immediately renders the React application, generating the HTML.</li>
<li>That freshly-baked HTML is sent to the client.</li>
</ol>
<p>This is <em>one</em> possible way to implement Server Side Rendering, but it's not the only one. Another option is to generate the HTML when we <em>build the application.</em></p>
<p>Typically, React applications need to be <em>compiled</em>, transforming JSX into plain ol’ JavaScript, and bundling all of our modules. What if, during that same process, we “pre-rendered” all of the HTML for all of our different routes?</p>
<p>This is commonly known as <em>static site generation (SSG)</em>. It's a sub-variant of Server Side Rendering.</p>
<p>The way I see it, “Server Side Rendering” is an umbrella term that includes several different rendering strategies. They all have one thing in common: the initial render happens in a server runtime like Node.js, using the <code>ReactDOMServer</code> APIs. It doesn't actually matter <em>when</em> this happens, whether it's on-demand or at compile-time. Either way, it's Server Side Rendering.</p>
</blockquote>
<h2 id="bouncing-back-and-forth"><a href="https://www.joshwcomeau.com/react/server-components/#bouncing-back-and-forth-2">Bouncing back and forth</a><a aria-hidden="true" class="anchor-heading icon-link" href="#bouncing-back-and-forth"></a></h2>
<p>Let's talk about data-fetching in React. Typically, we've had two separate applications that communicate over the network:</p>
<ul>
<li>A client-side React app</li>
<li>A server-side REST API</li>
</ul>
<p>Using something like React Query or SWR or Apollo, the client would make a network request to the back-end, which would then grab the data from the database and send it back over the network.</p>
<p>We can visualize this flow using a graph:</p>
<blockquote>
<p>chart</p>
</blockquote>
<p>This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item.</p>
<ol>
<li>Response from server. Duration: 4 units of time.</li>
<li>"Download JavaScript" on client. Duration: 7 units of time.</li>
<li>"Render Shell" on client. Duration: 6 units of time.</li>
<li>Request to server. Duration: 4 units of time.</li>
<li>"Database Query" on server. Duration: 5 units of time.</li>
<li>Response from server. Duration: 4 units of time.</li>
<li>"Render Content" on client. Duration: 5 units of time.</li>
</ol>
<blockquote>
<p><strong>A note about these graphs</strong></p>
<p>This blog post includes several of these “network request graphs”. They're designed to visualize how data moves between client (browser) and server (back-end API), across several different rendering strategies.</p>
<p>The numbers along the bottom represent an imaginary made-up time unit. They're not minutes or seconds. <strong>In reality, the numbers vary wildly, based on a ton of different factors.</strong> These graphs are meant to give you a high-level understanding of the concepts, they're not modeling any real data.</p>
</blockquote>
<p>This first graph shows the flow using a Client Side Rendering (CSR) strategy. It starts with the client receiving an HTML file. This file doesn't have any content, but it does have one or more <code>&#x3C;script></code> tags.</p>
<p>Once the JS has been downloaded and parsed, our React app will boot up, creating a bunch of DOM nodes and populating the UI. At first, though, we don't have any of the actual <em>data</em>, so we can only render the shell (the header, the footer, the general layout) with a loading state.</p>
<p>You've probably seen this sort of pattern a lot. For example, UberEats starts by rendering a shell while it fetches the data it needs to populate the actual restaurants:</p>
<blockquote>
<p>skeleton UI</p>
</blockquote>
<p>The user will see this loading state until the network request resolves and React re-renders, replacing the loading UI with the real content.</p>
<p><strong>Let's look at another way we could architect this.</strong> This next graph keeps the same general data-fetching pattern, but uses <em>Server</em> Side Rendering instead of Client Side Rendering:</p>
<blockquote>
<p>chart</p>
</blockquote>
<p>This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item.</p>
<ol>
<li>"Render Shell" on server. Duration: 3 units of time.</li>
<li>Response from server. Duration: 4 units of time.</li>
<li>"Download JavaScript" on client. Duration: 7 units of time.</li>
<li>"Hydrate" on client. Duration: 3 units of time.</li>
<li>Request to server. Duration: 4 units of time.</li>
<li>"Database Query" on server. Duration: 5 units of time.</li>
<li>Response from server. Duration: 4 units of time.</li>
<li>"Render Content" on client. Duration: 5 units of time.</li>
</ol>
<p>In this new flow, we perform the first render on the server. This means that the user receives an HTML file that isn't totally empty.</p>
<p>This is an improvement — a shell is better than a blank white page — but ultimately, it doesn't really move the needle in a significant way. The user isn't visiting our app to see a loading screen, they're visiting to see the <em>content</em> (restaurants, hotel listings, search results, messages, whatever).</p>
<p>To really get a sense of the differences in user experience, let's add some web performance metrics to our graphs. <strong>Toggle between these two flows, and notice what happens to the flags:</strong></p>
<p>Client Side Rendering</p>
<blockquote>
<p>interactive chart</p>
</blockquote>
<p>This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item.</p>
<ol>
<li>Response from server. Duration: 4 units of time.</li>
<li>"Download JavaScript" on client. Duration: 7 units of time.</li>
<li>"Render Shell" on client. Duration: 6 units of time.</li>
<li>Request to server. Duration: 4 units of time.</li>
<li>"Database Query" on server. Duration: 5 units of time.</li>
<li>Response from server. Duration: 4 units of time.</li>
<li>"Render Content" on client. Duration: 5 units of time.</li>
</ol>
<p>Each of these flags represents a commonly-used web performance metric. Here's the breakdown:</p>
<ol>
<li><strong>First Paint</strong> — The user is no longer staring at a blank white screen. The general layout has been rendered, but the content is still missing. This is sometimes called FCP (First Contentful Paint).</li>
<li><strong>Page Interactive</strong> — React has been downloaded, and our application has been rendered/hydrated. Interactive elements are now fully responsive. This is sometimes called TTI (Time To Interactive).</li>
<li><strong>Content Paint</strong> — The page now includes the stuff the user cares about. We've pulled the data from the database and rendered it in the UI. This is sometimes called LCP (Largest Contentful Paint).</li>
</ol>
<p>By doing the initial render on the server, we're able to get that initial “shell” drawn more quickly. This can make the loading experience feel a bit faster, since it provides a sense of progress, that things are happening.</p>
<p>And, in some situations, this <em>will</em> be a meaningful improvement. For example, maybe the user is only waiting for the header to load so that they can click a navigation link.</p>
<p><strong>But doesn't this flow feel a bit silly?</strong> When I look at the SSR graph, I can't help but notice that the request <em>starts</em> on the server. Instead of requiring a second round-trip network request, why don't we do the database work <em>during that initial request?</em></p>
<p>In order words, <strong>why not do something like this?</strong></p>
<blockquote>
<p>chart</p>
</blockquote>
<p>This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item.</p>
<ol>
<li>"Database Query" on server. Duration: 5 units of time.</li>
<li>"Render App" on server. Duration: 6 units of time.</li>
<li>Response from server. Duration: 4 units of time.</li>
<li>"Download JavaScript" on client. Duration: 7 units of time.</li>
<li>"Hydrate" on client. Duration: 3 units of time.</li>
</ol>
<p>Instead of bouncing back and forth between the client and server, we do our database query as part of the initial request, sending the fully-populated UI straight to the user.</p>
<p>But hm, how exactly would we do this?</p>
<p>In order for this to work, we'd need to be able to give React a chunk of code that it runs <em>exclusively</em> on the server, to do the database query. But that hasn't been an option with React… even with Server Side Rendering, all of our components render on <em>both</em> the server and the client.</p>
<p><strong>The ecosystem has come up with lots of solutions to this problem.</strong> Meta-frameworks? like Next.js and Gatsby have created their own way to run code exclusively on the server.</p>
<p>For example, here's what this looked like using Next.js (using the legacy “Pages” router):</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword module">import</span> <span class="token imports">db</span> <span class="token keyword module">from</span> <span class="token string">"imaginary-db"</span>
<span class="token comment">// This code only runs on the server:</span>
<span class="token keyword module">export</span> <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getServerSideProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> link <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token method function property-access">connect</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"passw0rd"</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword control-flow">await</span> db<span class="token punctuation">.</span><span class="token method function property-access">query</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">"SELECT * FROM products"</span><span class="token punctuation">)</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">{</span> data <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// This code runs on the server + on the client</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Homepage</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> data <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">Trending Products</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>data<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>article</span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>h2</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">title</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>h2</span><span class="token punctuation">></span></span><span class="token plain-text">
          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">description</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>article</span><span class="token punctuation">></span></span>
      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>Let's break this down:</strong> when the server receives a request, the <code>getServerSideProps</code> function is called. It returns a <code>props</code> object. Those props are then funneled into the component, which is rendered first on the server, and then hydrated on the client.</p>
<p>The clever thing here is that <code>getServerSideProps</code> doesn't re-run on the client. In fact, this function isn't even included in our JavaScript bundles!</p>
<p>This approach was <em>super</em> ahead of its time. Honestly, it's pretty friggin’ great. But there <em>are</em> some downsides with this:</p>
<ol>
<li>This strategy only works at the route level, for components at the very top of the tree. We can't do this in any component.</li>
<li>Each meta-framework came up with its own approach. Next.js has one approach, Gatsby has another, Remix has yet another. It hasn't been standardized.</li>
<li>All of our React components will <em>always</em> hydrate on the client, even when there's no need for them to do so.</li>
</ol>
<p>For years, the React team has been quietly tinkering on this problem, trying to come up with an official way to solve this problem. Their solution is called <strong>React Server Components.</strong></p>
<h2 id="introduction-to-react-server-components"><a href="https://www.joshwcomeau.com/react/server-components/#introduction-to-react-server-components-3">Introduction to React Server Components</a><a aria-hidden="true" class="anchor-heading icon-link" href="#introduction-to-react-server-components"></a></h2>
<p>At a high level, <em>React Server Components</em> is the name for a brand-new paradigm. In this new world, we can create components that run <em>exclusively on the server</em>. This allows us to do things like write database queries right inside our React components!</p>
<p>Here's a quick example of a “Server Component”:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword module">import</span> <span class="token imports">db</span> <span class="token keyword module">from</span> <span class="token string">"imaginary-db"</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Homepage</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> link <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token method function property-access">connect</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"passw0rd"</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword control-flow">await</span> db<span class="token punctuation">.</span><span class="token method function property-access">query</span><span class="token punctuation">(</span>link<span class="token punctuation">,</span> <span class="token string">"SELECT * FROM products"</span><span class="token punctuation">)</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">Trending Products</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>h1</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>data<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>article</span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>h2</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">title</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>h2</span><span class="token punctuation">></span></span><span class="token plain-text">
          </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">description</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">
        </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>article</span><span class="token punctuation">></span></span>
      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">Homepage</span>
</code></pre>
<p>As someone who has been using React for many years, this code looked <em>absolutely wild</em> to me at first. 😅</p>
<p>“But wait!”, my instincts screamed. “Function components can't be asynchronous! And we're not allowed to have side effects directly in the render like that!”</p>
<p><strong>The key thing to understand is this:</strong> Server Components never re-render. They run <em>once</em> on the server to generate the UI. The rendered value is sent to the client and locked in place. As far as React is concerned, this output is immutable, and will never change.*</p>
<p>This means that a <em>big chunk</em> of React's API is incompatible with Server Components. For example, we can't use state, because state can change, but Server Components can't re-render. And we can't use effects because effects only run <em>after</em> the render, on the client, and Server Components never make it to the client.</p>
<p>It also means that we have a bit more flexibility when it comes to the rules. For example, in traditional React, we need to put side effects inside a <code>useEffect</code> callback or an event handler or something, so that they don't repeat on every render. But if the component only runs <em>once</em>, we don't have to worry about that!</p>
<p>Server Components <em>themselves</em> are surprisingly straightforward, but the “React Server Components” paradigm is significantly more complex. This is because we <em>still have</em> regular ol’ components, and the way they fit together can be pretty confusing.</p>
<p>In this new paradigm, the “traditional” React components we're familiar with are called <em>Client Components</em>. I'll be honest, I don't love this name. 😅</p>
<p>The name “Client Component” implies that these components <em>only</em> render on the client, but that's not actually true. <strong>Client Components render on both the client <em>and</em> the server.</strong></p>
<p>I know that all this terminology is pretty confusing, so here's how I'd summarize it:</p>
<ul>
<li><em>React Server Components</em> is the name for this new paradigm.</li>
<li>In this new paradigm, the “standard” React components we know and love have been rebranded as <em>Client Components</em>. It's a new name for an old thing.</li>
<li>This new paradigm introduces a new type of component, <em>Server Components</em>. These new components render exclusively on the server. Their code isn't included in the JS bundle, and so they never hydrate or re-render.</li>
</ul>
<blockquote>
<p><strong>React Server Components vs. Server Side Rendering</strong></p>
<p>Let's clear up another common bit of confusion: React Server Components is <em>not</em> a replacement for Server Side Rendering. You shouldn't think of React Server Components as “SSR version 2.0”.</p>
<p>Instead, I like to think of it as two separate puzzle pieces that snap together perfectly, two flavors that complement each other.</p>
<p>We still rely on Server Side Rendering to generate the initial HTML. React Server Components builds on top of that, allowing us to omit certain components from the client-side JavaScript bundle, ensuring they only run on the server.</p>
<p>In fact, it's even possible to use React Server Components <em>without</em> Server Side Rendering, though in practice, you'll get better results if you use them together. The React team has built a <a href="https://github.com/reactjs/server-components-demo">minimal RSC demo</a> without SSR, if you'd like to see an example.</p>
</blockquote>
<h3 id="compatible-environments"><a href="https://www.joshwcomeau.com/react/server-components/#compatible-environments-4">Compatible Environments</a><a aria-hidden="true" class="anchor-heading icon-link" href="#compatible-environments"></a></h3>
<p>So, typically, when a new React feature comes out, we can start using it in our existing projects by bumping our React dependency to the latest version. A quick <code>npm install react@latest</code> and we're off to the races.</p>
<p>Unfortunately, React Server Components doesn't work like that.</p>
<p>My understanding is that React Server Components needs to be tightly integrated with a bunch of stuff outside of React, things like the bundler, the server, and the router.</p>
<p>As I write this, there's only one way to start using React Server Components, and that's with Next.js 13.4+, using their brand-new re-architected “App Router”.</p>
<p>Hopefully in the future, more React-based frameworks will start to incorporate React Server Components. It feels awkward that a core React feature is only available in one particular tool! The React docs has a <a href="https://react.dev/learn/start-a-new-react-project#bleeding-edge-react-frameworks">“Bleeding-edge frameworks” section</a> where they list the frameworks that support React Server Components; I plan on checking this page from time to time, to see if any new options become available.</p>
<h3 id="specifying-client-components"><a href="https://www.joshwcomeau.com/react/server-components/#specifying-client-components-5">Specifying client components</a><a aria-hidden="true" class="anchor-heading icon-link" href="#specifying-client-components"></a></h3>
<p>In this new “React Server Components” paradigm, <strong>all components are assumed to be Server Components by default.</strong> We have to “opt in” for Client Components.</p>
<p>We do this by specifying a brand-new <em>directive</em>:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token string">"use client"</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">React</span></span> <span class="token keyword module">from</span> <span class="token string">"react"</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">Current value: </span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>button</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token maybe-class-name">Counter</span>
</code></pre>
<p>That standalone string at the top, <code>'use client'</code>, is how we signal to React that the component(s) in this file are Client Components, that they should be included in our JS bundles so that they can re-render on the client.</p>
<p>This might <em>seem</em> like an incredibly odd way to specify the type of component we're creating, but there is a precedent for this sort of thing: the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">"use strict"</a> directive that opts into “Strict Mode” in JavaScript.</p>
<p>We don't specify the <code>'use server'</code> directive in our Server Components; in the React Server Components paradigm, components are treated as Server Components by default. In fact, <code>'use server'</code> is used for Server Actions, a totally different feature that is beyond the scope of this blog post.</p>
<blockquote>
<p><strong>Which components should be Client Components?</strong></p>
<p>You might be wondering: how should I decide whether a given component should be a Server Component or a Client Component?</p>
<p>As a general rule, if a component <em>can</em> be a Server Component, it <em>should</em> be a Server Component. Server Components tend to be simpler and easier to reason about. There's also a performance benefit: because Server Components don't run on the client, their code isn't included in our JavaScript bundles. One of the benefits of the React Server Components paradigm is that it has the potential to improve the <em>Page Interactive</em> (TTI) metric.</p>
<p>That said, we also shouldn't make it our mission to eradicate as many Client Components as possible! We shouldn't try to optimize for the smallest # of Client Components. It's worth remembering that until now, <em>every</em> React component in every React app has been a Client Component.</p>
<p>As you start working with React Server Components, you'll likely discover that this is pretty intuitive. Some of our components will need to run on the client, because they use state variables or effects. You can slap a <code>'use client'</code> directive on those components. Otherwise, you can leave them as Server Components.</p>
</blockquote>
<h2 id="boundaries"><a href="https://www.joshwcomeau.com/react/server-components/#boundaries-6">Boundaries</a><a aria-hidden="true" class="anchor-heading icon-link" href="#boundaries"></a></h2>
<p>One of the first questions I had when I was getting familiar with React Server Components was this: <em>what happens when the props change?</em></p>
<p>For example, suppose we had a Server Component like this:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">HitCounter</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> hits <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">Number of hits: </span><span class="token punctuation">{</span>hits<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>div</span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span>
</code></pre>
<p>Let's suppose that in the initial Server Side Render, <code>hits</code> was equal to <code>0</code>. This component, then, will produce the following markup:</p>
<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>div</span><span class="token punctuation">></span></span>Number of hits: 0<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>div</span><span class="token punctuation">></span></span>
</code></pre>
<p>But what happens if the value of <code>hits</code> changes? Suppose it's a state variable, and it changes from <code>0</code> to <code>1</code>. <code>HitCounter</code> would need to re-render, but it <em>can't</em> re-render, because it's a Server Component!</p>
<p><strong>The thing is, Server Components don't really make sense in isolation.</strong> We have to zoom out, to take a more holistic view, to consider the structure of our application.</p>
<p>Let's say we have the following component tree:</p>
<blockquote>
<p>tree diagram</p>
</blockquote>
<p>If all of these components are Server Components, then it all makes sense. None of the props will ever change, because none of the components will ever re-render.</p>
<p>But let's suppose that <code>Article</code> component owns the <code>hits</code> state variable. In order to use state, we need to convert it to a Client Component:</p>
<blockquote>
<p>tree diagram</p>
</blockquote>
<p>Do you see the issue here? When <code>Article</code> re-renders, any owned components will <em>also</em> re-render, including <code>HitCounter</code> and <code>Discussion</code>. If these are Server Components, though, they <em>can't</em> re-render.</p>
<p>In order to prevent this impossible situation, the React team added a rule: <strong>Client Components can only import other Client Components.</strong> That <code>'use client'</code> directive means that these instances of <code>HitCounter</code> and <code>Discussion</code> will need to become Client Components.</p>
<p>One of the biggest “ah-ha” moments I had with React Server Components was the realization that this new paradigm is all about creating <em>client boundaries</em>. Here's what winds up happening, in practice:</p>
<blockquote>
<p>tree diagram of client boundary</p>
</blockquote>
<p>When we add the <code>'use client'</code> directive to the <code>Article</code> component, we create a “client boundary”. All of the components within this boundary are <em>implicitly</em> converted to Client Components. Even though components like <code>HitCounter</code> don't have the <code>'use client'</code> directive, they'll still hydrate/render on the client in this particular situation.*</p>
<p>This means we don't have to add <code>'use client'</code> to every single file that needs to run on the client. In practice, we only need to add it when we're creating new client boundaries.</p>
<h3 id="workarounds"><a href="https://www.joshwcomeau.com/react/server-components/#workarounds-7">Workarounds</a><a aria-hidden="true" class="anchor-heading icon-link" href="#workarounds"></a></h3>
<p>When I first learned that Client Components can't render Server Components, it felt pretty restrictive to me. What if I need to use state high up in the application? Does that mean <em>everything</em> needs to become a Client Component??</p>
<p>It turns out that in many cases, we can work around this limitation by restructuring our application so that the <em>owner</em> changes.</p>
<p>This is a tricky thing to explain, so let's use an example:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token string">"use client"</span>
<span class="token keyword module">import</span> <span class="token punctuation">{</span> <span class="token constant">DARK_COLORS</span><span class="token punctuation">,</span> <span class="token constant">LIGHT_COLORS</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">"@/constants.js"</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Header</span></span> <span class="token keyword module">from</span> <span class="token string">"./Header"</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">MainContent</span></span> <span class="token keyword module">from</span> <span class="token string">"./MainContent"</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Homepage</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>colorTheme<span class="token punctuation">,</span> setColorTheme<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">useState</span><span class="token punctuation">(</span><span class="token string">"light"</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> colorVariables <span class="token operator">=</span> colorTheme <span class="token operator">===</span> <span class="token string">"light"</span> <span class="token operator">?</span> <span class="token constant">LIGHT_COLORS</span> <span class="token operator">:</span> <span class="token constant">DARK_COLORS</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>body</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>colorVariables<span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span><span class="token class-name">Header</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span><span class="token class-name">MainContent</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>body</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>In this setup, we need to use React state to allow users to flip between dark mode / light mode. This needs to happen high up in the application tree, so that we can apply our CSS variable tokens to the <code>&#x3C;body></code> tag.</p>
<p>In order to use state, we need to make <code>Homepage</code> a Client Component. And since this is the top of our application, it means that all of the other components — <code>Header</code> and <code>MainContent</code> — will implicitly become Client Components too.</p>
<p>To fix this, let's pluck the color-management stuff into its own component, moved to its own file:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token comment">// /components/ColorProvider.js</span>
<span class="token string">"use client"</span>
<span class="token keyword module">import</span> <span class="token punctuation">{</span> <span class="token constant">DARK_COLORS</span><span class="token punctuation">,</span> <span class="token constant">LIGHT_COLORS</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">"@/constants.js"</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">ColorProvider</span></span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> children <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>colorTheme<span class="token punctuation">,</span> setColorTheme<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">useState</span><span class="token punctuation">(</span><span class="token string">"light"</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> colorVariables <span class="token operator">=</span> colorTheme <span class="token operator">===</span> <span class="token string">"light"</span> <span class="token operator">?</span> <span class="token constant">LIGHT_COLORS</span> <span class="token operator">:</span> <span class="token constant">DARK_COLORS</span>
  <span class="token keyword control-flow">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>body</span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>colorVariables<span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>body</span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span>
</code></pre>
<p>Back in <code>Homepage</code>, we use this new component like so:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token comment">// /components/Homepage.js</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Header</span></span> <span class="token keyword module">from</span> <span class="token string">"./Header"</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">MainContent</span></span> <span class="token keyword module">from</span> <span class="token string">"./MainContent"</span>
<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">ColorProvider</span></span> <span class="token keyword module">from</span> <span class="token string">"./ColorProvider"</span>
<span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Homepage</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span><span class="token class-name">ColorProvider</span></span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span><span class="token class-name">Header</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span><span class="token class-name">MainContent</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span><span class="token class-name">ColorProvider</span></span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
<p>We can remove the <code>'use client'</code> directive from <code>Homepage</code> because it no longer uses state, or any other client-side React features. This means that <code>Header</code> and <code>MainContent</code> won't be implicitly converted to Client Components anymore!</p>
<p><strong>But wait a second.</strong> <code>ColorProvider</code>, a Client Component, is a <em>parent</em> to <code>Header</code> and <code>MainContent</code>. Either way, it's still higher in the tree, right?</p>
<p>When it comes to client boundaries, though, the parent/child relationship doesn't matter. <code>Homepage</code> is the one importing and rendering <code>Header</code> and <code>MainContent</code>. This means that <code>Homepage</code> decides <em>what the props are</em> for these components.</p>
<p>Remember, the problem we're trying to solve is that Server Components can't re-render, and so they can't be given new values for any of their props. With this new setup, <code>Homepage</code> decides what the props are for <code>Header</code> and <code>MainContent</code>, and since <code>Homepage</code> is a Server Component, there's no problem.</p>
<p><strong>This is brain-bending stuff.</strong> Even after years of React experience, I still find this very confusing 😅. It took a fair bit of practice to develop an intuition for this.</p>
<p>To be more precise, the <code>'use client'</code> directive works at the file / module level. Any modules <em>imported</em> in a Client Component file must be Client Components as well. When the bundler bundles up our code, it'll follow these imports, after all!</p>
<blockquote>
<p><strong>Changing the color theme?</strong></p>
<p>In my example above, you might have noticed that there's no way to change the color theme. <code>setColorTheme</code> is never called.</p>
<p>I wanted to keep things as minimal as possible, and so I left some stuff out. A full example would use React context to make the setter function available to any descendants. As long as the component that consumes the context is a Client Component, everything works great!</p>
</blockquote>
<h2 id="peeking-under-the-hood"><a href="https://www.joshwcomeau.com/react/server-components/#peeking-under-the-hood-8">Peeking under the hood</a><a aria-hidden="true" class="anchor-heading icon-link" href="#peeking-under-the-hood"></a></h2>
<p>Let's look at this at a bit of a lower level. When we use a Server Component, what does the output look like? What actually gets generated?</p>
<p>Let's start with a super-simple React application:</p>
<pre class="language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Homepage</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>p</span><span class="token punctuation">></span></span><span class="token plain-text">Hello world!</span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>p</span><span class="token punctuation">></span></span>
<span class="token punctuation">}</span>
</code></pre>
<p>In the React Server Components paradigm, all components are Server Components by default. Since we haven't explicitly marked this component as a Client Component (or rendered it within a client boundary), it'll only render on the server.</p>
<p>When we visit this app in the browser, we'll receive an HTML document which looks something like this:</p>
<pre class="language-html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&#x3C;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>html</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>p</span><span class="token punctuation">></span></span>Hello world!<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>p</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/static/js/bundle.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">
      self<span class="token punctuation">.</span><span class="token property-access">__next</span><span class="token punctuation">[</span><span class="token string">"$Homepage-1"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
        type<span class="token operator">:</span> <span class="token string">"p"</span><span class="token punctuation">,</span>
        props<span class="token operator">:</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span>
        children<span class="token operator">:</span> <span class="token string">"Hello world!"</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>html</span><span class="token punctuation">></span></span>
</code></pre>
<blockquote>
<p><strong>Some liberties taken</strong></p>
<p>To make it easier to understand, I've taken the liberty of restructuring things here. For example, the true JS generated in an RSC context uses stringified JSON arrays, as an optimization to reduce the file size of this HTML document.</p>
<p>I've also stripped out all non-critical parts of the HTML (like the <code>&#x3C;head></code>).</p>
</blockquote>
<p>We see that our HTML document includes the UI generated by our React application, the “Hello world!” paragraph. This is thanks to Server Side Rendering, and isn't directly attributable to React Server Components.</p>
<p>Below that, we have a <code>&#x3C;script></code> tag that loads up our JS bundle. This bundle includes the dependencies like React, as well as any Client Components used in our application. And since our <code>Homepage</code> component is a Server Component, the code for that component is <em>not</em> included in this bundle.</p>
<p>Finally, we have a second <code>&#x3C;script></code> tag with some inline JS:</p>
<pre class="language-js"><code class="language-js">self<span class="token punctuation">.</span><span class="token property-access">__next</span><span class="token punctuation">[</span><span class="token string">"$Homepage-1"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token string">"p"</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token keyword null nil">null</span><span class="token punctuation">,</span>
  children<span class="token operator">:</span> <span class="token string">"Hello world!"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre>
<p>This is the really interesting bit. Essentially, what we're doing here is telling React “Hey, so I know you're missing the <code>Homepage</code> component code, but don't worry: here's what it rendered”.</p>
<p>Typically, when React hydrates on the client, it speed-renders all of the components, building up a virtual representation of the application. It can't do that for Server Components, because the code isn't included in the JS bundle.</p>
<p>And so, we send along the rendered value, the virtual representation that was generated by the server. When React loads on the client, it re-uses that description instead of re-generating it.</p>
<p>This is what allows that <code>ColorProvider</code> example above to work. The output from <code>Header</code> and <code>MainContent</code> is passed into the <code>ColorProvider</code> component through the <code>children</code> prop. <code>ColorProvider</code> can re-render as much as it wants, but this data is static, locked in by the server.</p>
<p>If you're curious to see <em>true</em> representations of how Server Components are serialized and sent over the network, check out the <a href="https://www.alvar.dev/blog/creating-devtools-for-react-server-components">RSC Devtools</a> by developer Alvar Lagerlöf.</p>
<blockquote>
<p><strong>Server Components don't require a server</strong></p>
<p>Earlier in this post, I mentioned that Server Side Rendering is an “umbrella term” for lots of different rendering strategies, including:</p>
<ul>
<li>Static: the HTML is generated when the application is built, during the deploy process.</li>
<li>Dynamic: the HTML is generated “on-demand”, when the page is requested by the user.</li>
</ul>
<p><strong>React Server Components is compatible with either of these rendering strategies.</strong> When our Server Components are rendered in the Node.js runtime, the JavaScript objects they return will be created. That can happen either on-demand or during the build.</p>
<p>This means that it's possible to use React Server Components without a server! We can generate a bunch of static HTML files and host them wherever we want. In fact, this is what happens <em>by default</em> in the Next.js App Router. Unless we really need things to happen “on-demand”, all of this work happens ahead of time, during the build.</p>
</blockquote>
<blockquote>
<p><strong>No React at all?</strong></p>
<p>You might be wondering: if we don't include any Client Components in our application, do we actually need to download React at all? Can we use React Server Components to build a <em>truly</em> static no-JS website?</p>
<p>The thing is, React Server Components is available exclusively within the Next.js framework, and that framework has a bunch of code that needs to run on the client, to manage things like routing.</p>
<p>Counter-intuitively, though, this actually tends to produce a <em>better</em> user experience; Next's router, for example, will process link clicks <em>faster</em> than a typical <code>&#x3C;a></code> tag, since it doesn't have to load a whole new HTML document.</p>
<p>A well-structured Next.js application will still work while the JS is downloading, but it'll be even faster/better once the JS loads.</p>
</blockquote>
<h2 id="advantages"><a href="https://www.joshwcomeau.com/react/server-components/#advantages-9">Advantages</a><a aria-hidden="true" class="anchor-heading icon-link" href="#advantages"></a></h2>
<p>React Server Components is the first “official” way to run server-exclusive code in React. As I mentioned earlier, though, this isn't <em>really</em> a new thing in the broader React ecosystem; we've been able to run server-exclusive code in Next.js since 2016!</p>
<p>The big difference is that we've never before had a way to run server-exclusive code <em>inside our components.</em></p>
<p>The most obvious benefit is performance. Server Components don't get included in our JS bundles, which reduces the amount of JavaScript that needs to be downloaded, and the number of components that need to be hydrated:</p>
<blockquote>
<p>chart of Legacy Next.js (pre-RSC) and Modern Next.js (with RSC)</p>
</blockquote>
<p>This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item.</p>
<ol>
<li>"Database Query" on server. Duration: 5 units of time.</li>
<li>"Render App" on server. Duration: 6 units of time.</li>
<li>Response from server. Duration: 4 units of time.</li>
<li>"Download JavaScript" on client. Duration: 7 units of time.</li>
<li>"Hydrate" on client. Duration: 3 units of time.</li>
</ol>
<p>This is maybe the least exciting thing to me, though. Honestly, most Next.js apps are <em>already</em> fast enough when it comes to “Page Interactive” timing.</p>
<p>If you follow semantic HTML principles, most of your app should work even before React has hydrated. Links can be followed, forms can be submitted, accordions can be expanded and collapsed (using <code>&#x3C;details></code> and <code>&#x3C;summary></code>). For most projects, it's fine if it takes a few seconds for React to hydrate.</p>
<p><strong>But here's something I find really cool:</strong> we no longer have to make the same compromises, in terms of features vs. bundle size!</p>
<p>For example, most technical blogs require some sort of syntax highlighting library. On this blog, I use Prism. The code snippets look like this:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">exampleJavaScriptFunction</span><span class="token punctuation">(</span><span class="token parameter">param</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword control-flow">return</span> <span class="token string">"Hello world!"</span>
<span class="token punctuation">}</span>
</code></pre>
<p>A proper syntax-highlighting library, with support for all popular programming languages, would be several megabytes, far too large to stick in a JS bundle. As a result, we have to make compromises, trimming out languages and features that aren't mission-critical.</p>
<p>But, suppose we do the syntax highlighting <em>in a Server Component.</em> In that case, none of the library code would actually be included in our JS bundles. As a result, we wouldn't have to make any compromises, we could use all of the bells and whistles.</p>
<p>This is the big idea behind <a href="https://bright.codehike.org/">Bright</a>, a modern syntax-highlighting package designed to work with React Server Components.</p>
<p><a href="/images/server-components/bright.png">image of React server component for syntax highlighting</a></p>
<p>This is the sort of thing that gets me excited about React Server Components. Things that would be too cost-prohibitive to include in a JS bundle can now run on the server <em>for free,</em> adding zero kilobytes to our bundles, and producing an even better user experience.</p>
<p>It's not just about performance and UX either. After working with RSC for a while, I've come to really appreciate how easy-breezy Server Components are. We never have to worry about dependency arrays, stale closures, memoization, or any of the other complex stuff caused by <em>things changing.</em></p>
<p>Ultimately, it's still very early days. React Server Components only emerged from beta a couple of months ago! I'm really excited to see how things evolve over the next couple of years, as the community continues to innovate new solutions like Bright, taking advantage of this new paradigm. It's an exciting time to be a React developer!</p>
<h2 id="the-full-picture"><a href="https://www.joshwcomeau.com/react/server-components/#the-full-picture-10">The full picture</a><a aria-hidden="true" class="anchor-heading icon-link" href="#the-full-picture"></a></h2>
<p>React Server Components is an exciting development, but it's actually only one part of the “Modern React” puzzle.</p>
<p>Things get <em>really</em> interesting when we combine React Server Components with Suspense and the new Streaming SSR architecture. It allows us to do <em>wild</em> stuff like this:</p>
<blockquote>
<p>chart</p>
</blockquote>
<p>This is a data visualization which shows a sequence of events between client and server. Each event is represented here as a list item.</p>
<ol>
<li>"Render Shell" on server. Duration: 3 units of time.</li>
<li>Response from server. Duration: 3 units of time.</li>
<li>"Database Query" on server. Duration: 8 units of time.</li>
<li>"Render Content" on server. Duration: 3 units of time.</li>
<li>Response from server. Duration: 4 units of time.</li>
<li>"Download JS" on client. Duration: 5 units of time.</li>
<li>"Hydrate" on client. Duration: 2 units of time.</li>
<li>"Hydrate" on client. Duration: 2 units of time.</li>
</ol>
<p>It's beyond the scope of this tutorial, but you can learn more about this architecture <a href="https://github.com/reactwg/react-18/discussions/37">on Github</a>.</p>
<p>It's also something we explore in depth in my brand-new course, <a href="https://joyofreact.com/">The Joy of React</a>. I'd love to tell you a little bit more about it, if that's alright! ❤️</p>
<p>The Joy of React is a beginner-friendly interactive course, designed to help you build an intuition for how React works. We start at the very beginning (no prior React experience required), and work our way through some of the most notoriously-tricky aspects of React.</p>
<p>This course has been my full-time focus for almost two years now, and it includes all of the most important stuff I've learned about React in over 8 years of experience.</p>
<p>There's so much good stuff I'd love to tell you about. In addition to React itself, and all the bleeding-edge stuff we've alluded to in this blog post, you'll learn about my favourite parts of the React ecosystem. For example, you'll learn how to do next-level layout animations like this, using Framer Motion:</p>
<p>You can learn more about the course, and discover the joy of building with React:</p>
<ul>
<li><a href="https://joyofreact.com/">The Joy of React</a></li>
</ul>
<hr>
<p>React Server Components is a significant paradigm shift. Personally, I'm <em>super</em> keen to see how things develop over the next couple of years, as the ecosystem builds more tools like Bright that takes advantage of Server Components.</p>
<p>I have the feeling that building in React is about to get even cooler. 😄</p>