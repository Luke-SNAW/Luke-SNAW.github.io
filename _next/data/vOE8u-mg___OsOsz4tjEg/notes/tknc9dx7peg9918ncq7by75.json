{"pageProps":{"note":{"id":"tknc9dx7peg9918ncq7by75","title":"LiveView is best with Svelte","desc":"","updated":1712213318441,"created":1712213040611,"custom":{},"fname":"javascript.tools.liveview-is-best-with-svelte","type":"note","vault":{"fsPath":"vault"},"contentHash":"b6113131b5487089b9019d4f9df8d3a7","links":[],"anchors":{"what-is-liveview":{"type":"header","text":"What is LiveView","value":"what-is-liveview","line":26,"column":0,"depth":2},"where-liveview-makes-easy-things-hard":{"type":"header","text":"Where LiveView makes easy things hard","value":"where-liveview-makes-easy-things-hard","line":55,"column":0,"depth":2},"client-side-state-is-inevitable":{"type":"header","text":"Client-side state is inevitable","value":"client-side-state-is-inevitable","line":61,"column":0,"depth":3},"three-components":{"type":"header","text":"Three components","value":"three-components","line":94,"column":0,"depth":3},"the-elusive-liveview-way":{"type":"header","text":"The elusive “LiveView way”","value":"the-elusive-liveview-way","line":123,"column":0,"depth":2},"liveview--svelte":{"type":"header","text":"LiveView + Svelte","value":"liveview--svelte","line":135,"column":0,"depth":2},"q":{"type":"header","text":"Q","value":"q","line":281,"column":0,"depth":2},"a":{"type":"header","text":"A","value":"a","line":285,"column":0,"depth":3}},"children":[],"parent":"vsuy3iuvjqng2jewf82nxoq","data":{}},"body":"<h1 id=\"liveview-is-best-with-svelte\">LiveView is best with Svelte<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#liveview-is-best-with-svelte\"></a></h1>\n<blockquote>\n<p><a href=\"https://blog.sequin.io/liveview-is-best-with-svelte/\">https://blog.sequin.io/liveview-is-best-with-svelte/</a></p>\n<p>LiveView is a unique approach to building web applications that combines the benefits of server-rendered and client-side frameworks. While LiveView offers many advantages, the authors found some limitations around handling complex client-side interactions and the blurry line between client and server state. To address these challenges, the authors describe using LiveView together with the Svelte frontend framework, which they found to be a powerful and productive combination. The LiveView backend handles data fetching, validation, and state management, while the Svelte frontend focuses on rendering and simple event handling. This \"LiveSvelte\" approach eliminates the need for a separate frontend microservice and allows for a clean separation of concerns between the client and server.</p>\n<blockquote>\n<p>One possible solution which I didn't investigate, but should work, is to write all game logic in gleam (<a href=\"https://gleam.run/\">https://gleam.run/</a>). Gleam is compatible with Elixir, AND it also can compile to js, so you could in theory run the same code on the server and the client. — <a href=\"https://news.ycombinator.com/item?id=39919223\">POiNTx</a></p>\n</blockquote>\n</blockquote>\n<p>Phoenix's <a href=\"https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html\">LiveView</a> has polarized our team. Compared to SPA, there are components and features that we’re able to build 2-3x faster. Conversely, there are components and features that are frustrating to build or feel very counterintuitive.</p>\n<p>Said another way, LiveView makes a lot of things easy. But it also makes some easy things hard.</p>\n<p>This created tension. Do we keep forging down this path? Or do we give in and convert our app to a SPA?</p>\n<p>Fortunately, we found a companion library called <a href=\"https://github.com/woutdp/live_svelte\">LiveSvelte</a>. LiveView enables a development experience with Svelte that’s unlike any other fullstack paradigm I’ve used.</p>\n<p>The team agrees: this is a killer way to build.</p>\n<p>To appreciate the LiveView+Svelte paradigm, I’ll start by explaining how LiveView works and what makes it different. Then, I’ll detail the friction we encountered with a pure LiveView approach. At that point, you’ll be able to appreciate what LiveSvelte offers.</p>\n<h2 id=\"what-is-liveview\">What is LiveView<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#what-is-liveview\"></a></h2>\n<p>LiveView offers a very unique way to build web applications.</p>\n<p>In a traditional server-rendered web application, the server is stateless. The client requests a page and the server renders it. All client actions route back to the server, which re-renders the next page.</p>\n<p>In a SPA, the client is in charge of building pages. It leverages a backend API to read and write data. Client apps are stateful (e.g. <code>useState</code> in React).</p>\n<p>In LiveView, the server is in charge of rendering the page. But it’s stateful. Actions in the frontend are handled by the backend, but the server <em>incrementally</em> updates the DOM, much like in a SPA.</p>\n<p>At a high-level, the reason a SPA is complex is because distributed systems are complex. Supporting a client JS app is supporting a microservice (and one that runs in a hostile, untrusted environment, no less!)</p>\n<p>In <em>theory</em> your frontend app uses a backend REST API that <em>could</em> be used to support lots of different services and clients. In reality, the needs of your frontend app are unique. So your backend routes and controllers explode with functions that serve the needs of a single client.</p>\n<p>If nothing else, this complexity just means shaving a lot of yaks. Each request requires a fair bit of plumbing on both the frontend and the backend. Callstacks can easily exceed half a dozen layers:</p>\n<ul>\n<li><code>onMount</code></li>\n<li><code>await api.fetchUsers</code></li>\n<li><code>parseResponse</code></li>\n<li><code>Router.handle(/api/users)</code></li>\n<li><code>AuthPlug.verify_cookie</code></li>\n<li><code>UsersController.index</code></li>\n<li><code>Users.list_for_org</code></li>\n<li><code>ApiHelpers.prepare_response</code></li>\n</ul>\n<p>The promise of LiveView is that you get to create rich client-side experiences without the frontend microservice. You're back to the much simpler world where you can query the database in the function adjacent to the function that renders your table rows. If a new row comes in, you just need to push it to your table, and LiveView will update the client for you.</p>\n<p>But in addition, you also get to enjoy building an app using the stateful paradigm of frontend frameworks. It's much easier and faster to build rich interaction patterns this way vs prior backend paradigms where you'd need to \"rebuild the world\" on each request.</p>\n<h2 id=\"where-liveview-makes-easy-things-hard\">Where LiveView makes easy things hard<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#where-liveview-makes-easy-things-hard\"></a></h2>\n<p>There's a lot of good stuff in LiveView. But there are also real thorns.</p>\n<p>There are two primary areas that we struggled with LiveView:</p>\n<h3 id=\"client-side-state-is-inevitable\">Client-side state is inevitable<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#client-side-state-is-inevitable\"></a></h3>\n<p>There is a (literal) speed of light limitation with this approach: your server can only be <em>so close</em> to your users.</p>\n<p>Invariably, you’re going to need to do some stuff client-side. Animations, tooltips, showing/hiding DOM elements, disabling form fields, etc.</p>\n<p>For example, there’s a form in our app with two interdependent dropdowns. Selecting an option in the first dropdown allows our server to generate the list for the second dropdown. To get the best UX, you want to disable the second dropdown immediately after the first dropdown changes. Then, when it’s repopulated by the server, you can re-enable it:</p>\n<p><a href=\"https://blog.sequin.io/content/images/2024/03/CleanShot-2024-03-28-at-10.58.11-1.gif\">Two dropdowns, the second is disabled after the first changes</a></p>\n<p><em>Simulating 1000ms of roundtrip latency between the client and the server.</em></p>\n<p>To pull this off, as far as we could tell, you need to use two independent concepts in LiveView:</p>\n<ul>\n<li>Use the <a href=\"https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html\">JS module</a> to disable the second dropdown when the first dropdown changes.</li>\n<li>Use a <a href=\"https://hexdocs.pm/phoenix_live_view/js-interop.html#client-hooks-via-phx-hook\">hook</a> to register an event listener on the second dropdown. Then, send an action to re-enable the second dropdown from the backend.</li>\n</ul>\n<p>And for slightly more complex interaction patterns, you’ll need to incorporate a <em>third</em> concept, LiveView state. For example, maybe you only want to re-enable the second dropdown in certain conditions.</p>\n<p>The way these three concepts fit together is not obvious (we’re still not sure this is the right pattern!)</p>\n<p>So, while the server is in charge of a lot of DOM changes, it can’t command all of them. You use JS and hooks to sprinkle in JavaScript where needed. These tools feel side-chained to core LiveView, and therefore their patterns of use are not obvious. And the more JS and hooks you use, the more of your DOM state now exists <em>outside</em> of LiveView.</p>\n<p>This is a stark contrast to a paradigm like React. In React, it’s state and actions all the way down. With that core concept, you can do most anything. And there is no blurry line between DOM state and component state.</p>\n<p>React can take that approach because there’s no latency between client-side actions and client-side state. This means you can let React’s state paradigm handle every action and transition. Because all of LiveView’s state is server-side, it has to contend with the latency between client-side actions and server-side state. This means that while LiveView state <em>looks like</em> other frontend frameworks, the model is actually quite different.</p>\n<p>Take input fields, for example. In React, a character can’t be inserted into an input field without routing through state. This unlocks a powerful programming model, where your component re-renders – and therefore responds – to every keystroke. It gives the state and action paradigm a lot of reach, where you can use one core concept (<code>useState</code>) to solve a huge space of problems.</p>\n<p>In LiveView, it’s more accurate to say that the input field is changed by the user, <em>and then</em> a short while later LiveView finds out about it and reacts to it. With no latency, <em>it looks a lot like React</em>. But with increased latency, it’s quite a different paradigm.</p>\n<p>In frontend frameworks like React, you need to contend with server-side latency all the time. But <em>when</em> a high-latency action is going to take place is clear (i.e. you’re fetching from a server). In LiveView, the boundary is murkier.</p>\n<h3 id=\"three-components\">Three components<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#three-components\"></a></h3>\n<p>LiveView has three different types of components: LiveViews, LiveComponents, and Components.</p>\n<p>LiveViews and LiveComponents are like stateful components in React, whereas Components are like functional components.</p>\n<p>Importantly, a LiveView will always be the uppermost parent component. You render LiveComponents and Components as children underneath a LiveView.</p>\n<p>In React, it's easy to switch between stateful and functional components–just add or remove <code>useState</code> hooks. The API for both are the same (they both accept props in the same way). And outside state, they have an identical feature set. For example, they can both register and respond to DOM events in the same way.</p>\n<p>The ease of switching between component types is important. As an app matures, you’re constantly factoring out components. You’re figuring out which bits should be reused, what should be generalized, where state should live, etc.</p>\n<p>In LiveView, all three components are very different. As a result, refactoring a LiveView into a LiveComponent is surprisingly cumbersome.</p>\n<p>In particular:</p>\n<ul>\n<li>The syntax for rendering and passing props to LiveViews and LiveComponents is different.</li>\n<li>The lifecycle of LiveViews and LiveComponents are different.</li>\n<li>The <a href=\"https://hexdocs.pm/phoenix_live_view/Phoenix.LiveComponent.html#module-unifying-liveview-and-livecomponent-communication\">communication options</a> between LiveViews and LiveComponents are different. For example, you <code>send</code> to LiveViews but <code>send_update</code> to LiveComponents.</li>\n<li>LiveComponents are not processes, and so can't interact with the rest of the system like LiveViews can.</li>\n</ul>\n<p>That last point is what makes LiveComponents so different and so frustrating. The limitations <em>make sense</em>: A LiveView is a process. That's one of the best parts about a LiveView, they're \"just processes\" and so they can fit into your Elixir/OTP system like every other process. For example, you can use pub/sub in a LiveView to subscribe to system-wide changes.</p>\n<p>A LiveComponent is <em>not</em> its own process, they are modules invoked by a LiveView. The parent LiveView process holds the state for all subcomponents. So, a LiveView has a <code>pid</code>, state, and an inbox; a LiveComponent does not. This means the LiveView also has to handle all message routing for its child LiveComponents.</p>\n<p>This is in keeping with Elixir/OTP design principles: processes are the building blocks. To give LiveComponents the same powers of independent state management and action handling, they would each need to be their own process.</p>\n<p>Still, for the life of me, I <em>really</em> struggled with LiveComponents. So often, I wanted to send my LiveComponent an event/action but didn't have a good way to do it. You end up using <code>send_update</code>, which is an awkward API. We couldn't decide: do we send <em>actions</em> via <code>send_update</code>, or do we use it to patch state? If we use it to patch state, how do we tell in our <code>update</code> clause whether we're mounting or updating?</p>\n<h2 id=\"the-elusive-liveview-way\">The elusive “LiveView way”<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-elusive-liveview-way\"></a></h2>\n<p>LiveView often made us feel like we were “missing something.” The “LiveView way” feels elusive.</p>\n<p>Perhaps LiveView is in an uncanny valley. It shares a lot in common with contemporary frontend frameworks. So, our “React brains” and intuitions would kick in, driving us to use old patterns–but those would often lead to a dead end. More alienness would have forced us to recognize the differences and to approach problems differently.</p>\n<p>You can do a lot with just LiveView state and actions. But there are limits, and when you hit them you need to switch paradigms.</p>\n<p>It has components to help you organize and reuse code. But due to differences between JavaScript and Elixir, LiveView can’t really offer the same isomorphic component trees without a ton of abstraction, and so has LiveViews and LiveComponents.</p>\n<p><strong>This is what makes LiveSvelte so promising</strong>. As you’ll see, it shifts more responsibility to the frontend. It embraces the fact that the frontend will have its own state. And it lets you take advantage of all the maturity of contemporary JavaScript component frameworks.</p>\n<h2 id=\"liveview--svelte\">LiveView + Svelte<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#liveview--svelte\"></a></h2>\n<p>LiveSvelte lets you render Svelte components from LiveView. It's an awesome paradigm.</p>\n<p>There’s a couple different ways to render Svelte from your LiveViews, but the most basic way looks like this:</p>\n<pre class=\"language-elixir\"><code class=\"language-elixir\"><span class=\"token comment\"># LiveView component</span>\n<span class=\"token keyword\">defmodule</span> <span class=\"token module class-name\">Web</span><span class=\"token punctuation\">.</span><span class=\"token module class-name\">SyncLive</span><span class=\"token punctuation\">.</span><span class=\"token module class-name\">Form</span> <span class=\"token keyword\">do</span>\n  <span class=\"token keyword\">def</span> <span class=\"token function\">render</span><span class=\"token punctuation\">(</span>assigns<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n    assigns <span class=\"token operator\">=</span>\n      assigns\n      <span class=\"token operator\">|></span> <span class=\"token module class-name\">Map</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token atom symbol\">:encoded_collections</span><span class=\"token punctuation\">,</span> <span class=\"token module class-name\">Enum</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>assigns<span class=\"token punctuation\">.</span>collections<span class=\"token punctuation\">,</span> <span class=\"token operator\">&#x26;</span><span class=\"token function\">encode_collection</span><span class=\"token operator\">/</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token operator\">|></span> <span class=\"token module class-name\">Map</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token atom symbol\">:encoded_errors</span><span class=\"token punctuation\">,</span> <span class=\"token function\">encode_errors</span><span class=\"token punctuation\">(</span>assigns<span class=\"token punctuation\">.</span>changeset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    ~<span class=\"token module class-name\">H</span><span class=\"token string\">\"\"\"\n      &#x3C;.svelte\n        name=\"MyForm\"\n        props={\n          %{\n            collections: @encoded_collections,\n            credential_options: @credential_options,\n            errors: @encoded_errors,\n          }\n        }\n        socket={@socket}\n      />\n    \"\"\"</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n</code></pre>\n<p>This is an Elixir module, the LiveView. Inside the render, we first take our Elixir data structures and encode them for the frontend. We like the pattern of explicitly encoding Elixir structs and such as plain maps before passing to Svelte, like this:</p>\n<pre class=\"language-elixir\"><code class=\"language-elixir\">  <span class=\"token keyword\">defp</span> <span class=\"token function\">encode_collection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">%</span><span class=\"token module class-name\">Collection</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> collection<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">%</span><span class=\"token punctuation\">{</span>\n      <span class=\"token string\">\"id\"</span> <span class=\"token operator\">=></span> collection<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">,</span>\n      <span class=\"token string\">\"slug\"</span> <span class=\"token operator\">=></span> collection<span class=\"token punctuation\">.</span>slug<span class=\"token punctuation\">,</span>\n      <span class=\"token string\">\"name\"</span> <span class=\"token operator\">=></span> collection<span class=\"token punctuation\">.</span>name\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">end</span>\n</code></pre>\n<p>We’re able to set props on the Svelte component. Those are passed down as you’d expect to the component:</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Svelte component</span>\n<span class=\"token operator\">&#x3C;</span>script<span class=\"token operator\">></span>\n  <span class=\"token keyword module\">export</span> <span class=\"token keyword\">let</span> resource<span class=\"token punctuation\">;</span> <span class=\"token keyword module\">export</span> <span class=\"token keyword\">let</span> credential_options <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword module\">export</span> <span class=\"token keyword\">let</span> errors <span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword module\">export</span> <span class=\"token keyword\">let</span> live<span class=\"token punctuation\">;</span>\n<span class=\"token operator\">&#x3C;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n</code></pre>\n<p>One of the props that LiveSvelte sets for us is the <code>live</code> prop. To communicate from the Svelte component back up to the LiveView, we can call <code>live.pushEvent</code>. For example, check how easy it is to send the server changes to the form:</p>\n<pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&#x3C;</span>script<span class=\"token operator\">></span>\n  <span class=\"token comment\">// ...</span>\n  $<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    live<span class=\"token punctuation\">.</span><span class=\"token method function property-access\">pushEvent</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"form_updated\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> form <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token arrow operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token operator\">&#x3C;</span><span class=\"token operator\">/</span>script<span class=\"token operator\">></span>\n</code></pre>\n<p>This is a reactive block in Svelte. It will be executed whenever the variable <code>form</code> is changed. (Kind of like a <code>useEffect</code>, where <code>form</code> is the dependency.)</p>\n<p>The LiveView can handle and respond to the <code>pushEvent</code> using typical Elixir message handling semantics:</p>\n<pre class=\"language-elixir\"><code class=\"language-elixir\"><span class=\"token comment\"># In the LiveView</span>\n<span class=\"token comment\"># ...</span>\n  <span class=\"token attribute variable\">@impl</span> <span class=\"token module class-name\">LiveView</span>\n  <span class=\"token keyword\">def</span> <span class=\"token function\">handle_event</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"form_updated\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">%</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"form\"</span> <span class=\"token operator\">=></span> form<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> socket<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n    params <span class=\"token operator\">=</span> <span class=\"token function\">decode_params</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">,</span> form<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">{</span><span class=\"token atom symbol\">:noreply</span><span class=\"token punctuation\">,</span> <span class=\"token function\">merge_changeset</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">defp</span> <span class=\"token function\">merge_changeset</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">)</span> <span class=\"token keyword\">do</span>\n    changeset <span class=\"token operator\">=</span> <span class=\"token module class-name\">Collection</span><span class=\"token punctuation\">.</span><span class=\"token function\">create_changeset</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">.</span>assigns<span class=\"token punctuation\">.</span>resource<span class=\"token punctuation\">,</span> params<span class=\"token punctuation\">)</span>\n\n    <span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">,</span> <span class=\"token atom symbol\">:changeset</span><span class=\"token punctuation\">,</span> changeset<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n</code></pre>\n<p>We first decode the params from the frontend, reversing any encoding/mapping we did on the way out. Then, <code>merge_changeset/2</code> updates our changeset. If there are any validation errors in the changeset, those will make their way back to the frontend via the <code>errors</code> prop.</p>\n<p>So, you have data flow from Elixir down to the component via props. The LiveView process can update props at any time to cause the Svelte component to re-render. Any other communication can happen via the websocket.</p>\n<p>The boundary between the two is very clear–just as clear as in any SPA.</p>\n<p>What's most game-changing, though, is that you have a <em>backend, stateful process</em> that is collaborating with a <em>frontend, stateful process</em>.</p>\n<p>And it's <em>so</em> fun and productive.</p>\n<p>The three powerhouse properties:</p>\n<ol>\n<li>The backend controls the props on the frontend component.</li>\n<li>The frontend <em>and</em> the backend are stateful.</li>\n<li>You have a private, bi-directional communication channel between the two <em>where either side can initiate a message to the other</em>.</li>\n</ol>\n<p>#1 is made possible thanks to LiveView’s rendering paradigm: re-renders on the server are automatically pushed and applied to the client. This lets the server update props on the component just like a JS parent component can!</p>\n<p>#2 is possible because a LiveView is a process. Processes are how Elixir encapsulates and reduces state.</p>\n<p>#3 is made possible by the persistent websocket that LiveView gives you, wired to the frontend.</p>\n<p>Consider the differences between this paradigm and a SPA:</p>\n<p>First, all browser routing happens via the backend. This is a great simplifier. (In a regular SPA you have to maintain <em>two</em> sets of routes, one for the browser and one for your API.)</p>\n<p>Second, the backend is stateful. It knows what route you’re on. Which resource you’re working with. Each action it handles can be far more incremental, as it’s applying a state change to itself vs rebuilding state from scratch.</p>\n<p>Third, communication between the frontend and backend is private and coupled, as it should be. You’re not “polluting” your server’s public routes with a bunch of RPC calls that support a single component. When you see a <code>pushEvent</code> in the client, you know exactly where the handler for that is – in the collaborating Elixir module.</p>\n<p>Fourth, functionality is split across just two files. Sure, the backend module will call out to your backend functions (e.g. fetch data from database) and the frontend will import components and styles. But roundtrips between the two aren’t routing through a stack of API modules, routers, and controllers.</p>\n<p>Fifth, communication between frontend and backend is far less ceremonious. The backend can simply update props to inform frontend changes. And the frontend can <code>pushEvent</code> without needing handlers for expired tokens, timeouts, or outages. It’s binary: either the websocket is open which means the server is open for business, or it’s not in which case LiveView helpfully shows the user a global “disconnected” banner.</p>\n<p>In the simplest terms, the frontend microservice is eliminated.</p>\n<p>What you end up with feels like such a great split of responsibilities with very little boilerplate. All your business logic is on the backend – how you load data, <em>which</em> data to load, how to sort and filter the data, your validators, etc. Your frontend code is stupid simple. In Svelte, it’s all (1) <code>if/end</code> blocks to conditionally render stuff (2) animations and (3) a few dead simple <code>pushEvent</code> functions back to the server.</p>\n<p>That last part has been blowing my mind. The typical SPA frontend is full of so much logic, usually <code>map</code>, <code>reduce</code>, and <code>filter</code> in order to process server data, prepare data for display, or prepare data for the server. In a LiveSvelte app, all this can just happen server-side. The LiveView can prepare data exactly as the Svelte component needs it. This keeps complexity in your server language, in your server's data structures, and in your server's test suite.</p>\n<p>The backend LiveView and the frontend Svelte component aren't so much coupled as they are two halves: the LiveView only renders that Svelte component, and that Svelte component is only ever rendered by that LiveView.</p>\n<p>In contrast to a “regular” LiveView, this paradigm:</p>\n<ul>\n<li>Embraces state and state transitions in the frontend.</li>\n<li>Creates a clear boundary layer between the frontend and backend.</li>\n<li>Leverages Svelte’s component paradigm, which like other contemporary JS frameworks is very mature and familiar.</li>\n<li>In general, lets great frontend frameworks do what they do best! A pure LiveView approach doesn’t let you tap into this huge ecosystem. (For example, Svelte comes with great animation primitives.)</li>\n</ul>\n<p>By moving more into the frontend, we no longer felt like we were straddling an awkward middleground.</p>\n<p>We chose LiveSvelte because React didn't have a similarly complete LiveView library. The joy of working with Svelte has been a very happy bonus. Because LiveView does the heavy lifting with state management, our state management in Svelte is very simple. For basic state and reactivity, Svelte is the lightest and fastest frontend framework I've worked with. We also prefer its templating features to React's, namely getting to use <code>if/else</code> instead of ternary operators and its conditional property setting.</p>\n<p>Further, Svelte 5 is around the corner, and we're bullish on its <a href=\"https://svelte.dev/blog/runes\">runes</a>. We think it makes Svelte even easier to pick up and reason about, meaning everyone on the team is empowered to traverse the stack.</p>\n<p>I’m now convinced LiveView shines brightest as a backend-for-frontend. By rendering frontend components, incrementally updating them, maintaining a stateful backend process, and providing a websocket API, it creates a tremendously productive platform for frontend applications.</p>\n<p>If you’re using LiveView and resonated with any of the friction I highlighted, you need to give this a try. If you’ve never used LiveView, you’ll find that this paradigm <em>lowers</em> the learning curve. This is because you’re able to use a lot of the JavaScript framework primitives you’re used to.</p>\n<hr>\n<h2 id=\"q\">Q<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#q\"></a></h2>\n<p><a href=\"https://news.ycombinator.com/item?id=39917878\">So instead of managing state on the client, you manage state on the client and the server? That doesn't seem like an improvement, even if it saves you from having to build yet another API.</a></p>\n<h3 id=\"a\">A<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#a\"></a></h3>\n<blockquote>\n<p><a href=\"https://news.ycombinator.com/item?id=39918962\">https://news.ycombinator.com/item?id=39918962</a></p>\n</blockquote>\n<p>It's never that simple. In web applications there's always these types of states:</p>\n<pre><code>    * States that the client needs to keep track of\n    * States that the server needs to keep track of\n</code></pre>\n<p>Then on top of those there's two more kinds of states that overlap but they're not quite the same thing:</p>\n<pre><code>    * States that only need to exist in memory (i.e. transient)\n    * States that need to persist between sessions\n</code></pre>\n<p>There's a seemingly infinite number of ways to manage these things and because \"there's no correct way to do anything in JavaScript\" you either use a framework's chosen way to deal with them or you do it on an ad-hoc basis (aka \"chaos\" haha).</p>\n<p>In the last sophisticated SPA I wrote I had it perform a sync whenever the client loaded the page. Every local state or asset had a datetime-based hash associated with it and if it didn't match what was on the server the server would send down an updated version (of whatever that thing was; whether it be simple variables, a huge JSON object, or whole images/audio blobs).</p>\n<p>Whenever the client did something that required a change in state on the server it would send an update of that state over a WebSocket (99% of the app was WebSocket stuff). I didn't use any sort of sophisticated framework or pattern: If I was writing the code and thought, \"the server needs to keep track of this\" I'd have it send a message to the server with the new state and it would be up to the server whether or not that state should be synchronized on page load.</p>\n<p>IMHO, that's about as simple a mechanism as you can get for managing this sort of thing. WebSockets are a godsend for managing state.</p>","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -> 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -> easy fun -> art -> profit?\n\n> I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n> We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n> Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n> [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n>\n> Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n> Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n> A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n> “Motivation often comes after starting, not before. Action produces momentum.”\n> [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n>\n> - James Clear\n\n> Focus is more about **not** keeping busy when you need to wait for something.  \n> Eat the boredom for a minute.\n>\n> - [[life-tips#wodenokoto]]\n\n> [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n>\n> - https://www.ntnu.edu/cerg/advice\n> - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n> [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n>\n> - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n> 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n>\n> 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n>\n> - 막막한 독서. 시로군. P.10~13\n\n> I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n> My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n> Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}