{"pageProps":{"note":{"id":"t302idqloejiq4vv8nu1myj","title":"Comparing TCP and QUIC","desc":"","updated":1667956255230,"created":1667955573804,"custom":{},"fname":"dev.network.quicvtcp","type":"note","vault":{"fsPath":"vault"},"contentHash":"f6f119200e65d4947eb32c5344d21302","links":[],"anchors":{"what-is-tcp":{"type":"header","text":"What is TCP?","value":"what-is-tcp","line":15,"column":0,"depth":3},"tcp-and-tls":{"type":"header","text":"TCP and TLS","value":"tcp-and-tls","line":40,"column":0,"depth":3},"quic":{"type":"header","text":"QUIC","value":"quic","line":48,"column":0,"depth":3},"quic-connections":{"type":"header","text":"QUIC Connections","value":"quic-connections","line":56,"column":0,"depth":4},"quic-connection-handshake":{"type":"header","text":"QUIC Connection Handshake","value":"quic-connection-handshake","line":68,"column":0,"depth":4},"packets-and-frames":{"type":"header","text":"Packets and Frames","value":"packets-and-frames","line":77,"column":0,"depth":4},"quic-streams":{"type":"header","text":"QUIC Streams","value":"quic-streams","line":89,"column":0,"depth":4},"quic-datagrams":{"type":"header","text":"QUIC Datagrams","value":"quic-datagrams","line":101,"column":0,"depth":4},"quic-frames":{"type":"header","text":"QUIC Frames","value":"quic-frames","line":107,"column":0,"depth":4},"quic-recovery-and-flow-control":{"type":"header","text":"QUIC Recovery and Flow Control","value":"quic-recovery-and-flow-control","line":118,"column":0,"depth":4},"quic-issues":{"type":"header","text":"QUIC Issues","value":"quic-issues","line":128,"column":0,"depth":3},"rpc-support":{"type":"header","text":"RPC support","value":"rpc-support","line":130,"column":0,"depth":4},"load-balancing-quic":{"type":"header","text":"Load Balancing QUIC","value":"load-balancing-quic","line":142,"column":0,"depth":4},"ddos-defence":{"type":"header","text":"DDOS Defence","value":"ddos-defence","line":150,"column":0,"depth":4},"private-quic":{"type":"header","text":"Private QUIC","value":"private-quic","line":156,"column":0,"depth":4},"quic-and-openssl":{"type":"header","text":"QUIC and OpenSSL","value":"quic-and-openssl","line":164,"column":0,"depth":4},"conclusions":{"type":"header","text":"Conclusions","value":"conclusions","line":172,"column":0,"depth":3}},"children":[],"parent":"ccs5aj6i8lwdbelhgzr75i5","data":{}},"body":"<h1 id=\"comparing-tcp-and-quic\">Comparing TCP and QUIC<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#comparing-tcp-and-quic\"></a></h1>\n<blockquote>\n<p><a href=\"https://www.potaroo.net/ispcol/2022-11/quicvtcp.html\">https://www.potaroo.net/ispcol/2022-11/quicvtcp.html</a><br>\n<strong>Geoff Huston</strong></p>\n</blockquote>\n<p>There is a common view out there that the QUIC transport protocol (RFC 9000) is just another refinement to the original TCP transport protocol<a id=\"fnref-1\" class=\"fnref\" href=\"#fn-1\">1</a><a id=\"fnref-2\" class=\"fnref\" href=\"#fn-2\">2</a>. I find it hard to agree with this sentiment, and for me QUIC represents a significant shift in the set of transport capabilities available to applications in terms of communication privacy, session control integrity and flexibility. QUIC embodies a different communications model that makes intrinsically useful to many more forms of application behaviours. Oh, yes. It’s also faster than TCP! In my opinion It’s likely that over time QUIC will replace TCP in the public Internet. So, for me QUIC is a lot more than just a few tweaks to TCP. Here we will describe both TCP and QUIC and look at the changes that QUIC has bought to the transport table.</p>\n<p>However, we should first do a brief recap of TCP.</p>\n<h3 id=\"what-is-tcp\">What is TCP?<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#what-is-tcp\"></a></h3>\n<p>TCP is the embodiment of the end-to-end principle in the overall Internet architecture. All the functionality required to take a simple base of datagram delivery and impose upon this model an end-to-end signalling regime that implements reliability, sequencing, adaptive flow control, and streaming is embedded within the TCP protocol.</p>\n<p>TCP is a bilateral full duplex protocol. That means that TCP is a two-party communications protocol that supports both parties simultaneously sending and receiving data within the context of a single TCP connection. Rather than impose a state within the network to support the connection, TCP uses synchronized state between the two end points, and much of the protocol design ensures that each local state transition is communicated to, and acknowledged by, the remote party without any mediation by the network whatsoever.</p>\n<p>TCP is a <em>stream protocol</em>. The stream of data generated by the sender will be seen by the receiver in the precisely the same order as generated by the sender. TCP is a true streaming protocol, and application-level network operations are not transparent. Other transport protocols have explicitly encapsulated each application transaction; for every sender’s <em>write</em>, there must be a matching receiver’s <em>read</em>. In this manner, the application-derived segmentation of the data stream into a logical record structure is preserved across the communication. TCP explicitly does not preserve such an implicit structure of the data, so that there is no explicit pairing between <em>write</em> and <em>read</em> operations within the network protocol. For example, a TCP application may write three data blocks in sequence into the network connection, which may be collected by the remote reader in a single read operation. It is left to the application to mark the stream with its own record boundaries, if such boundaries exist in the data.</p>\n<p>There is a rudimentary level of stream formatting permitted within TCP through the concept of <em>urgent data</em> in which the sender can mark the end of a data segment that the application wants to bring to the attention of the receiver. The TCP data segment that carries the final byte of the urgent data segment can mark this data point, and the TCP receiving process has the responsibility to pass this mark to the receiving application.</p>\n<p>The TCP connection is identified by the hosts at both ends by a 5-tuple of protocol identifier, source IP address, source port, destination IP address, and destination port.</p>\n<p>The setup of a TCP connection requires a three-way handshake, ensuring that both sides of the connection have an unambiguous understanding of the remote side's byte sequence values. The operation of the connection setup is as follows: The local system sends the remote end an initial sequence number to the remote port using a SYN packet. The remote system responds with an ACK of the initial sequence number and the remote end's initial sequence number in a response SYN packet. The local end responds with an ACK of this remote sequence number. These handshake packets are conventionally TCP packets without any data payload. At this point TCP shifts into a reliable data flow control mode of operation. (Figure 1)</p>\n<p><img src=\"/assets/images/quicvtcp-fig1.webp\"><br>\nFigure 1 – TCP 3-way handshake</p>\n<p>TCP is a <em>sliding window</em> protocol. The data stream is a sequence of numbered bytes. The sender retains a copy of all sent but as yet unacknowledged data in a local send buffer. When a receiver receives a data segment whose starting sequence number is the next expected data segment, then it will send an acknowledgement (ACK) back to the sender with the sequence number of the end of the received data segment. This allows the sender to discard the data in the local send buffer all data whose sequence number is less than this received ACK sequence and advance the send window. When the received data is out of order, it will send an acknowledgement (ACK) back to the sender with the sequence number of the last in-order received data. In addition, the ACK message includes the size of the receiver’s available buffer size (receive window). The volume of unacknowledged data must be no larger than this receiver window size. The overall constraint is that at all points in time the sender should ensure that the volume of unacknowledged data in flight in the network is the smaller of the advertised receive window size and the total capacity of the local send buffer.</p>\n<p>TCP is an <em>ACK-clocked</em> flow control protocol, in that within a static lossless mode of operation each received ACK packet indicates that a certain volume of data has been received at the receiver end (and hence has been removed from the network), and this is accompanied by an advertised receive window that then permits the sender to inject the same volume of data into the network as has been removed by the receiver. Hence, the sending rate is governed by the received ACK rate.</p>\n<p>However, TCP is not necessarily aware of the available path capacity of the network and must do so by a control algorithm implemented at the sending end that attempts to establish a dynamic equilibrium between the flow volume of the TCP session and all other concurrent TCP sessions that have path segments in common with this session. The mode of operation of this flow control is not fixed in the TCP specification, and a number of flow control algorithms are in use. Many of these control algorithms use an induced instability in TCP through an approach of slow inflation of the sending window for each received ACK, and a rapid drop of the sending window in response to an indication of packet drop (3 duplicate ACKs). This process of sending rate inflation will stop when the send buffer is full, indicating that the sender cannot store any more sent data and must await ACKs before sending more data (send buffer rate limited). It will also stop sending rate inflation when the network cannot accept any further data in flight as the network’s buffers are already full, so further sent data will cause packet loss, which will be signalled back to the sender by duplicate ACKs.</p>\n<p>This process has a number of outcomes relevant to service quality. Firstly, TCP behaves adaptively, rather than predictively. The flow-control algorithms are intended to increase the data-flow rate to fill all available network path capacity but also quickly back off if the available capacity changes due to network congestion or if a dynamic change occurs in the end-to-end network path that reduces this available capacity. Secondly, a single TCP flow across an otherwise idle network attempts to fill the network path with data, optimizing the flow rate (as long as the send buffer is larger than the network flow capacity). If a second TCP flow opens up across the same path, the two flow-control algorithms will interact so that both flows will stabilize to use approximately half of the available capacity per flow. More generally, TCP attempts to behave fairly, in that when multiple TCP flows are present the TCP algorithm is intended to share the network resource evenly across all active flows. A design tension always exists between the efficiency of network use and enforcing predictable session performance. With TCP, you do not necessarily have predictable throughput but gain a highly utilized and efficient network.</p>\n<h3 id=\"tcp-and-tls\">TCP and TLS<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#tcp-and-tls\"></a></h3>\n<p>Transport layer security (TLS)<a id=\"fnref-3\" class=\"fnref\" href=\"#fn-3\">3</a> is handled as a further layer of indirection. Once the TCP 3-way handshake is complete, the parties then enter a TLS negotiation phase to allow authentication of the remote end of the connection, and to establish a session key that can be used to manage the encryption of the session data.</p>\n<p>TLS commences with an exchange of credentials. In version 1.3 of TLS (the latest version of this protocol) the client sends a <em>client hello</em> message which includes which TLS version the client supports, the cipher suites supported, the name of the service, and a string of random bytes known as the client random. The server responds with a <em>server hello</em> message that contains the server’s public key certificate, the <em>server random</em>, the chosen cipher suite and a digital signature of the hello messages. Both ends now know each other’s random values and the chosen cipher suite, so both can generate a master secret for session encryption. The client sends a <em>finished</em> message to indicate that the secure symmetric session key is ready for use (Figure 2).</p>\n<p>Earlier versions of TLS used additional packets in the hello exchange that increased the time to complete the TLS handshake.</p>\n<h3 id=\"quic\">QUIC<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#quic\"></a></h3>\n<p>We can now move on to QUIC. The QUIC transport protocol<a id=\"fnref-4\" class=\"fnref\" href=\"#fn-4\">4</a> was apparently designed to address several issues with TCP and TLS, and in particular to improve the transport performance for encrypted traffic with faster session setup, and to allow for further evolution of transport mechanisms and explicitly avoid the emerging TCP ossification within the network.</p>\n<p>It is a grossly inaccurate simplification, but at its simplest level QUIC is simply TCP encapsulated and encrypted in a UDP payload. To the external network QUIC has the appearance of a bi-directional UDP packet sequence where the UDP payload is concealed. To the endpoints QUIC can be used as a reliable full duplex data flow protocol. Even at this level, QUIC has a number of advantages over TCP. The first lies in the deliberate concealing of the transport flow control parameters from the network. The practice of deploying network middleware that rewrites TCP flow control values to impair the application’s behaviour is not one that has enjoyed widespread support from the application layer, and hiding these flow control parameters from the network certainly prevents this practice. Secondly, it can allow the shift of responsibility for providing the transport protocol from the platform to the application. There has been a longstanding tension between the application and the platform. Changes to kernel-level TCP are performed via updates to the platform software, and often applications have to wait for the platform to make changes before they can take advantage of the change. For example, if an application wanted to use the TCP BBR flow control algorithm, then it would need to wait for a platform to integrate an implementation of the algorithm. By using a basic UDP interface to the platform’s transport services, the entire flow control and encryption service can be lifted into the application itself, if so desired. There may be some performance penalty of shifting the transport code from the kernel to user space, but in return the application regains complete control of the transport service and allows it to operate in a mode which is not only independent of the platform but also hidden from the platform. This gives the application environment greater levels of control and agility.</p>\n<p>However, QUIC is a whole lot more than just wrapping up TCP in UDP, so let’s look at the QUIC protocol in a little more detail.</p>\n<h4 id=\"quic-connections\">QUIC Connections<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#quic-connections\"></a></h4>\n<p>A QUIC connection is a shared state between a single client and a single server. QUIC uses the combination of two numbers, one selected by each end, to form a pair of connection IDs. This acts as a persistent identity for the QUIC session, which is used to ensure that changes in addressing at lower protocol layers (addresses or ports) will not cause packets to be delivered to a wrong recipient on the end host.</p>\n<p>The primary function of a connection ID is to ensure that changes in addressing at lower protocol layers (IP source address and UDP source port numbers) do not cause packets for a QUIC connection to be dropped when there is a change in the external IP address of an endpoint. Each endpoint selects a connection ID using an implementation-specific (and perhaps deployment-specific) method that will allow received packets with that connection ID to be to be identified by the endpoint upon receipt to the appropriate QUIC connection instance.</p>\n<p>After an endpoint receives a packet with the same connection ID and a different IP address or UDP port, it will verify the peer’s ownership of the new address by sending a challenge frame containing random data to this new address and waiting for an echoed response with the same data. This challenge and response exchange is performed within the established crypto state, so it is intentionally challenging for an eavesdropper to hijack a session in this way. The two endpoints can continue to exchange data after the verification of the new address.</p>\n<p>This is particularly useful in terms of negotiating various forms of Network Address Translation (NAT) behaviour. NATs are intentionally transport-aware and for TCP NATs will attempt to maintain a translation state until it observes the closing FIN exchange. UDP offers no such externally visible clues as to the ending of a session and NATs are prone to interpreting a silent period as a signal to tear down the NAT state. In such a case the next outbound packet might be assigned a new source address and/or UDP source port number by the NAT. It is also useful in terms of session resumption where the connection may have been idle for an extended period, and the NAT binding may have timed out. With TCP any change in any of the four address and port fields of the connection 5-tuple will cause the packet to be rejected as part of the TCP session. QUIC’s use of a persistent connection ID permits the receiver to associate the new sender’s address details with an existing connection.</p>\n<p>This QUIC functionality of address agility can also be used in the context of network-level changes, such as a device switching between WiFi and cellular services while maintaining an active QUIC transport session.</p>\n<h4 id=\"quic-connection-handshake\">QUIC Connection Handshake<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#quic-connection-handshake\"></a></h4>\n<p>A QUIC connection starts with a handshake which establishes a shared communications state and a shared secret using the QUIC-TLS protocol cryptographic handshake protocol in a single exchange. This protocol merges the TCP 3-way handshake and the TLS 1.3 3-way handshake into a single 3 packet exchange (Figure 2). This eliminates a full Round Trip Time (RTT) in the QUIC startup phase, which for short sessions is a very significant improvement in session performance.</p>\n<p><img src=\"/assets/images/quicvtcp-fig2.webp\"><br>\nFigure 2 – TCP/TLS and QUIC Handshakes</p>\n<p>QUIC also allows a client to send 0-RTT encrypted application data in its first packet to the server by reusing the negotiated parameters from a previous connection and a TLS 1.3 pre-shared key (PSK) identity issued by the server, although these 0-RTT data exchanges are not protected against replay attack.</p>\n<h4 id=\"packets-and-frames\">Packets and Frames<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#packets-and-frames\"></a></h4>\n<p>The QUIC protocol sends packets along the connection. Packets are individually numbered in a 62-bit number space. There is no allowance for retransmission of a numbered packet. If data is to be retransmitted, it is done so in a new packet with the next packet number in sequence. That way there is a clear distinction between the reception of an original packet and a retransmission of the data payload.</p>\n<p>Multiple QUIC packets can be loaded into a single UDP datagram. QUIC UDP datagrams must not be fragmented, and unless the end performs path MTU discovery, then QUIC assumes that the path can support a 1,200-byte UDP payload.</p>\n<p>A QUIC client expands the payload of all UDP datagrams carrying Initial packets to at least the smallest allowed maximum datagram size of 1,200 bytes by adding padding frames to the Initial packet or by coalescing a set of Initial packets. The payload of all UDP datagrams carrying ack-eliciting Initial packets is padded to at least the smallest allowed maximum datagram size of 1,200 bytes. Sending UDP datagrams of this size ensures that the network path supports a reasonable Path Maximum Transmission Unit (PMTU), in both directions. Additionally, a client that expands Initial packets helps reduce the order of amplitude gain of amplification attacks caused by server responses toward an unverified client address.</p>\n<p>QUIC packets are encrypted individually, so that the decryption process does not result in data decryption waiting for partially delivered packets. This is not generally possible under TCP, where the encryption records are in a byte stream and the protocol stack is unaware of higher-layer boundaries within this stream. The additional inference from this per-packet encryption is that it’s a requirement that QUIC IP packets are not fragmented. QUIC implementations typically use a conservative choice in the maximum packet size so that IP packet fragmentation does not occur.</p>\n<p>A QUIC receiver ACKs the highest packet number received so far, together with a listing of all received contiguous packet number blocks of lower-numbered packets if there are gaps in the received packet sequence. Because QUIC uses purpose-defined ACK frames, QUIC can code up to 256 such number ranges in a single frame, whereas TCP SACK has a limit of 3 such sequence number ranges. This allows QUIC to provide a more detailed view of packet loss and reordering, leading to higher resiliency against packet losses and more efficient recovery. Lost packets are not retransmitted. Data recovery is performed in the context of each QUIC stream.</p>\n<h4 id=\"quic-streams\">QUIC Streams<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#quic-streams\"></a></h4>\n<p>A QUIC connection is further broken into streams. Each QUIC stream provide an ordered byte-stream abstraction to an application similar in nature to a TCP byte-stream. QUIC allows for an arbitrary number of concurrent streams to operate over a connection. Applications may indicate the relative priority of streams.</p>\n<p>Because the connection has already performed the end-to-end association and established the encryption context, streams can be established with minimal overhead. A single stream frame can open, pass data, and close down within a single packet, or a stream can exist for the entire lifetime of the connection.</p>\n<p>By comparison, it is possible to multiplex a TCP session into streams, but all such multiplexed TCP streams share a single flow control state. If the TCP receiver advertises a zero-sized window to the sender, then all multiplexed streams are blocked in a TCP scenario.</p>\n<p>Each QUIC stream is identified by a unique stream ID, where its two least significant bits are used to identify which endpoint initiated the stream and whether the stream is bidirectional or unidirectional. The byte stream is segmented to data frames, and the stream frame offset is equivalent to the TCP sequence number, used for data frame delivery ordering and loss detection and retransmission for reliable data delivery.</p>\n<p>QUIC endpoints can decide how to allocate bandwidth between different streams, how to prioritize transmission of different stream frames based on information from the application. This ensures effective loss recovery, congestion control, flow control operations, which can significantly impact application performance.</p>\n<h4 id=\"quic-datagrams\">QUIC Datagrams<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#quic-datagrams\"></a></h4>\n<p>In addition to reliable streams, QUIC also supports an unreliable but secured data delivery service with DATAGRAM frames, which will not be retransmitted upon loss detection<a id=\"fnref-5\" class=\"fnref\" href=\"#fn-5\">5</a>. When an application sends a datagram over a QUIC connection, QUIC will generate a DATAGRAM frame and send it in the first available packet. When a QUIC endpoint receives a valid DATAGRAM frame, it is expected that it would deliver the data to the application immediately. These DATAGRAM frames are not associated with any stream.</p>\n<p>If a received packet contains only DATAGRAM frames, then the ACK frame can be delayed, as the sender will not retransmit a frame when there is an ACK failure in any case. This is not a reliable datagram service. If a sender detects that a packet containing a specific DATAGRAM frame might have been lost, the implementation may notify the application that it believes the datagram was lost. Similarly, if a packet containing a DATAGRAM frame is acknowledged, the implementation may notify the sender application that the datagram was successfully transmitted and received.</p>\n<h4 id=\"quic-frames\">QUIC Frames<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#quic-frames\"></a></h4>\n<p>Each packet contains a sequence of frames. Frames have a frame type field and type-dependant data. The QUIC standard<a id=\"fnref-4\" class=\"fnref\" href=\"#fn-4\">4</a> defines 20 different frame types. They serve an analogous purpose to the TCP flags, carrying a control signal about the state of streams and the connection itself.</p>\n<p>Frame types include padding, ping (or keepalive), ack frames for received packet numbers, which themselves contain ECN counts as well as ack ranges, as well as stream data frames, and datagram frames.</p>\n<p>The larger organisation of QUIC connections, streams and frames is shown in Figure 3.</p>\n<p><img src=\"/assets/images/quicvtcp-fig3.webp\"><br>\nFigure 3 – QUIC logical organisation</p>\n<h4 id=\"quic-recovery-and-flow-control\">QUIC Recovery and Flow Control<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#quic-recovery-and-flow-control\"></a></h4>\n<p>QUIC packets contain one or more frames. QUIC performs loss detection based on these packets, not on individual frames. For each packet that is acknowledged by the received, all frames carried in that packet are considered received. The packet is considered lost if that packet is unacknowledged when a later sent packet has been acknowledged, and when a loss threshold is met.</p>\n<p>QUIC uses two thresholds to determine loss. The first is a <em>packet reordering threshold <strong>t</strong></em>. When packet <em><strong>x</strong></em> is acknowledged, then all unacknowledged packets with a number less than <em><strong>x – t</strong></em> are considered lost. The second is related to the QUIC-measured RTT interval, the <em>waiting time <strong>w</strong></em> which is determined as a weight factor applied to the current estimated RTT interval. If the time of the most recent acknowledgement is <em><strong>t</strong></em>, then all unacknowledged packets sent before time <em><strong>t – w</strong></em> will be considered lost.</p>\n<p>For recovery, all frames in lost packets where the associated stream requires retransmission will be placed into new packets for retransmission. The lost packet itself is not retransmitted.</p>\n<p>As with TCP's advertised receiver window, QUIC contains a mechanism to enable a QUIC receiver to control the maximum amount of data that a sender can send on an individual stream, and the maximum amount on all streams at any time. Also, as with TCP, the flow control algorithm to be used by reliable streams is not specified by QUIC, although one such sender-side congestion controller is defined in<a id=\"fnref-6\" class=\"fnref\" href=\"#fn-6\">6</a>. This is an algorithm similar to TCP’s New Reno<a id=\"fnref-7\" class=\"fnref\" href=\"#fn-7\">7</a>.</p>\n<h3 id=\"quic-issues\">QUIC Issues<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#quic-issues\"></a></h3>\n<h4 id=\"rpc-support\">RPC support<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#rpc-support\"></a></h4>\n<p>IP hosts commonly support just two transport services, UDP and TCP. UDP is a simple datagram delivery service. Data encapsulated using UDP have no assured delivery. TCP, as we have seen, is a reliable streaming service. Any packet loss, or changes to the delivered packet sequence is repaired by the TCP protocol.</p>\n<p>There is another model, namely the Remote Procedure Call (RPC) model. This model emulates the functionality of procedure calls, and rather than the byte stream model of TCP or the datagram model of UDP, the RPC model is a reliable request/reply model, where the reply is uniquely associated with the request. Perhaps the most well-known example today of an RPC framework is gRPC<a id=\"fnref-8\" class=\"fnref\" href=\"#fn-8\">8</a>. gRPC is based on an HTTP/2 platform, which implies that the framework is susceptible to head of line blocking as with any other TCP-based substrate.</p>\n<p>The issue here is that a reliable byte stream is not the right abstraction for RPC, as the core of RPC is a request/reply paradigm, which is more aligned to a reliable messaging paradigm, with all that such a paradigm entails. A capable RPC framework needs to handle lost, mis-ordered, and duplicated messages, with an identifier space that can match requests and responses. The underlying message transport needs to handle messages of arbitrary size, which entails packetization adaptation within the transport.</p>\n<p>The bidirectional stream framework is a reasonable match to the RPC communications model where each RPC can be is matched against an individual stream. The stream is reliable and sequenced. The data framing is not contained in QUIC, and it is still an application task to add a record structure to an RPC stream, if that is what is required. The invocation overhead is low in that the encrypted end-to-end connection is already established.</p>\n<p>It certainly appears that HTTPS behaves much more like RPC than a reliable byte stream. That can benefit applications that run over HTTP(S), such as gRPC, and a set of RESTful APIs.</p>\n<h4 id=\"load-balancing-quic\">Load Balancing QUIC<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#load-balancing-quic\"></a></h4>\n<p>In today’s world of managing scale its very common to place a front-end load balancer across a number of servers. The load balancer in the TCP world typically categorizes packets as being in the same TCP session because of a common 5-tuple value of protocol, IP addresses and port numbers, with the confident assurance that this value is stable for the life of the TCP session.</p>\n<p>With QUIC there are no such assurances. The 5-tuple load balancing approach can work, but if the client is behind a NAT that performs what could be called “aggressive” rebinding then any such load balancing approach will be thrown. The reason why is that UDP does not provide session signalling to a NAT, so the is no a priori assurance that the NAT bindings (and the presented source address and port) will remain constant for the entire QUIC session. Now in theory IPv6 could invoke the Flow-ID to provide a proxy persistent field that remains constant for a flow, but the Flow-ID is of limited size and has no assurances of uniqueness, as well as evidence of highly variable treatment by IPv6 network infrastructure and end hosts.</p>\n<p>This topic touches upon a major assumption in today’s high-capacity server infrastructure on the public Internet. Data streams use TCP and the DNS uses UDP. Using UDP to carry sustained high-volume streams may not match the internal optimisations used in server content delivery networks.</p>\n<h4 id=\"ddos-defence\">DDOS Defence<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#ddos-defence\"></a></h4>\n<p>The next issue here is exposure to DOS attacks. An attacker can send a large volume of packets to the server and cause the server to perform work to attempt to decrypt the packet. For this to be successful in TLS over TCP the attacker must make a reasonable guess of the TCP sequence number and window size for the packet to be accepted and passed to the TLS decoder. In QUIC there is no lightweight packet filter before the decoder is invoked.</p>\n<p>On the other hand, the session encryption uses symmetric crypto algorithms, which are less of a load on the receiver to decode than asymmetric encryption. Is this enough of a difference to allow large scale QUIC platforms that are DOS resistant to be constructed? I’m unsure if there are clear answers here, but it seems that its part of the cost of having a more complete encryption framework, which in itself appears to be sorely needed on the public Internet.</p>\n<h4 id=\"private-quic\">Private QUIC<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#private-quic\"></a></h4>\n<p>For private contexts can QUIC negotiate a “null” TLS encryption algorithm?</p>\n<p>There is a bigger world out there beyond the public Internet and in many private data centre environments the overheads of encrypting and decrypting packets are overheads that may appear to be unnecessary. While QUIC can present some clear advantages in terms of suitability to complex application behaviours in the data centre that can leverage QUIC’s multi-stream capability, the cost of encryption may be too high.</p>\n<p>Of course, there is nothing stopping an implementation using a null encryption algorithm, but such an implementation could only talk to other implementations of itself. Strictly speaking, if you remove encryption, then it’s no longer QUIC and won't interoperate with anything else that is QUIC.</p>\n<h4 id=\"quic-and-openssl\">QUIC and OpenSSL<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#quic-and-openssl\"></a></h4>\n<p>It useful to ask that is QUIC has such clear advantages over TCP then why hasn’t the adoption of QUIC been rapid. Metrics of QUIC use tend to point to a use rate of some 30% of web sessions (such as Cloudflare’s Radar report<a id=\"fnref-9\" class=\"fnref\" href=\"#fn-9\">9</a>). However, if you alter the measurement to measure the extent to which browsers on end systems are capable of supporting a QUIC session, then the measurement jumps to 60%<a id=\"fnref-10\" class=\"fnref\" href=\"#fn-10\">10</a>.</p>\n<p>There are a couple of reasons why QUIC use is far lower than QUIC capability. The first is that the Chrome browser still relies on the content-level switch to QUIC, so that the client has to visit the site for the first time using HTTP/2 (TCP/TLS) and thereby receive an indication if the server can support QUIC, and then on the second visit the client may use QUIC. It’s not quite as simple as this, as HTTP/2 uses persistent connection, so if the second visit is sufficiently close in time to the first, then the HTTP/2 session will remain open and still be use. The Safari browser is capable of using QUIC on first use because it is triggered by the SVCB record in the DNS, but the market share of Safari is relatively small in comparison to QUIC.</p>\n<p>The second reason lies in the web server environment. Many servers rely on the OpenSSL TLS library<a id=\"fnref-11\" class=\"fnref\" href=\"#fn-11\">11</a>, and so far, (November 2022) OpenSSL does not include support for QUIC. QUIC is supported in BoringSSL<a id=\"fnref-12\" class=\"fnref\" href=\"#fn-12\">12</a>, but as the notes for BoringSSL states, BoringSSL is a fork of OpenSSL that is designed to meet Google's needs, and while this works for Google, it may not work for everyone else. Google does not recommend that third parties depend on BoringSSL. There is also QuicTLS, a fork of OpenSSL supported by Akamai and Google<a id=\"fnref-13\" class=\"fnref\" href=\"#fn-13\">13</a>. This fragmentation of OpenSSL is not exactly helpful and the result is that many server environments are waiting for OpenSSL to incorporate a QUIC library. This effort was delayed by the work on OpenSSL release 3.0.0, and then the OpenSSL folk announced their intention to provide a fully functional QUIC implementation, and this development of a new QUIC protocol stack may further delay QUIC support in OpenSSL by months, if not years. This may well be the major impediment behind the very large scale deployment of QUIC in the guise of HTTP/3 across the Internet.</p>\n<h3 id=\"conclusions\">Conclusions<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#conclusions\"></a></h3>\n<p>There are a few conclusions we can draw from this effort with QUIC.</p>\n<p>Any useful public communications medium needs to safeguard the privacy and integrity of the communications that it carries. The time when open protocols represented an acceptable compromise between efficiency, speed and privacy are over and these days all network transactions in the public Internet need to be protected by adequate encryption. QUIC’s model of wrapping a set of transactions between a client and a server in a single encryption state represents a sensible design decision.</p>\n<p>Encryption is no longer an expensive luxury, but a required component for all transactions over the public Internet. The added imposition is that adding encryption into a network transaction should impose no additional performance penalty in terms of speed and responsiveness.</p>\n<p>Network transactions come in many forms, and TCP and UDP tend to represent two ends of a relatively broad spectrum. UDP is just too susceptible to abuse so we’ve heaped everything onto TCP. The issue is TCP was designed as an efficient single streaming protocol and retro-fitting multiple sessions, short transactions, shared congestion state and shared encryption state have proved to be extremely challenging.</p>\n<p>Applications are now dominant in the Internet ecosystem, while platforms and networks are being commoditised. We are seeing losing patience with platforms providing common transport services for the application that they host, and a new model where the application comes with its own transport service. This is not just the HTTP client/server model but has been extended into application-specific DNS name resolution with DNS over HTTPS. It's highly likely that this trend will continue for the moment.</p>\n<p>Taking an even broader perspective, the context of the Internet’s success lay in shifting the responsibility for providing service from the network to the end system. This allowed us to make more efficient use of the common network substrate and push the cost of this packetization of network transactions over to end systems. It shifted the innovation role from the large and lumbering telco operators into the more nimble world of platform software. The success of Microsoft with its Windows product was not an accident by any means. QUIC takes this one step further, and pushes the innovation role from platforms to applications, just at the time when platforms are declining in relative importance within the ecosystem. From such a perspective the emergence of an application-centric transport model that provides faster services, a larger repertoire of transport models and encompassing comprehensive encryption was an inevitable development.</p>\n<hr>\n<h2 id=\"footnotes\">Footnotes<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#footnotes\"></a></h2>\n<ol>\n<li><span id=\"fn-1\" style=\"width: 0; height: 0;\"></span><p>Eddy, W., Ed.,, “Transmission Control Protocol (TCP)”, RFC 9293, August 2022, <a href=\"https://www.rfc-editor.org/info/rfc9293\">https://www.rfc-editor.org/info/rfc9293</a>.<a class=\"fn\" href=\"#fnref-1\">˄</a></p></li>\n<li><span id=\"fn-2\" style=\"width: 0; height: 0;\"></span><p>Postel, J., Ed., “Transmission Control Protocol”, RFC 793, September 1981, <a href=\"https://www.rfc-editor.org/info/rfc793\">https://www.rfc-editor.org/info/rfc793</a>.<a class=\"fn\" href=\"#fnref-2\">˄</a></p></li>\n<li><span id=\"fn-3\" style=\"width: 0; height: 0;\"></span><p>Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, August 2018, <a href=\"https://www.rfc-editor.org/info/rfc8446\">https://www.rfc-editor.org/info/rfc8446</a>.<a class=\"fn\" href=\"#fnref-3\">˄</a></p></li>\n<li><span id=\"fn-4\" style=\"width: 0; height: 0;\"></span><p>Iyengar, J., Ed., and M. Thomson, Ed., \"QUIC: A UDP-Based Multiplexed and Secure Transport\", RFC 9000, May 2021, <a href=\"https://www.rfc-editor.org/info/rfc9000\">https://www.rfc-editor.org/info/rfc9000</a>.<a class=\"fn\" href=\"#fnref-4\">˄</a></p></li>\n<li><span id=\"fn-5\" style=\"width: 0; height: 0;\"></span><p>Pauly, T., Kinnear, E., and D. Schinazi, \"An Unreliable Datagram Extension to QUIC\", RFC 9221, March 2022, <a href=\"https://www.rfc-editor.org/info/rfc9221\">https://www.rfc-editor.org/info/rfc9221</a>.<a class=\"fn\" href=\"#fnref-5\">˄</a></p></li>\n<li><span id=\"fn-6\" style=\"width: 0; height: 0;\"></span><p>Iyengar, J., Ed., and I. Swett, Ed., \"QUIC Loss Detection and Congestion Control\", RFC 9002, May 2021, <a href=\"https://www.rfc-editor.org/info/rfc9002\">https://www.rfc-editor.org/info/rfc9002</a>.<a class=\"fn\" href=\"#fnref-6\">˄</a></p></li>\n<li><span id=\"fn-7\" style=\"width: 0; height: 0;\"></span><p>Henderson, T., Floyd, S., Gurtov, A., and Y. Nishida, \"The NewReno Modification to TCP's Fast Recovery Algorithm\", RFC 6582, April 2012, <a href=\"https://www.rfc-editor.org/info/rfc6582\">https://www.rfc-editor.org/info/rfc6582</a>.<a class=\"fn\" href=\"#fnref-7\">˄</a></p></li>\n<li><span id=\"fn-8\" style=\"width: 0; height: 0;\"></span><p>gPRC – A cross-platform open source RPC framework <a href=\"https://grpc.io/\">https://grpc.io/</a>.<a class=\"fn\" href=\"#fnref-8\">˄</a></p></li>\n<li><span id=\"fn-9\" style=\"width: 0; height: 0;\"></span><p>Cloudflare Rader, retrieved 1 November 2022, <a href=\"https://radar.cloudflare.com/\">https://radar.cloudflare.com/</a>.<a class=\"fn\" href=\"#fnref-9\">˄</a></p></li>\n<li><span id=\"fn-10\" style=\"width: 0; height: 0;\"></span><p>APNIC Labs, Quic Usage Report, retrieved 1 November 2022, <a href=\"https://stsats.labs.apmnic.net/quic\">https://stsats.labs.apmnic.net/quic</a>.<a class=\"fn\" href=\"#fnref-10\">˄</a></p></li>\n<li><span id=\"fn-11\" style=\"width: 0; height: 0;\"></span><p>OpenSSL a library for secure communication, retrieved 1 November 2022, <a href=\"https://www.openssl.org\">https://www.openssl.org</a>.<a class=\"fn\" href=\"#fnref-11\">˄</a></p></li>\n<li><span id=\"fn-12\" style=\"width: 0; height: 0;\"></span><p>BoringSSL, an open source fork of the OpenSSL library operated by Google for internal use, retrieved 1 November 2022, <a href=\"https://boringssl.googlesource.com/boringssl/\">https://boringssl.googlesource.com/boringssl/</a>.<a class=\"fn\" href=\"#fnref-12\">˄</a></p></li>\n<li><span id=\"fn-13\" style=\"width: 0; height: 0;\"></span><p>QuicTLS, an open source fork of the OpenSSL library developed by Akamai and Microsoft as an interim QUIC API, retrieved 1 November 2022, <a href=\"https://github.com/quictls/openssl\">https://github.com/quictls/openssl</a>.<a class=\"fn\" href=\"#fnref-13\">˄</a></p></li>\n</ol>","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -> 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -> easy fun -> art -> profit?\n\n> I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n> We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n> Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n> [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n>\n> Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n> Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n> A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n> “Motivation often comes after starting, not before. Action produces momentum.”\n> [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n>\n> - James Clear\n\n> Focus is more about **not** keeping busy when you need to wait for something.  \n> Eat the boredom for a minute.\n>\n> - [[life-tips#wodenokoto]]\n\n> [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n>\n> - https://www.ntnu.edu/cerg/advice\n> - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n> [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n>\n> - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n> 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n>\n> 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n>\n> - 막막한 독서. 시로군. P.10~13\n\n> I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n> My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n> Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}