{"pageProps":{"note":{"id":"wjsyv41pykk19dxjviwj6rm","title":"Coroutines and effects","desc":"","updated":1713771160739,"created":1713771107487,"custom":{},"fname":"dev.program-languages.coroutines-and-effects","type":"note","vault":{"fsPath":"vault"},"contentHash":"c18bb6d13837dbc50f984ee479b9e138","links":[],"anchors":{"background":{"type":"header","text":"Background","value":"background","line":20,"column":0,"depth":2},"what-is-a-coroutine":{"type":"header","text":"What is a coroutine?","value":"what-is-a-coroutine","line":22,"column":0,"depth":3},"what-is-an-effect-handler":{"type":"header","text":"What is an effect handler?","value":"what-is-an-effect-handler","line":32,"column":0,"depth":3},"the-difference-is-between-static-and-dynamic-scope":{"type":"header","text":"The difference is between static and dynamic scope","value":"the-difference-is-between-static-and-dynamic-scope","line":48,"column":0,"depth":2}},"children":[],"parent":"cnzc1i8ojequt9lhg3zpkgo","data":{}},"body":"<h1 id=\"coroutines-and-effects\">Coroutines and effects<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#coroutines-and-effects\"></a></h1>\n<blockquote>\n<p><a href=\"https://without.boats/blog/coroutines-and-effects/\">https://without.boats/blog/coroutines-and-effects/</a></p>\n<p>The passage discusses the relationship between effect systems and coroutines. It explains that effect systems, like those found in languages like Koka, and coroutines, like Rust's async functions, are in some ways isomorphic to each other. The key difference is that coroutines yield control to their caller, while effectful expressions in effect systems yield control to their handler. The author argues that coroutines strike a good balance, as they are statically typed, lexically scoped, and unlayered, making them a promising approach for handling effectful functions. The passage also contrasts effect systems with Rust's use of the Result type and async/await syntax to model effects.</p>\n</blockquote>\n<p>For the past few months I’ve been mulling over some things that Russell Johnston made me realize about the relationship between effect systems and coroutines. You can read more of his thoughts on this subject <a href=\"https://www.abubalay.com/blog/2024/01/14/rust-effect-lowering\">here</a>, but he made me realize that effect systems (like that found in Koka) and coroutines (like Rust’s async functions or generators) are in some ways isomorphic to one another. I’ve been pondering the differences between them, trying to figuring out the advantages and disadvantages of each.</p>\n<p>A few weeks ago, Will Crichton posted something on <a href=\"https://twitter.com/tonofcrates/status/1770560175835058573\">Twitter</a> that helped bring the contrast into sharper focus for me:</p>\n<blockquote>\n<p>The entire field of PL right now: what if it was dynamically scoped…. but statically typed…………..? (effects, capabilities, contexts, metavariables…)</p>\n</blockquote>\n<p>I’m just a humble language designer (and not a theorist of anything, especially not PL), so my focus is the difference in user experience and affordance. But this seems like a cutting insight and this property of effect handlers - static typing but dynamic scoping - seems to me to be a good jumping off point for understanding the difference between effect handlers and coroutines from a user perspective.</p>\n<h2 id=\"background\">Background<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#background\"></a></h2>\n<h3 id=\"what-is-a-coroutine\">What is a coroutine?<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#what-is-a-coroutine\"></a></h3>\n<p>A coroutine is a function which can yield control back to its caller before finishing. The caller then has a reference to the state of the coroutine when it yielded, so it can resume the coroutine again if it so chooses. It’s possible to model many meaningful “effects” using coroutines by having the coroutine yield. For example:</p>\n<ul>\n<li>A coroutine can perform IO “asynchronously,” by yielding a value like <code>Pending</code> when IO is being performed.</li>\n<li>A coroutine can be iterable by yielding values as it traverses some collection.</li>\n<li>A coroutine can model exceptions by yielding an exception value (in this case, resuming the coroutine would have no effect).</li>\n</ul>\n<p>Rust, for example, models both asynchrony and iteration using coroutines. On the other hand, exceptions are not modeled this way; instead they are modeled with the <code>Result</code> type. Specifically, Rust uses “stackless” coroutines, but this distinction is not very important to the concepts in this post.</p>\n<h3 id=\"what-is-an-effect-handler\">What is an effect handler?<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#what-is-an-effect-handler\"></a></h3>\n<p>I need to be clear, because terminology has become muddied in the Rust community: this post has nothing in particular to do with “effects generics” as conceptualized by the Rust project, which is a different set semantic features related to how Rust handles effects from “effects systems” as they appear in the literature. In this post, I am focused on effect systems as proposed in languages like <a href=\"https://koka-lang.github.io/koka/doc/index.html\">Koka</a> and <a href=\"https://effekt-lang.org/\">Effekt</a>. And my understanding of these systems may be imperfect or wrong, but this is how they operate as I understand them.</p>\n<p>In an effect system, in addition to a type, an expression will have an <em>effect</em>. An effect is an additional “kind” in the formal, type system sense of the word (in the same way that lifetimes are another “kind” in Rust). In general, expressions inherit the effects of other expressions they contain. Functions inherit the effects of their body.</p>\n<p>For example, Koka has a “diverging” effect, which means that an expression may diverge (that is to say, it may not finish evaluating). An expression containing a diverging expression is also diverging. So you can distinguish in the type system between a function that is guaranteed to finish and a function that may not finish (this is imperfect, of course, because of the undecidability of the halting problem; some functions that do not diverge will be marked diverging).</p>\n<p>However, these languages also have a concept of <em>effect handlers</em>, which take an expression with an effect and “handle” it, producing an expression without that effect. Not all effects can be handled (for example, as far as I understand it is not possible to meaningfully handle the diverging effect), but some can. The semantics of what it means to handle an effect are where effect systems become similar to coroutines.</p>\n<p>When a handleable effect occurs, an effectful expression yields control to the nearest-most handler of that effect, which may or may not yield control back. This can be used to model all of the same sorts of effects as coroutines. For example:</p>\n<ul>\n<li>An IO effect can yield control to the IO handler, which will yield back to the expression when IO is complete.</li>\n<li>An iterable effect can yield control to the loop consumer for each value, which yields back to the iterable to continue iteration.</li>\n<li>An exception effect can yield control to an exception handler, which will not yield control back.</li>\n</ul>\n<h2 id=\"the-difference-is-between-static-and-dynamic-scope\">The difference is between static and dynamic scope<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#the-difference-is-between-static-and-dynamic-scope\"></a></h2>\n<p>The key difference between coroutines and effect handlers is that coroutines yield control to their caller, but effectful expressions yield control to their handler. The difference of affordance this implies is the materially significant advantage of coroutines over effect handlers.</p>\n<p>Let’s imagine a programming language in which every function is a coroutine which can yield <code>Pending</code> or an exception (to model both IO and exceptions) and there are multiple kind of call operators that “handle effects” differently:</p>\n<ul>\n<li>There is an ordinary call operator that can only be used on coroutines that never yield (these coroutines are effectively pure functions)</li>\n<li>There is an asynchronous <code>().await</code> call operator that can be called on coroutines that yield <code>Pending</code>, which yields <code>Pending</code> and then calls them again (so it can only be called from within another coroutine that yields <code>Pending</code>)</li>\n<li>There is an exception-throwing <code>()?</code> call operator that can be called on coroutines that yield an exception, which yields the exception outward.</li>\n<li>There is a combined <code>().await?</code> call operator that can be called on coroutines that yield <code>Pending</code> and exceptions, to forward both effects.</li>\n</ul>\n<p>Let’s suppose you wanted to do an HTTP request in this language (which performs IO and can also raise an exception representing some sort of IO error):</p>\n<pre class=\"language-fallback\"><code class=\"language-fallback\">fn get_blog() -> HttpResponse yields (Pending | Exception) {\n    http::get(\"https://without.boats\").await?\n}\n</code></pre>\n<p>Now, let’s contrast this to a similar language which models IO and exceptions using effects. In this language, there is no need for special call operators: a function which has an IO or exception effect can call functions which also have IO or exception effects:</p>\n<pre class=\"language-fallback\"><code class=\"language-fallback\">fn get_blog() -> HttpResponse effect (IO | Exception) {\n    http::get(\"https://without.boats\")\n}\n</code></pre>\n<p>The difference between these features is that the call to <code>http::get</code> must be annotated with the <code>await</code> and <code>?</code> syntax to forward its effects, whereas with effect handlers the forwarding of effects by a callee is implicit.</p>\n<p>I want to take one more step back and then I promise I will reach a conclusion. There are definitions of coroutines other than the one I gave, especially older ones. If you were to closely read <a href=\"https://en.wikipedia.org/wiki/Coroutine\">Wikipedia</a>, you would find a slightly different definition, and what I’ve called coroutines are addressed instead as “generators” or “semicoroutines.” In the older definition, a coroutine can specify where it yields control. This is actually based on a model of program execution in which there is no program stack: instead, every coroutine is a global singleton, and yielding control to it means continuing it wherever it last left off. For semicoroutines, in contrast, calling a coroutine produces a new stack frame which can only be resumed by code with a reference to that stack frame.</p>\n<p>The program stack is such a universal model of program execution today that we treat it as inevitable, but like everything else it had to be invented. It was invented to support recursive function definition, but it has other advantages in the way that it enables local reasoning: from the body of a function, there is exactly one dynamic jump point - wherever it returns to. From the point of view of the caller, this is now statically known: the function will jump back to the point at which it is called.</p>\n<p>This rule can only be violated when a language introduces new features that allow additional dynamic jump points. One that has long been popular is the notion of exceptions, which unwind the call stack to the point at which they are being handled. There are two kinds of exceptions: unchecked exceptions, which are totally untyped, and checked exceptions, which require an annotations on any function which could throw them.</p>\n<p><strong>Effect handlers are a generalization of checked exceptions</strong>, with all of the pros and cons of that feature. They require you to annotate functions that have an effect, but they do not require you to annotate <em>calls</em> at which the effect can occur. Therefore, when examining the body of a function, to understand when the effect occurs requires examining the type signature of every function that is called. Since this is meaningful control flow, it seems very valuable to be able to identify points at which an error occurs without examining the signatures of each function call. This is why Rust features <code>Result</code> and the <code>?</code> operator instead of checked exceptions.</p>\n<p>There’s an axis of evaluation here with three points: a language could model an effect in a way which is totally unchecked at compile time: both dynamically typed and dynamically scoped. Unchecked exceptions (including panics) are an example of this; so is blocking IO. And a language could model the effect in the type system, but with a dynamic scope. Checked exceptions and effect handlers are both examples of this. And a language could model the effect in a way which is both statically typed and lexically scoped. This is what Rust does for these effects with both <code>Result</code> and <code>async/await</code>.</p>\n<p>(You may notice that there’s a fourth spot in the design space not covered here: dynamically typed and lexically scoped. An example in this category would be the async/await feature in dynamically typed languages like Python and JavaScript; you must annotate asynchronous calls with <code>await</code> to get their result, but if you fail to do so it is not a compile-time error.)</p>\n<pre class=\"language-fallback\"><code class=\"language-fallback\">                                          │   EXCEPTIONS          │   IO\n──────────────────────────────────────────┼───────────────────────┼───────────────\n                                          │                       │\n  DYNAMICALLY TYPED &#x26; DYNAMICALLY SCOPED  │   panicking           │   blocking\n                                          │                       │\n   STATICALLY TYPED &#x26; DYNAMICALLY SCOPED  │   checked exceptions  │   IO effect\n                                          │                       │\n     STATICALLY TYPED &#x26; LEXICALLY SCOPED  │   Result              │   async/await\n                                          │                       │\n</code></pre>\n<p>These are not the only language features that can be used to model effects, and other features also fall into one of these buckets. For example, monads are also statically typed and lexically scoped. However, a major objection to monads is that they model effects in a specifically layered way, so that for example there is a distinction between an <code>IO&#x3C;Result&#x3C;T, E>></code> and a <code>Result&#x3C;IO&#x3C;T>, E></code>. Coroutines on the other hand are order-independent: all coroutine that yield <code>Pending</code> and <code>Exception</code> have the same type, there is no distinction of order. The same is true of effect handlers.</p>\n<p>This has appeared in Rust for example with the debate about the design of <a href=\"https://without.boats/blog/poll-next\">async iterators</a>. Designs based on <code>async fn next</code> introduce an arbitrary ordering by introducing multiple coroutines, whereas designed based on a single coroutine do not make a distinction; the coroutine just yields items as well as <code>Pending</code>. This was the crux of Russell Johnston’s argument in the post I linked earlier: this unlayered property is shared by coroutines and effect handlers, and is an advantage of these features.</p>\n<p>On the other hand, by modeling errors with <code>Result</code> instead of some sort of coroutine, Rust <em>does</em> introduce an ordering. This is mostly fine because of the fact that a function which “throws an exception” (by evaluating to an <code>Err</code>) is not supposed to be resumed, though it introduces some quirks where for example there’s no way to distinguish between an iterator of <code>Result</code>s (which may continue after one is an <code>Err</code>) and an iterator which throws an error (which will not continue). If instead a generator could “yield an exception,” it would be a different type from a generator that yields a sequence of <code>Result</code>s. But I don’t find this inadequacy to come up in practice that often, so I’m content to leave it as theoretical work for a future language to solve.</p>\n<p>Overall, coroutines strike me as the most promising way to handle many kinds of effectful functions because they seem to be in the design sweet spot: They are statically typed, lexically scoped, and unlayered. This is why my starting point for handling effects in any language would be a coroutine feature (though if the language were not under Rust’s constraints, I would prefer if it were a stackful coroutine feature so they could be recursive).</p>","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -> 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -> easy fun -> art -> profit?\n\n> I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n> We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n> Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n> [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n>\n> Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n> Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n> A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n> “Motivation often comes after starting, not before. Action produces momentum.”\n> [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n>\n> - James Clear\n\n> Focus is more about **not** keeping busy when you need to wait for something.  \n> Eat the boredom for a minute.\n>\n> - [[life-tips#wodenokoto]]\n\n> [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n>\n> - https://www.ntnu.edu/cerg/advice\n> - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n> [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n>\n> - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n> 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n>\n> 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n>\n> - 막막한 독서. 시로군. P.10~13\n\n> I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n> My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n> Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}