{"pageProps":{"note":{"id":"m3zpjkkh97bf1ao5rgm3k8l","title":"Why I Am Learning Category Theory 1","desc":"","updated":1670205125662,"created":1670204953258,"custom":{},"fname":"dev.functional-programming.why-i-am-learning-category-theory-1","type":"note","vault":{"fsPath":"vault"},"contentHash":"eb5ed16f3ab5497d3f91e8ac688c44db","links":[],"anchors":{"my-background-in-functional-programming":{"type":"header","text":"My background in functional programming","value":"my-background-in-functional-programming","line":15,"column":0,"depth":2},"turning-diagrams-into-code":{"type":"header","text":"Turning diagrams into code","value":"turning-diagrams-into-code","line":27,"column":0,"depth":2},"putting-words-to-my-thinking":{"type":"header","text":"Putting words to my thinking","value":"putting-words-to-my-thinking","line":41,"column":0,"depth":2},"writing-more-expressive-software":{"type":"header","text":"Writing more expressive software","value":"writing-more-expressive-software","line":65,"column":0,"depth":2},"a-never-ending-journey":{"type":"header","text":"A never-ending journey","value":"a-never-ending-journey","line":75,"column":0,"depth":2}},"children":[],"parent":"HtVLXiN97I2jTm8h2NEVQ","data":{}},"body":"<h1 id=\"why-i-am-learning-category-theory-1\">Why I Am Learning Category Theory 1<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#why-i-am-learning-category-theory-1\"></a></h1>\n<blockquote>\n<p><a href=\"https://the.scapegoat.dev/why-i-am-learning-category-theory-1/\">https://the.scapegoat.dev/why-i-am-learning-category-theory-1/</a><br>\n<a href=\"https://news.ycombinator.com/item?id=33802844\">https://news.ycombinator.com/item?id=33802844</a></p>\n</blockquote>\n<p>Category theory is a domain of mathematics that exerts a strange influence over programmers. One thing that can be said for sure about category theory is that it is highly abstract, and its relationship to software engineering is not immediately obvious. I consider myself to be more on the pragmatic side of software engineering, so <strong>why did I set out to learn category theory beyond the few concepts popularized by functional programming?</strong></p>\n<p>In particular, I have been following along <a href=\"http://brendanfong.com/programmingcats.html\">MIT 18.S097: Programming with Categories</a> and reading <a href=\"https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/\">Category Theory for Programmers</a> by Bartosz Milewski along with a few books like Steve Awodey's <a href=\"https://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182\">Category Theory</a> and <a href=\"https://www.amazon.com/Invitation-Applied-Category-Theory-Compositionality/dp/1108711820/ref=d_bpx_wsirn_iabw_v1_sccl_2_1/144-6076266-4505621\">Seven Sketches in Compositionality</a>. I want to thank my fellow Recursers who are taking part in our category theory reading group, as I wouldn't have nearly as much fun as I have.</p>\n<h2 id=\"my-background-in-functional-programming\">My background in functional programming<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#my-background-in-functional-programming\"></a></h2>\n<p><strong>My background is in systems programming</strong>; I work mostly on embedded and full-stack web development. Having been a Common Lisp aficionado, I use a lot of functional programming patterns. Until recently, my knowledge of category theory was a set of applied patterns: functors, monoids, foldables, applicatives, and especially monads.</p>\n<p>I rarely use these concepts explicitly, but they help me build software: I know when to fold a monoidal data structure, how to lift a functor into another, and how to use applicatives to validate data (if these sound abstract, that's because I wanted it to sound abstract. The programming itself is very pedestrian).</p>\n<p>Since I write mostly C++, PHP or Javascript, I use functions and simple data structures and don't go heavy on generics and type system magic. However, <strong>because of its theoretical underpinnings, my code can (usually) be cleanly composed into larger structures.</strong></p>\n<p>Yet, I always knew my approach to be a \"pop-sci\" version of category theory: I never bothered to look up the actual mathematical theory. The rare times I opened up a textbook, I was taken aback by millions of words I didn't know—I would look things up on Wikipedia or nlab and be utterly confused.</p>\n<p>My gut, however, was telling me that there was a lot of potential to be unlocked by delving deeper.</p>\n<h2 id=\"turning-diagrams-into-code\">Turning diagrams into code<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#turning-diagrams-into-code\"></a></h2>\n<p>Since I was a kid, I have been fascinated with <a href=\"https://the.scapegoat.dev/diagrams/\">diagrams</a>.</p>\n<p>Nowadays, <strong>I write code by first drawing simple boxes and arrows and doodles, then iteratively transforming them into more formal constructs</strong>. The drawings can represent time sequences, data structures, schema evolution, infrastructure, and state machines. At some point, the design is concrete enough that it can be turned into code.</p>\n<p><strong>Using these diagrams made collaboration with engineers in other disciplines very effective.</strong> For example, when drawing state machine diagrams and sequence diagrams, mechanical engineers I collaborated with were able to point out subtle race conditions, missed transitions, and faulty logic in my firmware.</p>\n<p>I \"discovered\" monads by trying really hard to encode the \"arrows\" of my state machines into more mundane programming languages like PHP or C++. It was a very autodidact approach, and I knew intuitively that there were formal ways of turning this visual approach to problem-solving into robust software.</p>\n<p>It was only years later that I realized that I had been implementing monads all along. This was a deep moment of insight for me. It allowed me to reduce tricky programming problems (concurrency in embedded systems, transaction sequencing, and error handling in distributed systems) into a single, concise concept, along with almost trivial-looking code.</p>\n<p>Category theory is literally the mathematics of boxes (objects), arrows (morphisms), and composition. <strong>Composition is how we build large software out of smaller parts while keeping complexity in check.</strong> Boxes and arrows is also how humans think in other disciplines, which makes category theory a powerful tool for uncovering cross-disciplinary analogies.</p>\n<h2 id=\"putting-words-to-my-thinking\">Putting words to my thinking<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#putting-words-to-my-thinking\"></a></h2>\n<p><strong>I have always had an \"expanding,\" holistic way of thinking about software systems.</strong> Going back to software I wrote as a junior developer, like this <a href=\"https://github.com/wesen/avr-bt-stack\">AVR Bluetooth Stack</a>, I wonder if I would write it any differently nowadays. My understanding of composition, naming, and components seem to already be fully formed, despite my inexperience (I only knew BASIC, assembly, and C when I wrote the above).</p>\n<p>This holistic approach encompasses systems (the above stack runs on both the host and 8-bit microcontrollers, which wasn't a common pattern back in 2001), machine and human (I always try to think of the developer as an <a href=\"https://the.scapegoat.dev/you-the-developer-are-a-user-too/\">actual user of the software they write</a>, code structure, runtime behavior, among other things. Of course, 18-year-old me didn't come up with these patterns out of the box, and they are influenced by the design of the Bluetooth specification, but the fact that I knew to recognize and apply them speaks to an innate sense of structure.</p>\n<p>As described in the previous paragraph, I build software by drawing boxes and arrows first and refining them until I can encode them as software.</p>\n<p>This structural approach encompasses much more than just code and data structures. I apply it to:</p>\n<ul>\n<li>product thinking</li>\n<li>communication structures</li>\n<li>schema design and evolution (database design, data schema evolution)</li>\n<li>logging and debugging (events, logging schema)</li>\n<li>runtime behavior (event loops, state machines, sequence diagrams)</li>\n<li>module and codebase decoupling</li>\n<li>software engineering workflow (git workflow, issues, and project management)</li>\n</ul>\n<p>Breaking things into boxes and arrows allows me to recognize commonalities across domains, so much so that I, for example, consider <a href=\"https://the.scapegoat.dev/embedded-programming-is-like-web-development/\">web development to be the same as embedded development</a>. I thought this statement would be quite uncontroversial, but it turns out that I got a lot of pushback. The reason I consider the two to be similar, if not the same, is that I have been able to form abstractions that carry across from embedded development to web development. <strong>An abstraction is a controlled form of forgetting the details to focus on something more fundamental, allowing one to make statements that are shorter to state yet broader in meaning.</strong></p>\n<p>Category theory is really the mathematics of composition, reducing everything it encounters to simple structures of objects and morphisms (boxes and arrows, really) and showing where they are similar and where they aren't based on how they can be composed. Once a system has been abstracted, that abstraction is abstracted: categories, functors, and monoids themselves form categories, which are yet more categories that can be put into relation with other categories.</p>\n<p><strong>I hope that category theory will allow me to formalize my intuitive understanding of abstraction, put words to it, and use those words (or, better, words others have written) to explain my thinking.</strong> The hardest about abstraction is that it requires effort to form yet becomes trivial once understood. This leads to a myriad of confusing monad tutorials that assume that there is one easy way to form the mental chunk for that abstraction when really understanding monads about the repeated struggle to work with the concept until it finally clicks. Everybody's favorite monad tutorial is the third they worked through.</p>\n<h2 id=\"writing-more-expressive-software\">Writing more expressive software<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#writing-more-expressive-software\"></a></h2>\n<p>Finally, I am seeing how learning about concepts I already had a good intuitive feel for (monoids, functors, ...) unlocks a whole new world of abstraction. I was swimming at the surface of seemingly simple concepts that actually have incredible depth, depths talented mathematicians have been studying for centuries. A good podcast about this is <a href=\"https://corecursive.com/050-sam-ritchie-portal-abstractions-2/\">corecursive's episode about portal abstractions with Sam Ritchie</a>.</p>\n<p>While I already use a lot of these patterns when writing functional code, there is so much more to be gained from understanding monoids or functors as formulated in category theory language. I started recognizing them in schema migrations, database transactions, state transitions in embedded systems, wire protocols, etc.</p>\n<p><strong>While I rarely call my classes or functions or modules mathematical names (in fact, due to the messy imperative languages I tend to use, I often can't, as their type system is rarely powerful enough), my thinking is heavily inspired by the underlying mathematical concept</strong>. That doesn't really matter much to me since writing verbose code due to not having programming language support doesn't impact the abstraction and its validity as such.</p>\n<p><strong>The soundness of the abstractions unearthed by thinking about a domain in terms of category theory means that elegant, concise, and, most importantly, composable domain-specific languages can be designed.</strong> This might be the most important result I get from learning more about mathematics. To me, a domain-specific language doesn't need to be an actual language but also encompasses API and protocol design.</p>\n<h2 id=\"a-never-ending-journey\">A never-ending journey<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#a-never-ending-journey\"></a></h2>\n<p>I am still at the very surface of category theory and just hit the first wall by working on F-algebras and recursion schemes. Yet, the value I got from sitting down and understanding functors, monoids, and adjunctions at a rigorous mathematical level, as well as working with the \"actual\" definition of categories, has already brought me a lot of confidence in my current approach to software design.</p>\n<p>I couldn't be more excited about what is coming next.</p>","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1761796791487,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"4e745570ca97988a0362cb939b760952","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":41,"column":5,"offset":2603},"end":{"line":41,"column":29,"offset":2627},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2025","alias":"What I read in 2025","position":{"start":{"line":70,"column":3,"offset":4333},"end":{"line":70,"column":54,"offset":4384},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2025"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2024","alias":"2024","position":{"start":{"line":71,"column":5,"offset":4389},"end":{"line":71,"column":41,"offset":4425},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2024"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2023","alias":"2023","position":{"start":{"line":72,"column":5,"offset":4430},"end":{"line":72,"column":41,"offset":4466},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2023"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-read-in.2022","alias":"2022","position":{"start":{"line":73,"column":5,"offset":4471},"end":{"line":73,"column":41,"offset":4507},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-read-in.2022"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":79,"column":3,"offset":4643},"end":{"line":79,"column":39,"offset":4679},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":74,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","uur1lkol353z9vfeqb3n5bv","cd9n1czq3ursgkby985wkmm","k1sr43vwnfqztwc0s43pkcf","wfde75rhdvq2yfa2zy2q6rv","rjcmdv60jokmbw6zoq8u2ef","ujapvww8o6v3kpmlhtryq4k","pkwewou9d5e8ystswn1j2b4"],"parent":null,"data":{},"body":"\nHi there 👋. I'm a Front-end developer.\n\n---\n\n- 단순함과 꾸준함은 가장 쉬우면서도 지키기 어려운 원칙.\n\n- 🥱 -> 🤔💡🌱 - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -> easy fun -> art -> profit?\n\n> I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n> We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n> Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n> [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n>\n> Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n> Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n> A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n> “Motivation often comes after starting, not before. Action produces momentum.”\n> [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n>\n> - James Clear\n\n> Focus is more about **not** keeping busy when you need to wait for something.  \n> Eat the boredom for a minute.\n>\n> - [[life-tips#wodenokoto]]\n\n> [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n>\n> - https://www.ntnu.edu/cerg/advice\n> - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n> [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n>\n> - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n> 도무지 읽히지 않는 책 앞에서 내가 택한 방법은 펼쳐진 페이지 앞에서 멍때리기이다. 다르게 표현하면 이렇다. 펼쳐진 두 페이지 앞에서 오래 머물기.\n>\n> 책을 펼쳐놓는 것으로 충분하다. 읽지 못해도 좋다. 매일 정해진 진도를 나가야 하는 학교 수업이 아니니까. 하지만 읽지 않아도 괜찮다고 해서 펼쳐두지조차 않으면 곤란하다. 가능한 한 자주 책을 펼쳐두도록 하자. 전혀 읽지 않고 멍하니 바라보고 있다가 다시 덮게 되더라도\n>\n> - 막막한 독서. 시로군. P.10~13\n\n> I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n> My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n> Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2025|journal.what-i-read-in.2025]]\n  - [[2024|journal.what-i-read-in.2024]]\n  - [[2023|journal.what-i-read-in.2023]]\n  - [[2022|journal.what-i-read-in.2022]]\n- 📝 [Gists](https://gist.github.com/Luke-SNAW)\n- 📜 [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}