{"pageProps":{"note":{"id":"0bqed1lx0c7hfr0txl97vrz","title":"Why Functional Programming Should Be the Future of Software Development","desc":"","updated":1667433307539,"created":1667433066928,"custom":{},"fname":"dev.functional-programming.spectrum-ieee__functional-programming","type":"note","vault":{"fsPath":"vault"},"contentHash":"720f071a044703a689559c5b931fb082","links":[],"anchors":{"with-functional-programming-less-is-more":{"type":"header","text":"With functional programming, less is more","value":"with-functional-programming-less-is-more","line":24,"column":0,"depth":2},"nullifying-problems-with-null-references":{"type":"header","text":"Nullifying problems with null references","value":"nullifying-problems-with-null-references","line":40,"column":0,"depth":2},"avoiding-null-reference-surprises":{"type":"header","text":"Avoiding Null-Reference Surprises","value":"avoiding-null-reference-surprises","line":70,"column":0,"depth":3},"functional-programming-has-a-steep-learning-curve":{"type":"header","text":"Functional programming has a steep learning curve","value":"functional-programming-has-a-steep-learning-curve","line":94,"column":0,"depth":2},"functional-programmings-future":{"type":"header","text":"Functional programming‚Äôs future","value":"functional-programmings-future","line":122,"column":0,"depth":2}},"children":[],"parent":"HtVLXiN97I2jTm8h2NEVQ","data":{}},"body":"<h1 id=\"why-functional-programming-should-be-the-future-of-software-development\">Why Functional Programming Should Be the Future of Software Development<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#why-functional-programming-should-be-the-future-of-software-development\"></a></h1>\n<blockquote>\n<p>It‚Äôs hard to learn, but your code will produce fewer nasty surprises<br>\nBY <a href=\"https://spectrum.ieee.org/u/charles_scalfani\">Charles Scalfani</a> 23 Oct 2022<br>\n<a href=\"https://spectrum.ieee.org/functional-programming\">https://spectrum.ieee.org/functional-programming</a></p>\n</blockquote>\n<p><strong>You‚Äôd expect</strong> the longest and most costly phase in the lifecycle of a software product to be the initial development of the system, when all those great features are first imagined and then created. In fact, the hardest part comes later, during the maintenance phase. That‚Äôs when programmers pay the price for the shortcuts they took during development.</p>\n<p>So why did they take shortcuts? Maybe they didn‚Äôt realize that they were cutting any corners. Only when their code was deployed and exercised by a lot of users did its hidden flaws come to light. And maybe the developers were rushed. Time-to-market pressures would almost guarantee that their software will contain more bugs than it would otherwise.</p>\n<hr>\n<p>The struggle that most companies have maintaining code causes a second problem: fragility. Every new feature that gets added to the code increases its complexity, which then increases the chance that something will break. It‚Äôs common for software to grow so complex that the developers avoid changing it more than is absolutely necessary for fear of breaking something. In many companies, whole teams of developers are employed not to develop anything new but just to keep existing systems going. You might say that they run a software version of the <a href=\"https://en.wikipedia.org/wiki/Red_Queen%27s_race\">Red Queen‚Äôs race</a>, running as fast as they can just to stay in the same place.</p>\n<p>It‚Äôs a sorry situation. Yet the current trajectory of the software industry is toward increasing complexity, longer product-development times, and greater fragility of production systems. To address such issues, companies usually just throw more people at the problem: more developers, more testers, and more technicians who intervene when systems fail.</p>\n<p>Surely there must be a better way. I‚Äôm part of a growing group of developers who think the answer could be functional programming. Here I describe what functional programming is, why using it helps, and why I‚Äôm so enthusiastic about it.</p>\n<h2 id=\"with-functional-programming-less-is-more\">With functional programming, less is more<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#with-functional-programming-less-is-more\"></a></h2>\n<p>A good way to understand the rationale for functional programming is by considering something that happened more than a half century ago. In the late 1960s, a programming paradigm emerged that aimed to improve the quality of code while reducing the development time needed. It was called <a href=\"https://en.wikipedia.org/wiki/Structured_programming\">structured programming</a>.</p>\n<p>Various languages emerged to foster structured programming, and some existing languages were modified to better support it. One of the most notable features of these structured-programming languages was not a feature at all: It was the absence of something that had been around a long time‚Äî <a href=\"https://en.wikipedia.org/wiki/Goto\">the GOTO statement</a>.</p>\n<p>The GOTO statement is used to redirect program execution. Instead of carrying out the next statement in sequence, the flow of the program is redirected to some other statement, the one specified in the GOTO line, typically when some condition is met.</p>\n<p>The elimination of the GOTO was based on what programmers had learned from using it‚Äîthat it made the program very hard to understand. Programs with GOTOs were often referred to as spaghetti code because the sequence of instructions that got executed could be as hard to follow as a single strand in a bowl of spaghetti.</p>\n<p>The inability of these developers to understand how their code worked, or why it sometimes didn‚Äôt work, was a complexity problem. Software experts of that era believed that those GOTO statements <a href=\"https://dl.acm.org/doi/10.1145/362929.362947\">were creating unnecessary complexity</a> and that the GOTO had to, well, go.</p>\n<p>Back then, this was a radical idea, and many programmers resisted the loss of a statement that they had grown to rely on. The debate went on for more than a decade, but in the end, the GOTO went extinct, and no one today would argue for its return. That‚Äôs because its elimination from higher-level programming languages greatly reduced complexity and boosted the reliability of the software being produced. It did this by limiting what programmers could do, which ended up making it easier for them to reason about the code they were writing.</p>\n<p>Although the software industry has eliminated GOTO from modern higher-level languages, software nevertheless continues to grow in complexity and fragility. Looking for how else such programming languages could be modified to avoid some common pitfalls, software designers can find inspiration, curiously enough, from their counterparts on the hardware side.</p>\n<h2 id=\"nullifying-problems-with-null-references\">Nullifying problems with null references<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#nullifying-problems-with-null-references\"></a></h2>\n<p>In designing hardware for a computer, you can‚Äôt have a resistor shared by, say, both the keyboard and the monitor‚Äôs circuitry. But programmers do this kind of sharing all the time in their software. It‚Äôs called shared global state: Variables are owned by no one process but can be changed by any number of processes, even simultaneously.</p>\n<p>Now, imagine that every time you ran your microwave, your dishwasher‚Äôs settings changed from Normal Cycle to Pots and Pans. That, of course, doesn‚Äôt happen in the real world, but in software, this kind of thing goes on all the time. Programmers write code that calls a function, expecting it to perform a single task. But many functions have side effects that change the shared global state, <a href=\"https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil\">giving rise to unexpected consequences</a>.</p>\n<p>In hardware, that doesn‚Äôt happen because the laws of physics curtail what‚Äôs possible. Of course, hardware engineers can mess up, but not like you can with software, where just too many things are possible, for better or worse.</p>\n<p>Another complexity monster lurking in the software quagmire is called a <a href=\"https://en.wikipedia.org/wiki/Null_pointer\">null reference</a>, meaning that a reference to a place in memory points to nothing at all. If you try to use this reference, an error ensues. So programmers have to remember to check whether something is null before trying to read or change what it references.</p>\n<p>Nearly every popular language today has this flaw. The pioneering computer scientist <a href=\"http://www.cs.ox.ac.uk/people/tony.hoare/\">Tony Hoare</a> introduced null references in the <a href=\"https://en.wikipedia.org/wiki/ALGOL\">ALGOL</a> language back in 1965, and it was later incorporated into numerous other languages. Hoare explained that he did this ‚Äúsimply because it was so easy to implement,‚Äù but today he considers it to be a ‚Äúbillion-dollar mistake.‚Äù That‚Äôs because it has caused countless bugs when a reference that the programmer expects to be valid is really a null reference.</p>\n<p>Software developers need to be extremely disciplined to avoid such pitfalls, and sometimes they don‚Äôt take adequate precautions. The architects of structured programming knew this to be true for GOTO statements and left developers no escape hatch. To guarantee the improvements in clarity that GOTO-free code promised, they knew that they‚Äôd have to eliminate it entirely from their structured-programming languages.</p>\n<p>History is proof that removing a dangerous feature can greatly improve the quality of code. Today, we have a slew of dangerous practices that compromise the robustness and maintainability of software. Nearly all modern programming languages have some form of null references, shared global state, and functions with side effects‚Äîthings that are far worse than the GOTO ever was.</p>\n<p>How can those flaws be eliminated? It turns out that the answer <a href=\"https://www.math-cs.gordon.edu/courses/cps323/LISP/lisp.html\">has been around for decades</a>: purely functional programming languages.</p>\n<p>Of the top dozen functional-programming languages, Haskell is by far the most popular, judging by the number of GitHub repositories that use these languages.</p>\n<p>The first purely functional language to become popular, called <a href=\"https://www.haskell.org/\">Haskell</a>, was created in 1990. So by the mid-1990s, the world of software development really had the solution to the vexing problems it still faces. Sadly, the hardware of the time often wasn‚Äôt powerful enough to make use of the solution. But today‚Äôs processors can easily manage the demands of Haskell and other purely functional languages.</p>\n<p>Indeed, software based on pure functions is particularly well suited to modern <a href=\"https://spectrum.ieee.org/the-trouble-with-multicore\">multicore CPUs</a>. That‚Äôs because pure functions operate only on their input parameters, making it impossible to have any interactions between different functions. This allows the compiler to be optimized to produce code that runs on multiple cores efficiently and easily.</p>\n<p>As the name suggests, with purely functional programming, the developer can write only pure functions, which, by definition, cannot have side effects. With this one restriction, you increase stability, open the door to compiler optimizations, and end up with code that‚Äôs far easier to reason about.</p>\n<p>But what if a function needs to know or needs to manipulate the state of the system? In that case, the state is passed through a long chain of what are called composed functions‚Äîfunctions that pass their outputs to the inputs of the next function in the chain. By passing the state from function to function, each function has access to it and there‚Äôs no chance of another concurrent programming thread modifying that state‚Äîanother common and costly fragility found in far too many programs.</p>\n<hr>\n<h3 id=\"avoiding-null-reference-surprises\">Avoiding Null-Reference Surprises<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#avoiding-null-reference-surprises\"></a></h3>\n<p><strong>A comparison of Javascript and Purescript shows how the latter can help programmers avoid bugs.</strong></p>\n<p><img src=\"/assets/images/a-comparison-of-javascript-and-purescript-shows-how-the-latter-can-help-programmers-avoid-bugs.webp\"></p>\n<hr>\n<p>Functional programming also has a solution to Hoare‚Äôs ‚Äúbillion-dollar mistake,‚Äù null references. It addresses that problem by disallowing nulls. Instead, there is a construct usually called <em>Maybe</em> (or <em>Option</em> in some languages). A <em>Maybe</em> can be <em>Nothing</em> or <em>Just</em> some value. Working with <em>Maybe__s</em> forces developers to always consider both cases. They have no choice in the matter. They must handle the <em>Nothing</em> case every single time they encounter a <em>Maybe</em>. Doing so eliminates the many bugs that null references can spawn.</p>\n<p>Functional programming also requires that data be immutable, meaning that once you set a variable to some value, it is forever that value. Variables are more like variables in math. For example, to compute a formula, <em>y</em> = <em>x_2 + 2_x</em> ‚Äì 11, you pick a value for <em>x</em> and at no time during the computation of <em>y</em> does <em>x</em> take on a different value. So, the same value for <em>x</em> is used when computing <em>x_2 as is used when computing 2_x</em>. In most programming languages, there is no such restriction. You can compute <em>x_2 with one value, then change the value of _x</em> before computing 2<em>x</em>. By disallowing developers from changing (mutating) values, they can use the same reasoning they did in middle-school algebra class.</p>\n<p>Unlike most languages, functional programming languages are deeply rooted in mathematics. It‚Äôs this lineage in the highly disciplined field of mathematics that gives functional languages their biggest advantages.</p>\n<p>Why is that? It‚Äôs because people have been working on mathematics for thousands of years. It‚Äôs pretty solid. Most programming paradigms, such as object-oriented programming, have at most half a dozen decades of work behind them. They are crude and immature by comparison.</p>\n<blockquote>\n<p>Imagine if every time you ran your microwave, your dishwasher‚Äôs settings changed from Normal Cycle to Pots and Pans. In software, this kind of thing goes on all the time.</p>\n</blockquote>\n<p>Let me share an example of how programming is sloppy compared with mathematics. We typically teach new programmers to forget what they learned in math class when they first encounter the statement <em>x = x + 1</em>. In math, this equation has zero solutions. But in most of today‚Äôs programming languages, <em>x = x + 1</em> is not an equation. It is a <em>statement</em> that commands the computer to take the value of <em>x</em>, add one to it, and put it back into a variable called <em>x</em>.</p>\n<p><strong>In functional programming, there are no statements, only <em>expressions</em>.</strong> Mathematical thinking that we learned in middle school can now be employed when writing code in a functional language.</p>\n<p>Thanks to functional purity, you can reason about code using algebraic substitution to help reduce code complexity in the same way you reduced the complexity of equations back in algebra class. In non-functional languages (imperative languages), there is no equivalent mechanism for reasoning about how the code works.</p>\n<h2 id=\"functional-programming-has-a-steep-learning-curve\">Functional programming has a steep learning curve<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#functional-programming-has-a-steep-learning-curve\"></a></h2>\n<p>Pure functional programming solves many of our industry‚Äôs biggest problems by removing dangerous features from the language, making it harder for developers to shoot themselves in the foot. At first, these limitations may seem drastic, as I‚Äôm sure the 1960s developers felt regarding the removal of GOTO. But the fact of the matter is that it‚Äôs both liberating and empowering to work in these languages‚Äîso much so that nearly all of today‚Äôs most popular languages have incorporated functional features, although they remain fundamentally imperative languages.</p>\n<p>The biggest problem with this hybrid approach is that it still allows developers to ignore the functional aspects of the language. Had we left GOTO as an option 50 years ago, we might still be struggling with spaghetti code today.</p>\n<p>To reap the full benefits of pure functional programming languages, you can‚Äôt compromise. You need to use languages that were designed with these principles from the start. Only by adopting them will you get the many benefits that I‚Äôve outlined here.</p>\n<p>But functional programming isn‚Äôt a bed of roses. It comes at a cost. Learning to program according to this functional paradigm is almost like learning to program again from the beginning. In many cases, developers must familiarize themselves with math that they didn‚Äôt learn in school. The required math isn‚Äôt difficult‚Äîit‚Äôs just new and, to the math phobic, scary.</p>\n<p>More important, developers need to learn a new way of thinking. At first this will be a burden, because they are not used to it. But with time, this new way of thinking becomes second nature and ends up reducing cognitive overhead compared with the old ways of thinking. The result is a massive gain in efficiency.</p>\n<p>But making the transition to functional programming can be difficult. My own journey doing so a few years back is illustrative.</p>\n<p>I decided to learn Haskell‚Äîand needed to do that on a business timeline. This was the most difficult learning experience of my 40-year career, in large part because there was no definitive source for helping developers make the transition to functional programming. Indeed, no one had written anything very comprehensive about functional programming in the prior three decades.</p>\n<blockquote>\n<p>To reap the full benefits of pure functional programming languages, you can‚Äôt compromise. You need to use languages that were designed with these principles from the start.</p>\n</blockquote>\n<p>I was left to pick up bits and pieces from here, there, and everywhere. And I can attest to the gross inefficiencies of that process. It took me three months of days, nights, and weekends living and breathing Haskell. But finally, I got to the point that I could write better code with it than with anything else.</p>\n<p>When I decided that our company should switch to using functional languages, I didn‚Äôt want to put my developers through the same nightmare. So, I started building a curriculum for them to use, which became the basis for a book intended to help developers transition into functional programmers. In <a href=\"https://leanpub.com/fp-made-easier\">my book</a>, I provide guidance for obtaining proficiency in a functional language called <a href=\"https://www.purescript.org/\">PureScript</a>, which stole all the great aspects of Haskell and improved on many of its shortcomings. In addition, it‚Äôs able to operate in both the browser and in a back-end server, making it a great solution for many of today‚Äôs software demands.</p>\n<p>While such learning resources can only help, for this transition to take place broadly, software-based businesses must invest more in their biggest asset: their developers. At my company, <a href=\"http://www.panosoft.com/\">Panoramic Software</a>, where I‚Äôm the chief technical officer, we‚Äôve made this investment, and all new work is being done in either PureScript or Haskell.</p>\n<p>We started down the road of adopting functional languages three years ago, beginning with another pure functional language called <a href=\"https://elm-lang.org/\">Elm</a> because it is a simpler language. (Little did we know we would eventually outgrow it.) It took us about a year to start reaping the benefits. But since we got over the hump, it‚Äôs been wonderful. We have had no production runtime bugs, which were so common in what we were formerly using, <a href=\"https://en.wikipedia.org/wiki/JavaScript\">JavaScript</a> on the front end and Java on the back. This improvement allowed the team to spend far more time adding new features to the system. Now, we spend almost no time debugging production issues.</p>\n<p>But there are still challenges when working with a language that relatively few others use‚Äîin particular, the lack of online help, documentation, and example code. And it‚Äôs hard to hire developers with experience in these languages. Because of that, my company uses recruiters who specialize in finding functional programmers. And when we hire someone with no background in functional programming, we put them through a training process for the first few months to bring them up to speed.</p>\n<h2 id=\"functional-programmings-future\">Functional programming‚Äôs future<a aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#functional-programmings-future\"></a></h2>\n<p>My company is small. It delivers software to governmental agencies to enable them to help veterans receive benefits from the <a href=\"https://www.va.gov/\">U.S. Department of Veteran‚Äôs Affairs</a>. It‚Äôs extremely rewarding work, but it‚Äôs not a lucrative field. With razor-slim margins, we must use every tool available to us to do more with fewer developers. And for that, functional programming is just the ticket.</p>\n<p>It‚Äôs very common for unglamorous businesses like ours to have difficulty attracting developers. But we are now able to hire top-tier people because they want to work on a functional codebase. Being ahead of the curve on this trend, we can get talent that most companies our size could only dream of.</p>\n<p>I anticipate that the adoption of pure functional languages will improve the quality and robustness of the whole software industry while greatly reducing time wasted on bugs that are simply impossible to generate with functional programming. It‚Äôs not magic, but sometimes it feels like that, and I‚Äôm reminded of how good I have it every time I‚Äôm forced to work with a non-functional codebase.</p>\n<p>One sign that the software industry is preparing for a paradigm shift is that functional features are showing up in more and more mainstream languages. It will take much more work for the industry to make the transition fully, but the benefits of doing so are clear, and that is no doubt where things are headed.</p>","noteIndex":{"id":"Iy0MoL0KnL55Br3AfTS2C","title":"Luke","desc":"","updated":1766965759366,"created":1644449449778,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":"vault"},"contentHash":"a724de3efd251cf89fe82a5860d9008b","links":[{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"life-tips","position":{"start":{"line":43,"column":5,"offset":2710},"end":{"line":43,"column":29,"offset":2734},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"life-tips","anchorHeader":"wodenokoto"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2026.articles","alias":"What I read in 2026","position":{"start":{"line":72,"column":3,"offset":4440},"end":{"line":72,"column":45,"offset":4482},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2026.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2025.articles","alias":"2025","position":{"start":{"line":73,"column":5,"offset":4487},"end":{"line":73,"column":32,"offset":4514},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2025.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2024.articles","alias":"2024","position":{"start":{"line":74,"column":5,"offset":4519},"end":{"line":74,"column":32,"offset":4546},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2024.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2023.articles","alias":"2023","position":{"start":{"line":75,"column":5,"offset":4551},"end":{"line":75,"column":32,"offset":4578},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2023.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"read.2022.articles","alias":"2022","position":{"start":{"line":76,"column":5,"offset":4583},"end":{"line":76,"column":32,"offset":4610},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"read.2022.articles"}},{"type":"wiki","from":{"fname":"root","id":"Iy0MoL0KnL55Br3AfTS2C","vaultName":"vault"},"value":"journal.what-i-struggled-brag-in","position":{"start":{"line":82,"column":3,"offset":4746},"end":{"line":82,"column":39,"offset":4782},"indent":[]},"xvault":false,"sameFile":false,"to":{"fname":"journal.what-i-struggled-brag-in"}}],"anchors":{"what-i-read-in-past":{"type":"header","text":"What I read in past","value":"what-i-read-in-past","line":76,"column":0,"depth":2}},"children":["zd4mq442jike0pr0wba1u3m","6hzeqsofq67gdk88flxlkhp","778ijii93yu5uwnrwmn5zi4","g1fngdjl25nes6fs3lip602","ZbdkdApFqLdks4Moq92R9","uoc5hhki3o4py15cesddu8q","9qf7j06jtdkm6rnx9ymvwb0","5zn10cvj7ajy2gh2is5nqmg","4qo9ma0z0yu1czns6pxl7y5","ok0e729ho7o09xetujkxc0m","GR5x8HnNFEN6fU2UBSEIK","yirtnlj8q24yutcf3ss1xqy","eq0wc6t7wl2wv221yb68ro4","7x2fnv4j6gxts08qk0jguny","ettkt3iClONnxpbGwBVLl","7l4knev6v613tbuoskvmbdg","hvh5bud6yp7dc89tuh95tr9","4fvoqrplw0cweo554usbjos","f8qsfql0a9v8thpeo82udfa","1swsbrhqi9jk41v9eodyi5q","SQqYupi6EFddTerBA8RRD","hjNeNc1F2JUh0lTWanH4h","qf0l4wbrc9jgooyzexmbq5v","o7xruzrah5wzqetottecss7","z1zo2mp6ddji5p317i4x9xw","v06c2tjelh341x4resa50fh","0yqesk4rcffwgyuab5x8rfa","sy2vkbtyu671chkvgn1yt8j","ufixpmxoydiccoh59kphrib","alswadkx4wb05y1z9iwfzfv","1daut9dpw70xd0zh5a7j5p4"],"parent":null,"data":{},"body":"\nHi there üëã. I'm a Front-end developer.\n\n---\n\n- ÌòÑÏã§ÏùÄ Ïù∏Í∞ÑÏùò Ïó∞ÏÇ∞ÏúºÎ°ú ÏôÑÏ†ÑÌûà ÌååÏïÖÌï† Ïàò ÏóÜÎäî Î≥µÏû°Í≥Ñ. Ï£ºÏñ¥ÏßÑ ÏÉÅÌô©Í≥º Îä•Î†•ÏúºÎ°ú Ìï† Ïàò ÏûàÎäî ÏµúÏÑ†Ïùò Ï†ÅÏùëÏùÄ Îã®ÏàúÌï®Í≥º Íæ∏Ï§ÄÌï®.\n\n  - ÌååÏÇ∞ÏùÑ Î©¥ÌïòÎäî ÏÑ†ÏóêÏÑú Ïó¨Îü¨Í∞ÄÏßÄÎ•º Ìï¥Î≥¥Í≥† ÏûêÏã†ÏóêÍ≤å ÎßûÎäî Í±∏ ÏúÑÏ£ºÎ°ú Íæ∏Ï§ÄÌûà. Í∑∏Î•º ÏúÑÌï¥ Îã®Ïàú, Ìé∏Ïïà, ÏæåÏ†ÅÌï®Ïù¥ ÌïÑÏöî.\n\n- ü•± -> ü§îüí°üå± - [On The Death of Daydreaming](https://www.afterbabel.com/p/on-the-death-of-daydreaming)\n  - boredom -> easy fun -> art -> profit?\n\n> I've often described my motivation for building software to others using imagery: I like to go find a secluded beach, build a large, magnificent sand castle, and then walk away. Will anyone notice? Probably not. Will the waves eventually destroy it? Yep. Did I still get immense satisfaction? Absolutely. - [aliasxneo](https://news.ycombinator.com/item?id=41497113)\n\n> We love to see the process, not just the result. The imperfections in your work can be beautiful if they show your struggle for perfection, not a lack of care. - [ralphammer](https://ralphammer.com/is-perfection-boring/)\n\n> Simplicity, even if it sacrifices some ideal functionality has better survival characteristics than the-right-thing. - [The Rise of Worse is Better](https://www.dreamsongs.com/RiseOfWorseIsBetter.html)\n\n> [Roberto Blake was talking about making 100 crappy videos](https://www.youtube.com/watch?v=OnUBaQ1Sp_E) to get better over time. Putting in the reps and improving a little bit each time.\n>\n> Putting in the work without expecting any external reward at first (eg views, followers, likes, etc) will pay off in the long run. - [100 Scrappy Things](https://www.florin-pop.com/blog/100-scrappy-things/)\n\n> Make the difficult habitual, the habitual easy, and the easy beautiful. - [Constantin S. Stanislavski](https://www.goodreads.com/quotes/7102271-make-the-difficult-habitual-the-habitual-easy-and-the-easy)\n\n> A good match is a **structured** dance, where players aim to **score** while they are following well-defined **rules**. This **freedom within a structure** is what makes it fun. - [ralphammer](https://ralphammer.com/how-to-get-started/)\n\n- [Pivot Points](https://longform.asmartbear.com/pivot-points/)\n\n  - non-judgmental aspects of personality that can be strengths in some contexts and weaknesses in others\n  - Pivot Points are fixed in the short term\n\n- [Hedged Bets](https://longform.asmartbear.com/predict-the-future/#hedged-bets)\n  - trading slightly less maximum upside for predictable, net-positive outcomes.\n\n> ‚ÄúMotivation often comes after starting, not before. Action produces momentum.‚Äù\n> [When you start a new habit, it should take less than two minutes to do.](https://jamesclear.com/how-to-stop-procrastinating)\n>\n> - James Clear\n\n> Focus is more about **not** keeping busy when you need to wait for something.  \n> Eat the boredom for a minute.\n>\n> - [[life-tips#wodenokoto]]\n\n> [4 minutes run hard enough to push heart rate to 90%, 3 minutes recover, repeat 4 times](https://news.ycombinator.com/item?id=34213181)\n>\n> - https://www.ntnu.edu/cerg/advice\n> - [Get running with Couch to 5K](https://www.nhs.uk/live-well/exercise/running-and-aerobic-exercises/get-running-with-couch-to-5k/)\n\n> [recommended routine - bodyweightfitness](https://www.reddit.com/r/bodyweightfitness/wiki/kb/recommended_routine/) - I Don't Have This Much Time!\n>\n> - Don't workout at all (saves anywhere from 20 to 60 minutes, but really, really, really, really, really, really, really, really, really not recommended)\n\n> ÎèÑÎ¨¥ÏßÄ ÏùΩÌûàÏßÄ ÏïäÎäî Ï±Ö ÏïûÏóêÏÑú ÎÇ¥Í∞Ä ÌÉùÌïú Î∞©Î≤ïÏùÄ ÌéºÏ≥êÏßÑ ÌéòÏù¥ÏßÄ ÏïûÏóêÏÑú Î©çÎïåÎ¶¨Í∏∞Ïù¥Îã§. Îã§Î•¥Í≤å ÌëúÌòÑÌïòÎ©¥ Ïù¥Î†áÎã§. ÌéºÏ≥êÏßÑ Îëê ÌéòÏù¥ÏßÄ ÏïûÏóêÏÑú Ïò§Îûò Î®∏Î¨ºÍ∏∞.\n>\n> Ï±ÖÏùÑ ÌéºÏ≥êÎÜìÎäî Í≤ÉÏúºÎ°ú Ï∂©Î∂ÑÌïòÎã§. ÏùΩÏßÄ Î™ªÌï¥ÎèÑ Ï¢ãÎã§. Îß§Ïùº Ï†ïÌï¥ÏßÑ ÏßÑÎèÑÎ•º ÎÇòÍ∞ÄÏïº ÌïòÎäî ÌïôÍµê ÏàòÏóÖÏù¥ ÏïÑÎãàÎãàÍπå. ÌïòÏßÄÎßå ÏùΩÏßÄ ÏïäÏïÑÎèÑ Í¥úÏ∞ÆÎã§Í≥† Ìï¥ÏÑú ÌéºÏ≥êÎëêÏßÄÏ°∞Ï∞® ÏïäÏúºÎ©¥ Í≥§ÎûÄÌïòÎã§. Í∞ÄÎä•Ìïú Ìïú ÏûêÏ£º Ï±ÖÏùÑ ÌéºÏ≥êÎëêÎèÑÎ°ù ÌïòÏûê. Ï†ÑÌòÄ ÏùΩÏßÄ ÏïäÍ≥† Î©çÌïòÎãà Î∞îÎùºÎ≥¥Í≥† ÏûàÎã§Í∞Ä Îã§Ïãú ÎçÆÍ≤å ÎêòÎçîÎùºÎèÑ\n>\n> - ÎßâÎßâÌïú ÎèÖÏÑú. ÏãúÎ°úÍµ∞. P.10~13\n\n> I think it should be everyone's primary focus to sleep well, drink water, get outside, get active, and eat generally decently. I hate to say it, but if you're not eating a good amount of vegetables and fruit, decent protein, sleep, etc, no amount of XYZ will catch up to that detriment. - [CE02](https://news.ycombinator.com/item?id=35056071)\n\n> My real battle is doing good versus doing nothing. - [Deirdre Sullivan](https://www.npr.org/2005/08/08/4785079/always-go-to-the-funeral)\n\n[Kind Engineering](https://kind.engineering/) - How To Engineer Kindness\n\n> Sometimes magic is just someone spending more time on something than anyone else might reasonably expect. - [Teller](https://www.goodreads.com/quotes/6641527-sometimes-magic-is-just-someone-spending-more-time-on-something)\n\n---\n\n## What I read in past\n\n- [[What I read in 2026|read.2026.articles]]\n  - [[2025|read.2025.articles]]\n  - [[2024|read.2024.articles]]\n  - [[2023|read.2023.articles]]\n  - [[2022|read.2022.articles]]\n- üìù [Gists](https://gist.github.com/Luke-SNAW)\n- üìú [Journals](https://luke-snaw.github.io/Luke-SNAW__netlify-CMS.github.io/)\n\n---\n\n- [[journal.what-i-struggled-brag-in]]\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link","taskCompleteStatus":["done","x"]},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":false,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"dendronVersion":"0.115.0","enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false,"enableFrontmatterTags":true,"enableHashesForFMTags":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Luke SNAW","description":"Personal knowledge space"},"github":{"enableEditLink":false,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"lookup","siteUrl":"https://luke-snaw.github.io/","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true}